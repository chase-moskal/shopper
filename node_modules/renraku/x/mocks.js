import { ApiError } from "./error.js";
import { objectMap } from "./tools/object-map.js";
import { is_service } from "./types.js";
export const mock = (options = {}) => ({
    forService: (service) => mockService(service, [], options),
    forApi(api) {
        return {
            withMetaMap(map, getHeaders = async () => undefined) {
                const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withMeta(getter, getHeaders));
                return recurse2(api, map);
            },
            withAuthMap(map) {
                const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withAuth(getter));
                return recurse2(api, map);
            },
        };
    },
});
function mockService(service, path, options) {
    function prepareProxy(getAuth) {
        const overrides = {};
        return new Proxy({}, {
            set: (t, key, value) => {
                overrides[key] = value;
                return true;
            },
            get: (t, key) => {
                var _a;
                return ((_a = overrides[key]) !== null && _a !== void 0 ? _a : (async (...params) => {
                    const auth = await getAuth();
                    const method = service.expose(auth)[key];
                    if (method) {
                        return options.spike
                            ? options.spike([...path, key].join("."), method, ...params)
                            : method(...params);
                    }
                    else
                        throw new ApiError(400, `renraku remote method "${key}" not found`);
                }));
            },
        });
    }
    return {
        withMeta(getMeta, getHeaders = async () => undefined) {
            return prepareProxy(async () => service.policy(await getMeta(), await getHeaders()));
        },
        withAuth(getAuth) {
            return prepareProxy(getAuth);
        },
    };
}
function prepareRecursiveMapping(handler) {
    return function recursiveMapping(apiGroup, mapGroup, path = []) {
        return objectMap(apiGroup, (value, key) => {
            const newPath = [...path, key];
            if (value[is_service]) {
                const service = value;
                return handler(service, mapGroup[key], newPath);
            }
            else {
                const nextApiGroup = value;
                const nextMapGroup = mapGroup[key];
                return recursiveMapping(nextApiGroup, nextMapGroup, newPath);
            }
        });
    };
}
//# sourceMappingURL=mocks.js.map