function isPlainObject(x) {
    return (typeof x === "object"
        && x !== null
        && !Array.isArray(x)
        && !(x instanceof Promise));
}
function unzipRecursive(object, path = []) {
    let spec = [];
    for (const [key, value] of Object.entries(object)) {
        if (isPlainObject(value))
            spec = [
                ...spec,
                ...unzipRecursive(value, [...path, key])
            ];
        else
            spec.push([[...path, key], value]);
    }
    return spec;
}
export function unzip(object) {
    return unzipRecursive(object);
}
export async function waitSpec(spec) {
    const paths = [];
    const awaitables = [];
    for (const [path, value] of spec) {
        paths.push(path);
        awaitables.push(value);
    }
    const values = await Promise.all(awaitables);
    return paths.map((path, index) => [path, values[index]]);
}
export function applyProperty(object, path, value) {
    let level = object;
    for (let i = 0; i < path.length; i++) {
        const final = i === (path.length - 1);
        const key = path[i];
        const existing = level[key];
        if (final)
            level[key] = value;
        else {
            const existingIsObject = isPlainObject(existing);
            if (existingIsObject)
                level = existing;
            else {
                const next = {};
                level[key] = next;
                level = next;
            }
        }
    }
}
export function zip(spec) {
    const result = {};
    for (const [path, value] of spec)
        applyProperty(result, path, value);
    return result;
}
export async function waitForProperties(input) {
    const specWithPromises = unzip(input);
    const specWithValues = await waitSpec(specWithPromises);
    return zip(specWithValues);
}
//# sourceMappingURL=zippy.js.map