import { XiomeComponentOptions } from "./types/xiome-component-options.js";
export declare function getComponents(options: XiomeComponentOptions): {
    XiomeStoreConnect: import("../../../types/mixin.js").Mixin<typeof import("../../../features/store/frontend/components/connect/component.js").XiomeStoreConnect, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        storeModel: {
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            load: () => Promise<void>;
            initialize: () => Promise<void>;
            refresh: () => Promise<void>;
            subscriptions: {
                addPlan(options: {
                    planLabel: string;
                    tier: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionTierDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan>;
                addTier(options: {
                    label: string;
                    planId: string;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionTier>;
                editPlan({ planId, label, archived }: {
                    planId: string;
                    label: string;
                    archived: boolean;
                }): Promise<void>;
                editTier({ planId, tierId, label, active, pricing }: {
                    planId: string;
                    tierId: string;
                    label: string;
                    active: boolean;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<void>;
                purchase({ stripePriceId, showLoadingSpinner }: {
                    stripePriceId: string;
                    showLoadingSpinner?: boolean;
                }): Promise<void>;
                cancel(tierId: string): Promise<void>;
                uncancel(tierId: string): Promise<void>;
                load: () => Promise<void>;
            };
            billing: {
                load: () => Promise<void>;
                allowance: {
                    readonly manageStore: boolean;
                    readonly connectStripeAccount: boolean;
                    readonly giveAwayFreebies: boolean;
                };
                customerPortal: () => Promise<void>;
            };
            connect: {
                load: () => Promise<void>;
                readonly isOnboardingNeeded: boolean;
                readonly isAllowedToOnboard: boolean;
                stripeAccountOnboarding(): Promise<void>;
                stripeLogin(): Promise<void>;
                pause(): Promise<void>;
                resume(): Promise<void>;
            };
            snap: import("@chasemoskal/snapstate").Snapstate<{
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            }>;
            state: {
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            };
            allowance: {
                readonly manageStore: boolean;
                readonly connectStripeAccount: boolean;
                readonly giveAwayFreebies: boolean;
            };
            get: {
                is: {
                    readonly storeActive: boolean;
                    readonly userLoggedIn: boolean;
                };
                user: {
                    readonly access: import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                };
                connect: {
                    readonly status: import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus;
                    readonly details: import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails;
                };
                subscriptions: {
                    readonly plans: import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[];
                    readonly mySubscriptionDetails: import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[];
                };
                billing: {
                    readonly paymentMethod: import("../../../features/store/isomorphic/concepts.js").PaymentMethod;
                };
            };
        };
    }>>;
    XiomeStoreSubscriptionPlanning: import("../../../types/mixin.js").Mixin<typeof import("../../../features/store/frontend/components/subscription-planning/component.js").XiomeStoreSubscriptionPlanning, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        storeModel: {
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            load: () => Promise<void>;
            initialize: () => Promise<void>;
            refresh: () => Promise<void>;
            subscriptions: {
                addPlan(options: {
                    planLabel: string;
                    tier: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionTierDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan>;
                addTier(options: {
                    label: string;
                    planId: string;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionTier>;
                editPlan({ planId, label, archived }: {
                    planId: string;
                    label: string;
                    archived: boolean;
                }): Promise<void>;
                editTier({ planId, tierId, label, active, pricing }: {
                    planId: string;
                    tierId: string;
                    label: string;
                    active: boolean;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<void>;
                purchase({ stripePriceId, showLoadingSpinner }: {
                    stripePriceId: string;
                    showLoadingSpinner?: boolean;
                }): Promise<void>;
                cancel(tierId: string): Promise<void>;
                uncancel(tierId: string): Promise<void>;
                load: () => Promise<void>;
            };
            billing: {
                load: () => Promise<void>;
                allowance: {
                    readonly manageStore: boolean;
                    readonly connectStripeAccount: boolean;
                    readonly giveAwayFreebies: boolean;
                };
                customerPortal: () => Promise<void>;
            };
            connect: {
                load: () => Promise<void>;
                readonly isOnboardingNeeded: boolean;
                readonly isAllowedToOnboard: boolean;
                stripeAccountOnboarding(): Promise<void>;
                stripeLogin(): Promise<void>;
                pause(): Promise<void>;
                resume(): Promise<void>;
            };
            snap: import("@chasemoskal/snapstate").Snapstate<{
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            }>;
            state: {
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            };
            allowance: {
                readonly manageStore: boolean;
                readonly connectStripeAccount: boolean;
                readonly giveAwayFreebies: boolean;
            };
            get: {
                is: {
                    readonly storeActive: boolean;
                    readonly userLoggedIn: boolean;
                };
                user: {
                    readonly access: import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                };
                connect: {
                    readonly status: import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus;
                    readonly details: import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails;
                };
                subscriptions: {
                    readonly plans: import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[];
                    readonly mySubscriptionDetails: import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[];
                };
                billing: {
                    readonly paymentMethod: import("../../../features/store/isomorphic/concepts.js").PaymentMethod;
                };
            };
        };
    }>>;
    XiomeStoreSubscriptionTier: import("../../../types/constructor.js").Constructor<import("lit-element/lit-element.js").LitElement & {
        basics: import("../../../features/store/frontend/views/tier/types.js").TierBasics;
        context: import("../../../features/store/frontend/views/tier/types.js").TierContext;
        interactivity: import("../../../features/store/frontend/views/tier/types.js").TierInteractivity;
    }>;
    XiomeStoreSubscriptionCatalog: import("../../../types/constructor.js").Constructor<import("lit-element/lit-element.js").LitElement & import("../../../features/store/frontend/components/subscription-catalog/utils/catalog-props.js").CatalogProps>;
    XiomeStoreCustomerPortal: import("../../../types/mixin.js").Mixin<typeof import("../../../features/store/frontend/components/customer-portal/component.js").XiomeStoreCustomerPortal, import("../../../framework/component.js").WithShare<{
        storeModel: {
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            load: () => Promise<void>;
            initialize: () => Promise<void>;
            refresh: () => Promise<void>;
            subscriptions: {
                addPlan(options: {
                    planLabel: string;
                    tier: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionTierDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan>;
                addTier(options: {
                    label: string;
                    planId: string;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionTier>;
                editPlan({ planId, label, archived }: {
                    planId: string;
                    label: string;
                    archived: boolean;
                }): Promise<void>;
                editTier({ planId, tierId, label, active, pricing }: {
                    planId: string;
                    tierId: string;
                    label: string;
                    active: boolean;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<void>;
                purchase({ stripePriceId, showLoadingSpinner }: {
                    stripePriceId: string;
                    showLoadingSpinner?: boolean;
                }): Promise<void>;
                cancel(tierId: string): Promise<void>;
                uncancel(tierId: string): Promise<void>;
                load: () => Promise<void>;
            };
            billing: {
                load: () => Promise<void>;
                allowance: {
                    readonly manageStore: boolean;
                    readonly connectStripeAccount: boolean;
                    readonly giveAwayFreebies: boolean;
                };
                customerPortal: () => Promise<void>;
            };
            connect: {
                load: () => Promise<void>;
                readonly isOnboardingNeeded: boolean;
                readonly isAllowedToOnboard: boolean;
                stripeAccountOnboarding(): Promise<void>;
                stripeLogin(): Promise<void>;
                pause(): Promise<void>;
                resume(): Promise<void>;
            };
            snap: import("@chasemoskal/snapstate").Snapstate<{
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            }>;
            state: {
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            };
            allowance: {
                readonly manageStore: boolean;
                readonly connectStripeAccount: boolean;
                readonly giveAwayFreebies: boolean;
            };
            get: {
                is: {
                    readonly storeActive: boolean;
                    readonly userLoggedIn: boolean;
                };
                user: {
                    readonly access: import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                };
                connect: {
                    readonly status: import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus;
                    readonly details: import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails;
                };
                subscriptions: {
                    readonly plans: import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[];
                    readonly mySubscriptionDetails: import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[];
                };
                billing: {
                    readonly paymentMethod: import("../../../features/store/isomorphic/concepts.js").PaymentMethod;
                };
            };
        };
    }>>;
    XiomeStoreSubscriptionStatus: import("../../../types/constructor.js").Constructor<import("lit-element/lit-element.js").LitElement>;
    XiomeStoreBillingArea: import("../../../types/mixin.js").Mixin<typeof import("../../../features/store/frontend/components/billing-area/component.js").XiomeStoreBillingArea, import("../../../framework/component.js").WithShare<{
        storeModel: {
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            load: () => Promise<void>;
            initialize: () => Promise<void>;
            refresh: () => Promise<void>;
            subscriptions: {
                addPlan(options: {
                    planLabel: string;
                    tier: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionTierDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan>;
                addTier(options: {
                    label: string;
                    planId: string;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<import("../../../features/store/isomorphic/concepts.js").SubscriptionTier>;
                editPlan({ planId, label, archived }: {
                    planId: string;
                    label: string;
                    archived: boolean;
                }): Promise<void>;
                editTier({ planId, tierId, label, active, pricing }: {
                    planId: string;
                    tierId: string;
                    label: string;
                    active: boolean;
                    pricing: import("../../../features/store/backend/services/subscriptions/types/drafts.js").SubscriptionPricingDraft;
                }): Promise<void>;
                purchase({ stripePriceId, showLoadingSpinner }: {
                    stripePriceId: string;
                    showLoadingSpinner?: boolean;
                }): Promise<void>;
                cancel(tierId: string): Promise<void>;
                uncancel(tierId: string): Promise<void>;
                load: () => Promise<void>;
            };
            billing: {
                load: () => Promise<void>;
                allowance: {
                    readonly manageStore: boolean;
                    readonly connectStripeAccount: boolean;
                    readonly giveAwayFreebies: boolean;
                };
                customerPortal: () => Promise<void>;
            };
            connect: {
                load: () => Promise<void>;
                readonly isOnboardingNeeded: boolean;
                readonly isAllowedToOnboard: boolean;
                stripeAccountOnboarding(): Promise<void>;
                stripeLogin(): Promise<void>;
                pause(): Promise<void>;
                resume(): Promise<void>;
            };
            snap: import("@chasemoskal/snapstate").Snapstate<{
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            }>;
            state: {
                user: {
                    accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                };
                stripeConnect: {
                    connectStatusOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus>;
                    connectDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails>;
                };
                subscriptions: {
                    subscriptionPlansOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[]>;
                    mySubscriptionDetailsOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[]>;
                };
                billing: {
                    paymentMethodOp: import("../../../framework/ops.js").Op<import("../../../features/store/isomorphic/concepts.js").PaymentMethod>;
                };
            };
            allowance: {
                readonly manageStore: boolean;
                readonly connectStripeAccount: boolean;
                readonly giveAwayFreebies: boolean;
            };
            get: {
                is: {
                    readonly storeActive: boolean;
                    readonly userLoggedIn: boolean;
                };
                user: {
                    readonly access: import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                };
                connect: {
                    readonly status: import("../../../features/store/isomorphic/concepts.js").StripeConnectStatus;
                    readonly details: import("../../../features/store/isomorphic/concepts.js").StripeConnectDetails;
                };
                subscriptions: {
                    readonly plans: import("../../../features/store/isomorphic/concepts.js").SubscriptionPlan[];
                    readonly mySubscriptionDetails: import("../../../features/store/isomorphic/concepts.js").SubscriptionDetails[];
                };
                billing: {
                    readonly paymentMethod: import("../../../features/store/isomorphic/concepts.js").PaymentMethod;
                };
            };
        };
    }>>;
    XiomeNotes: import("../../../types/mixin.js").Mixin<typeof import("../../../features/notes/components/notes/xiome-notes.js").XiomeNotes, import("../../../framework/component.js").WithShare<{
        notesModel: {
            initialize: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            };
            stateSubscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            }>) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            readonly isLoggedIn: boolean;
            readonly stats: import("../../../features/notes/types/notes-concepts.js").NotesStats;
            propagateChangeToOtherTabs: import("../../../toolbox/subbies.js").Subbie<undefined>;
            loadStats: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            overwriteStatsOp(op: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>): void;
            createNotesCacheDetails: () => {
                cache: {
                    subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    }>) => () => void;
                    cacheState: {
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    };
                    loginStatusChanged(): Promise<void>;
                    readonly notes: import("../../../features/notes/types/notes-concepts.js").Notes.Any[];
                    fetchAppropriateNotes: () => Promise<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    switchTabNew(): Promise<void>;
                    switchTabOld(): Promise<void>;
                    readonly isNextPageAvailable: boolean;
                    readonly isPreviousPageAvailable: boolean;
                    nextPage(): Promise<void>;
                    previousPage(): Promise<void>;
                    markAllNotesOld(): Promise<void>;
                    markSpecificNoteOld(noteId: string): Promise<void>;
                    markSpecificNoteNew(noteId: string): Promise<void>;
                    readonly totalPages: number;
                };
                setup: () => () => void;
            };
        };
    }>>;
    XiomeNotesIndicator: import("../../../types/mixin.js").Mixin<typeof import("../../../features/notes/components/notes-indicator/xiome-notes-indicator.js").XiomeNotesIndicator, import("../../../framework/component.js").WithShare<{
        notesModel: {
            initialize: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            };
            stateSubscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                statsOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            }>) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            readonly isLoggedIn: boolean;
            readonly stats: import("../../../features/notes/types/notes-concepts.js").NotesStats;
            propagateChangeToOtherTabs: import("../../../toolbox/subbies.js").Subbie<undefined>;
            loadStats: () => Promise<import("../../../features/notes/types/notes-concepts.js").NotesStats>;
            overwriteStatsOp(op: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").NotesStats>): void;
            createNotesCacheDetails: () => {
                cache: {
                    subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    }>) => () => void;
                    cacheState: {
                        old: boolean;
                        pageNumber: number;
                        pageSize: number;
                        notesOp: import("../../../framework/ops.js").Op<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    };
                    loginStatusChanged(): Promise<void>;
                    readonly notes: import("../../../features/notes/types/notes-concepts.js").Notes.Any[];
                    fetchAppropriateNotes: () => Promise<import("../../../features/notes/types/notes-concepts.js").Notes.Any[]>;
                    switchTabNew(): Promise<void>;
                    switchTabOld(): Promise<void>;
                    readonly isNextPageAvailable: boolean;
                    readonly isPreviousPageAvailable: boolean;
                    nextPage(): Promise<void>;
                    previousPage(): Promise<void>;
                    markAllNotesOld(): Promise<void>;
                    markSpecificNoteOld(noteId: string): Promise<void>;
                    markSpecificNoteNew(noteId: string): Promise<void>;
                    readonly totalPages: number;
                };
                setup: () => () => void;
            };
        };
    }>>;
    XiomeChat: import("../../../types/mixin.js").Mixin<typeof import("../../../features/chat/components/xiome-chat/xiome-chat.js").XiomeChat, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        chatModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                connectionOp: import("../../../framework/ops.js").Op<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
                cache: {
                    mutedUserIds: string[];
                    roomStats: import("../../../features/chat/common/types/chat-concepts.js").ChatStats;
                    rooms: {
                        [key: string]: {
                            status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                            posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                        };
                    };
                };
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                connectionOp: import("../../../framework/ops.js").Op<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
                cache: {
                    mutedUserIds: string[];
                    roomStats: import("../../../features/chat/common/types/chat-concepts.js").ChatStats;
                    rooms: {
                        [key: string]: {
                            status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                            posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                        };
                    };
                };
            }>) => () => void;
            subscribeToChange: (...listeners: (() => void | Promise<void>)[]) => () => void;
            readonly allowance: {
                moderateAllChats: boolean;
                participateInAllChats: boolean;
                viewAllChats: boolean;
                banned: boolean;
            };
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            session: (label: string) => Promise<{
                dispose: () => void;
                room: {
                    readonly posts: import("../../../features/chat/common/types/chat-concepts.js").ChatPost[];
                    readonly status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus;
                    readonly muted: string[];
                    readonly weAreMuted: boolean;
                    readonly weAreBanned: boolean;
                    setRoomStatus(status: import("../../../features/chat/common/types/chat-concepts.js").ChatStatus): void;
                    post(draft: import("../../../features/chat/common/types/chat-concepts.js").ChatDraft): void;
                    remove(postIds: string[]): void;
                    clear(): void;
                    mute(userId: string): void;
                    unmute(userId: string): void;
                    unmuteAll(): void;
                };
            }>;
            disconnect: () => Promise<void>;
            reconnect: () => Promise<import("../../../features/chat/common/types/chat-concepts.js").ChatConnection>;
        };
    }>>;
    XiomeVideoHosting: import("../../../types/mixin.js").Mixin<typeof import("../../../features/videos/components/video-hosting/xiome-video-hosting.js").XiomeVideoHosting, import("../../../framework/component.js").WithShare<{
        dacastModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                linkedAccountOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                linkedAccountOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            }>) => () => void;
            onLinkChange: (listener: (context: import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay) => void) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            initialize(): Promise<void>;
            readonly linkedAccount: import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay;
            linkAccount({ apiKey }: {
                apiKey: string;
            }): Promise<import("../../../features/videos/types/dacast-link.js").DacastLinkDisplay>;
            unlinkAccount(): Promise<void>;
        };
    }>>;
    XiomeVideoDisplay: import("../../../types/mixin.js").Mixin<typeof import("../../../features/videos/components/video-display/xiome-video-display.js").XiomeVideoDisplay, import("../../../framework/component.js").WithShare<{
        contentModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            onVideoHostingUpdate(): Promise<void>;
            initializeForModerationData(): Promise<void>;
            initializeForVideo(label: string): Promise<void>;
            readonly allowance: {
                canModerateVideos: boolean;
                canViewAllVideos: boolean;
            };
            readonly catalog: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
            readonly views: import("../../../features/videos/types/video-concepts.js").VideoView[];
            readonly privileges: import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
            readonly shows: import("../../../features/videos/types/video-concepts.js").VideoShow[];
            getView(label: string): import("../../../features/videos/types/video-concepts.js").VideoView;
            getPrivilege(id: string): import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
            getShow(label: string): import("../../../features/videos/types/video-concepts.js").VideoShow;
            setView(view: {
                label: string;
                privileges: string[];
                reference: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
            }): Promise<void>;
            deleteView(label: string): Promise<void>;
        };
    }>>;
    XiomeVideoViews: import("../../../types/mixin.js").Mixin<typeof import("../../../features/videos/components/video-views/xiome-video-views.js").XiomeVideoViews, import("../../../framework/component.js").WithShare<{
        contentModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            onVideoHostingUpdate(): Promise<void>;
            initializeForModerationData(): Promise<void>;
            initializeForVideo(label: string): Promise<void>;
            readonly allowance: {
                canModerateVideos: boolean;
                canViewAllVideos: boolean;
            };
            readonly catalog: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
            readonly views: import("../../../features/videos/types/video-concepts.js").VideoView[];
            readonly privileges: import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
            readonly shows: import("../../../features/videos/types/video-concepts.js").VideoShow[];
            getView(label: string): import("../../../features/videos/types/video-concepts.js").VideoView;
            getPrivilege(id: string): import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
            getShow(label: string): import("../../../features/videos/types/video-concepts.js").VideoShow;
            setView(view: {
                label: string;
                privileges: string[];
                reference: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
            }): Promise<void>;
            deleteView(label: string): Promise<void>;
        };
    }>>;
    XiomeVideoCompanion: import("../../../types/mixin.js").Mixin<typeof import("../../../features/videos/components/video-companion/xiome-video-companion.js").XiomeVideoCompanion, import("../../../framework/component.js").WithShare<{
        contentModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                catalogOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[]>;
                viewsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoView[]>;
                privilegesOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[]>;
                showsOp: import("../../../framework/ops.js").Op<import("../../../features/videos/types/video-concepts.js").VideoShow[]>;
            }>) => () => void;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
            onVideoHostingUpdate(): Promise<void>;
            initializeForModerationData(): Promise<void>;
            initializeForVideo(label: string): Promise<void>;
            readonly allowance: {
                canModerateVideos: boolean;
                canViewAllVideos: boolean;
            };
            readonly catalog: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastContent[];
            readonly views: import("../../../features/videos/types/video-concepts.js").VideoView[];
            readonly privileges: import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay[];
            readonly shows: import("../../../features/videos/types/video-concepts.js").VideoShow[];
            getView(label: string): import("../../../features/videos/types/video-concepts.js").VideoView;
            getPrivilege(id: string): import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay;
            getShow(label: string): import("../../../features/videos/types/video-concepts.js").VideoShow;
            setView(view: {
                label: string;
                privileges: string[];
                reference: import("../../../features/videos/types/video-concepts.js").VideoHosting.DacastReference;
            }): Promise<void>;
            deleteView(label: string): Promise<void>;
        };
    }>>;
    XiomeManageUsers: import("../../../types/mixin.js").Mixin<typeof import("../../../features/administrative/components/xiome-manage-users/xiome-manage-users.js").XiomeManageUsers, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        administrativeModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsOp: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>) => () => void;
            getAccess: () => import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            initialize: () => Promise<void>;
            readonly isAllowed: (privilege: "universal" | "banned" | "view all chats" | "participate in all chats" | "read questions" | "post questions" | "like questions" | "report questions" | "moderate all chats" | "control stripe account" | "manage store" | "give away freebies" | "view all videos" | "moderate videos" | "edit any profile" | "customize permissions" | "answer questions" | "moderate questions" | "view stats" | "administrate user roles") => boolean;
            reauthorize: () => Promise<void>;
            searchUsers: (options: {
                term: string;
            }) => Promise<{
                user: {
                    userId: string;
                    profile: import("../../../features/auth/aspects/users/types/profile.js").Profile;
                    roles: import("../../../features/auth/aspects/users/types/public-user-role.js").PublicUserRole[];
                    stats: import("../../../features/auth/aspects/users/types/user-stats.js").UserStats;
                };
                roleIds: string[];
            }[]>;
            assignRoleToUser: (options: {
                roleId: string;
                userId: string;
                isPublic: boolean;
                timeframeEnd: number;
                timeframeStart: number;
            }) => Promise<void>;
            revokeRoleFromUser: (options: {
                roleId: string;
                userId: string;
            }) => Promise<void>;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
    }>>;
    XiomeQuestions: import("../../../types/mixin.js").Mixin<typeof import("../../../features/questions/components/xiome-questions/xiome-questions.js").XiomeQuestions, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        questionsModel: {
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                access: import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                users: import("../../../features/auth/aspects/users/types/user.js").User[];
                questions: import("../../../features/questions/api/types/questions-and-answers.js").Question[];
                boardOps: {
                    [key: string]: import("../../../framework/ops.js").Op<void>;
                };
                postingOp: import("../../../framework/ops.js").Op<void>;
            }>) => () => void;
            makeBoardModel: (board: string) => {
                getPermissions(): {
                    readonly "read questions": boolean;
                    readonly "post questions": boolean;
                    readonly "moderate questions": boolean;
                    readonly "answer questions": boolean;
                    readonly "like questions": boolean;
                    readonly "report questions": boolean;
                };
                getBoardName(): string;
                getAccess(): import("../../../features/auth/types/auth-tokens.js").AccessPayload;
                getBoardOp(): import("../../../framework/ops.js").Op<void>;
                getPostingOp(): import("../../../framework/ops.js").Op<void>;
                getQuestions(): {
                    answers: import("../../../features/questions/api/types/questions-and-answers.js").Answer[];
                    questionId: string;
                    authorUserId: string;
                    board: string;
                    content: string;
                    archive: boolean;
                    timePosted: number;
                    liked: boolean;
                    likes: number;
                    reports: number;
                    reported: boolean;
                }[];
                getUser(userId: string): import("../../../features/auth/aspects/users/types/user.js").User;
                loadQuestions(): Promise<void>;
                postQuestion({ content }: {
                    content: string;
                }): Promise<import("../../../features/questions/api/types/questions-and-answers.js").Question>;
                postAnswer(questionId: string, answerDraft: import("../../../features/questions/api/types/answer-draft.js").AnswerDraft): Promise<import("../../../features/questions/api/types/questions-and-answers.js").Answer>;
                likeQuestion(questionId: string, like: boolean): Promise<void>;
                likeAnswer(questionId: string, answerId: string, like: boolean): Promise<void>;
                reportQuestion(questionId: string, report: boolean): Promise<void>;
                reportAnswer(questionId: string, answerId: string, report: boolean): Promise<void>;
                archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                archiveAnswer(questionId: string, answerId: string, archive: boolean): Promise<void>;
                archiveBoard(): Promise<void>;
            };
            accessChange: (access: import("../../../features/auth/types/auth-tokens.js").AccessPayload) => void;
        };
    }>>;
    XiomeMyAvatar: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/users/components/my-avatar/xiome-my-avatar.js").XiomeMyAvatar, import("../../../framework/component.js").WithShare<{
        accessModel: {
            subscribe: (...listeners: ((accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>) => void | Promise<void>)[]) => () => void;
            getAccessOp(): import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            getAccess(): import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            getValidAccess(): Promise<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            useExistingLogin(): Promise<void>;
            sendLoginLink(email: string): Promise<void>;
            login(loginToken: string): Promise<void>;
            logout(): Promise<void>;
            reauthorize(): Promise<void>;
        };
    }>>;
    XiomeLoginPanel: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/users/components/login-panel/xiome-login-panel.js").XiomeLoginPanel, import("../../../framework/component.js").WithShare<{
        accessModel: {
            subscribe: (...listeners: ((accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>) => void | Promise<void>)[]) => () => void;
            getAccessOp(): import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            getAccess(): import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            getValidAccess(): Promise<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            useExistingLogin(): Promise<void>;
            sendLoginLink(email: string): Promise<void>;
            login(loginToken: string): Promise<void>;
            logout(): Promise<void>;
            reauthorize(): Promise<void>;
        };
    }>>;
    XiomeAppManager: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/apps/components/app-manager/xiome-app-manager.js").XiomeAppManager, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        appsModel: {
            state: {
                active: boolean;
                appRecords: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                addingNewApp: import("../../../framework/ops.js").Op<null>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                active: boolean;
                appRecords: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/apps/models/types/app-records.js").AppRecords>;
                addingNewApp: import("../../../framework/ops.js").Op<null>;
            }>) => () => void;
            appEditService: {
                updateApp({ appId: appIdString, appDraft }: {
                    appId: string;
                    appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft;
                }): Promise<void>;
                deleteApp({ appId: appIdString }: {
                    appId: string;
                }): Promise<void>;
                listAdmins({ appId: appIdString }: {
                    appId: string;
                }): Promise<import("../../../features/auth/aspects/apps/types/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin({ appId: appIdString, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin({ appId: appIdString, userId: userIdString }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            };
            getApp: (appId: string) => import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay;
            loadApps: () => Promise<import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay[]>;
            deleteApp: (appId: string) => Promise<void>;
            updateApp: (appId: string, appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<void>;
            registerApp: (appDraft: import("../../../features/auth/aspects/apps/types/app-draft.js").AppDraft) => Promise<import("../../../features/auth/aspects/apps/types/app-display.js").AppDisplay>;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
    }>>;
    XiomeMyAccount: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/users/components/my-account/xiome-my-account.js").XiomeMyAccount, import("../../../framework/component.js").WithShare<{
        personalModel: {
            track: <X>(observer: import("@chasemoskal/snapstate").Observer<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../../../framework/ops.js").Op<void>;
            }, X>, reaction?: import("@chasemoskal/snapstate").Reaction<X>, options?: {
                flip?: boolean;
            }) => () => void;
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../../../framework/ops.js").Op<void>;
            }>) => () => void;
            readable: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                submitDraftOp: import("../../../framework/ops.js").Op<void>;
            };
            saveProfile(profileDraft: import("../../../features/auth/aspects/users/routines/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): void;
        };
    }>>;
    XiomePermissions: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/permissions/components/permissions/xiome-permissions.js").XiomePermissions, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        permissionsModel: {
            readable: {
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>) => () => void;
            track: <X_1>(observer: import("@chasemoskal/snapstate").Observer<{
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }, X_1>, reaction?: import("@chasemoskal/snapstate").Reaction<X_1>, options?: {
                flip?: boolean;
            }) => () => void;
            getAccess: () => import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            initialize: () => Promise<void>;
            getUserCanCustomizePermissions: () => boolean;
            createRole: ({ label }: {
                label: string;
            }) => Promise<void>;
            deleteRole: ({ roleId: roleIdString }: {
                roleId: string;
            }) => Promise<void>;
            assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            deletePrivilege: ({ privilegeId: privilegeIdString }: {
                privilegeId: string;
            }) => Promise<void>;
            createPrivilege: ({ label }: {
                label: string;
            }) => Promise<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
    }>>;
    XiomePrivileges: import("../../../types/mixin.js").Mixin<typeof import("../../../features/auth/aspects/permissions/components/privileges/xiome-privileges.js").XiomePrivileges, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        permissionsModel: {
            readable: {
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }>) => () => void;
            track: <X_1>(observer: import("@chasemoskal/snapstate").Observer<{
                active: boolean;
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
                permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/aspects/users/routines/permissions/types/permissions-display.js").PermissionsDisplay>;
            }, X_1>, reaction?: import("@chasemoskal/snapstate").Reaction<X_1>, options?: {
                flip?: boolean;
            }) => () => void;
            getAccess: () => import("../../../features/auth/types/auth-tokens.js").AccessPayload;
            initialize: () => Promise<void>;
            getUserCanCustomizePermissions: () => boolean;
            createRole: ({ label }: {
                label: string;
            }) => Promise<void>;
            deleteRole: ({ roleId: roleIdString }: {
                roleId: string;
            }) => Promise<void>;
            assignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            unassignPrivilege: ({ roleId: roleIdString, privilegeId: privilegeIdString }: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            deletePrivilege: ({ privilegeId: privilegeIdString }: {
                privilegeId: string;
            }) => Promise<void>;
            createPrivilege: ({ label }: {
                label: string;
            }) => Promise<import("../../../features/auth/aspects/users/routines/permissions/types/privilege-display.js").PrivilegeDisplay>;
            updateAccessOp(op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>): Promise<void>;
        };
    }>>;
    XiomeExample: import("../../../types/mixin.js").Mixin<typeof import("../../../features/example/components/xiome-example/xiome-example.js").XiomeExample, import("../../../framework/component.js").WithShare<{
        modals: import("../modal/types/modal-system.js").ModalSystem;
        exampleModel: {
            state: {
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            };
            subscribe: (subscription: import("@chasemoskal/snapstate").Subscription<{
                accessOp: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>;
            }>) => () => void;
            updateAccessOp: (op: import("../../../framework/ops.js").Op<import("../../../features/auth/types/auth-tokens.js").AccessPayload>) => void;
        };
    }>>;
    XioId: typeof import("../../../features/xio-components/id/xio-id.js").XioId;
    XioOp: typeof import("../../../features/xio-components/op/xio-op.js").XioOp;
    XioMenu: typeof import("../../../features/xio-components/menu/xio-menu.js").XioMenu;
    XioAvatar: typeof import("../../../features/xio-components/avatar/xio-avatar.js").XioAvatar;
    XioButton: typeof import("../../../features/xio-components/button/xio-button.js").XioButton;
    XioExample: typeof import("../../../features/xio-components/example/xio-example.js").XioExample;
    XioCheckbox: typeof import("../../../features/xio-components/checkbox/xio-checkbox.js").XioCheckbox;
    XioMenuItem: typeof import("../../../features/xio-components/menu/xio-menu-item.js").XioMenuItem;
    XioTextInput: typeof import("../../../features/xio-components/inputs/xio-text-input.js").XioTextInput;
    XioPriceInput: typeof import("../../../features/xio-components/inputs/xio-price-input.js").XioPriceInput;
    XioNightlight: typeof import("../../../features/xio-components/nightlight/xio-nightlight.js").XioNightlight;
    XioProfileCard: typeof import("../../../features/xio-components/profile-card/xio-profile-card.js").XioProfileCard;
    XioPriceDisplay: typeof import("../../../features/xio-components/price-display/xio-price-display.js").XioPriceDisplay;
};
