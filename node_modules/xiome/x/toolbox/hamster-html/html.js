var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HtmlTemplate_instances, _HtmlTemplate_strings, _HtmlTemplate_values, _HtmlTemplate_processValue, _HtmlTemplate_processAsyncValue;
import { escapeHtml } from "../escape-html.js";
export class HtmlTemplate {
    constructor({ strings, values }) {
        _HtmlTemplate_instances.add(this);
        _HtmlTemplate_strings.set(this, void 0);
        _HtmlTemplate_values.set(this, void 0);
        __classPrivateFieldSet(this, _HtmlTemplate_strings, strings, "f");
        __classPrivateFieldSet(this, _HtmlTemplate_values, values, "f");
    }
    toString() {
        return __classPrivateFieldGet(this, _HtmlTemplate_strings, "f").reduce((previous, current, index) => {
            var _a;
            const value = (_a = __classPrivateFieldGet(this, _HtmlTemplate_values, "f")[index]) !== null && _a !== void 0 ? _a : "";
            const safeValue = Array.isArray(value)
                ? value.map(__classPrivateFieldGet(this, _HtmlTemplate_instances, "m", _HtmlTemplate_processValue)).join("")
                : __classPrivateFieldGet(this, _HtmlTemplate_instances, "m", _HtmlTemplate_processValue).call(this, value);
            return previous + current + safeValue;
        }, "");
    }
    async render() {
        const results = await Promise.all(__classPrivateFieldGet(this, _HtmlTemplate_strings, "f").map(async (string, index) => {
            var _a;
            const value = (_a = await __classPrivateFieldGet(this, _HtmlTemplate_values, "f")[index]) !== null && _a !== void 0 ? _a : "";
            const safeValue = Array.isArray(value)
                ? (await Promise.all(value.map(__classPrivateFieldGet(this, _HtmlTemplate_instances, "m", _HtmlTemplate_processAsyncValue)))).join("")
                : await __classPrivateFieldGet(this, _HtmlTemplate_instances, "m", _HtmlTemplate_processAsyncValue).call(this, value);
            return string + safeValue;
        }));
        return results.join("");
    }
}
_HtmlTemplate_strings = new WeakMap(), _HtmlTemplate_values = new WeakMap(), _HtmlTemplate_instances = new WeakSet(), _HtmlTemplate_processValue = function _HtmlTemplate_processValue(value) {
    return value instanceof HtmlTemplate
        ? value.toString()
        : escapeHtml(value.toString());
}, _HtmlTemplate_processAsyncValue = async function _HtmlTemplate_processAsyncValue(value) {
    return value instanceof HtmlTemplate
        ? await value.render()
        : escapeHtml(value.toString());
};
export function html(strings, ...values) {
    return new HtmlTemplate({ strings, values });
}
export function render(template) {
    return template.toString();
}
export function unsanitized(value) {
    return new HtmlTemplate({ strings: [value], values: [] });
}
export function untab(code) {
    const lines = code.split(/\r|\n/);
    let baseTabLevel;
    for (const line of lines) {
        const isOnlyWhitespace = /^\s+$/.test(line);
        if (!isOnlyWhitespace) {
            const tabMatch = line.match(/^(\t+).+/);
            if (tabMatch) {
                const tabCount = tabMatch[1].length;
                baseTabLevel = baseTabLevel === undefined
                    ? tabCount
                    : tabCount < baseTabLevel
                        ? tabCount
                        : baseTabLevel;
                if (baseTabLevel === 0)
                    break;
            }
        }
    }
    const rebaseTabRegex = new RegExp(`^\\t{${baseTabLevel}}`);
    return lines
        .map(line => /^\s+$/.test(line) ? "" : line)
        .map(line => line.replace(rebaseTabRegex, ""))
        .join("\n");
}
export function attrMaybe(attr, value) {
    return value !== undefined
        ? html `${attr}="${value}"`
        : "";
}
export function attrBool(attr, value) {
    return value
        ? attr
        : "";
}
export function maybe(value, realize) {
    return value
        ? realize(value)
        : undefined;
}
//# sourceMappingURL=html.js.map