import { snapstate } from "@chasemoskal/snapstate";
import { ops } from "../../../../framework/ops.js";
export function prepareNotesCacheCreator({ propagateChangeToOtherTabs, notesService, getStats, loadStats, getIsLoggedIn, }) {
    async function loadNewNotes(pagination) {
        return notesService.getNewNotes(pagination);
    }
    async function loadOldNotes(pagination) {
        return notesService.getOldNotes(pagination);
    }
    async function markNotesNewOrOld(old, noteIds) {
        await notesService.markNotesNewOrOld({ old, noteIds });
        await loadStats();
        propagateChangeToOtherTabs.publish(undefined);
    }
    return function createNotesCache() {
        const cacheState = snapstate({
            old: false,
            pageNumber: 1,
            pageSize: 10,
            notesOp: ops.none(),
        });
        function resetPagination() {
            cacheState.writable.pageNumber = 1;
            cacheState.writable.pageSize = 10;
        }
        async function fetchAppropriateNotes() {
            if (!getIsLoggedIn()) {
                cacheState.writable.notesOp = ops.ready([]);
                return [];
            }
            const { old, pageNumber, pageSize } = cacheState.readable;
            const pagination = {
                offset: ((pageNumber - 1) * pageSize),
                limit: pageSize,
            };
            await ops.operation({
                setOp: op => cacheState.writable.notesOp = op,
                promise: old
                    ? loadOldNotes(pagination)
                    : loadNewNotes(pagination),
            });
        }
        function totalNumberOfPages() {
            const { old, pageSize } = cacheState.readable;
            const { oldCount, newCount } = getStats();
            const count = old
                ? oldCount
                : newCount;
            return Math.ceil(count / pageSize);
        }
        const isPageAvailable = {
            next: () => cacheState.writable.pageNumber < totalNumberOfPages(),
            previous: () => cacheState.writable.pageNumber > 1,
        };
        return {
            subscribe: cacheState.subscribe,
            cacheState: cacheState.readable,
            async loginStatusChanged() {
                resetPagination();
                await fetchAppropriateNotes();
            },
            get notes() {
                return ops.value(cacheState.readable.notesOp);
            },
            fetchAppropriateNotes,
            async switchTabNew() {
                cacheState.writable.old = false;
                resetPagination();
                await fetchAppropriateNotes();
            },
            async switchTabOld() {
                cacheState.writable.old = true;
                resetPagination();
                await fetchAppropriateNotes();
            },
            get isNextPageAvailable() {
                return isPageAvailable.next();
            },
            get isPreviousPageAvailable() {
                return isPageAvailable.previous();
            },
            async nextPage() {
                if (isPageAvailable.next()) {
                    cacheState.writable.pageNumber += 1;
                    await fetchAppropriateNotes();
                }
                else
                    throw new Error("no next page");
            },
            async previousPage() {
                if (isPageAvailable.previous()) {
                    cacheState.writable.pageNumber -= 1;
                    await fetchAppropriateNotes();
                }
                else
                    throw new Error("no previous page");
            },
            async markAllNotesOld() {
                await notesService.markAllNotesOld();
                await loadStats();
                propagateChangeToOtherTabs.publish(undefined);
                await fetchAppropriateNotes();
            },
            async markSpecificNoteOld(noteId) {
                await markNotesNewOrOld(true, [noteId]);
                cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                    ? cacheState.writable.pageNumber -= 1
                    : null;
                await fetchAppropriateNotes();
            },
            async markSpecificNoteNew(noteId) {
                await markNotesNewOrOld(false, [noteId]);
                cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                    ? cacheState.writable.pageNumber -= 1
                    : null;
                await fetchAppropriateNotes();
            },
            get totalPages() {
                return totalNumberOfPages();
            },
        };
    };
}
//# sourceMappingURL=notes-cache.js.map