import * as renraku from "renraku";
import * as dbmage from "dbmage";
import { Id, find, findAll } from "dbmage";
import { validatePagination } from "../validation/validate-pagination.js";
import { validateId } from "../../../../common/validators/validate-id.js";
import { runValidation } from "../../../../toolbox/topic-validation/run-validation.js";
import { array, boolean, each, maxLength, schema, validator } from "../../../../toolbox/darkvalley.js";
export const makeNotesService = ({ config, basePolicy, }) => renraku.service()
    .policy(async (meta, headers) => {
    const auth = await basePolicy(meta, headers);
    return {
        ...auth,
        notesDatabase: dbmage.subsection(auth.database, tables => tables.notes),
    };
})
    .expose(({ notesDatabase, access }) => ({
    async getNotesStats() {
        const { userId } = access.user;
        const newCount = await notesDatabase.tables.notes.count(find({
            to: Id.fromString(userId),
            old: false
        }));
        const oldCount = await notesDatabase.tables.notes.count(find({
            to: Id.fromString(userId),
            old: true
        }));
        return { newCount, oldCount };
    },
    async getNewNotes(pagination) {
        const { offset, limit } = runValidation(pagination, validatePagination);
        const { userId } = access.user;
        const newNotes = await notesDatabase.tables.notes.read({
            ...find({
                to: Id.fromString(userId),
                old: false
            }),
            offset,
            limit,
            order: { time: "descend" }
        });
        return newNotes.map(note => ({
            type: "message",
            noteId: note.noteId.toString(),
            time: note.time,
            old: note.old,
            from: undefined,
            to: note.to.toString(),
            text: note.text,
            title: note.title,
            details: {},
        }));
    },
    async getOldNotes(pagination) {
        const { offset, limit } = runValidation(pagination, validatePagination);
        const { userId } = access.user;
        const oldNotes = await notesDatabase.tables.notes.read({
            ...find({
                to: Id.fromString(userId),
                old: true
            }),
            offset,
            limit,
            order: { time: "descend" }
        });
        return oldNotes.map(note => ({
            type: "message",
            noteId: note.noteId.toString(),
            time: note.time,
            old: note.old,
            from: undefined,
            to: note.to.toString(),
            text: note.text,
            title: note.title,
            details: {},
        }));
    },
    async markAllNotesOld() {
        const { userId } = access.user;
        await notesDatabase.tables.notes.update({
            ...find({
                to: Id.fromString(userId),
                old: false,
            }),
            write: { old: true },
        });
    },
    async markNotesNewOrOld(input) {
        const { userId } = access.user;
        const { old, noteIds: noteIdStrings } = runValidation(input, schema({
            old: boolean(),
            noteIds: validator(array(), maxLength(1000), each(validateId)),
        }));
        const noteIds = noteIdStrings.map(id => Id.fromString(id));
        const notes = await notesDatabase.tables.notes.read(findAll(noteIds, noteId => ({ noteId })));
        for (const note of notes) {
            if (userId !== note.to.toString())
                throw new renraku.ApiError(403, `user is not privileged for note ${note.to.toString()}`);
        }
        await notesDatabase.tables.notes.update({
            ...findAll(noteIds, noteId => ({ noteId })),
            write: { old }
        });
    }
}));
//# sourceMappingURL=notes-service.js.map