import * as dbmage from "dbmage";
import { find } from "dbmage";
import { getStripeId } from "../../utils/get-stripe-id.js";
import { stripeResponse } from "./utils/stripe-response.js";
import { prepareStandardRestResource } from "./utils/standard-rest-resource.js";
import { mockSubscriptionMechanics } from "./utils/mock-subscription-mechanics.js";
import { makeFakestripePopupUrls } from "../../../../popups/make-fakestripe-popup-urls.js";
export function mockStripeLiaison({ rando, rootUrl, recentDetails, metaDataTables, tables: rawTables, dispatchWebhook, }) {
    const generateId = () => rando.randomId().string;
    const makeStandardRestResource = prepareStandardRestResource({ generateId });
    const fakestripePopups = makeFakestripePopupUrls(rootUrl);
    return {
        accounts: {
            async create(params) {
                const account = {
                    id: generateId().toString(),
                    type: params.type,
                    email: params.email,
                };
                await rawTables.accounts.create(account);
                return stripeResponse(account);
            },
            async retrieve(id) {
                const account = await rawTables.accounts.readOne(find({ id }));
                return stripeResponse(account);
            },
            async createLoginLink(id) {
                const loginLink = {
                    created: Date.now(),
                    url: fakestripePopups.login(),
                };
                return stripeResponse(loginLink);
            },
        },
        accountLinks: {
            async create(params) {
                const accountLink = {
                    url: fakestripePopups.connect({
                        return_url: params.return_url,
                        refresh_url: params.refresh_url,
                    }),
                };
                return stripeResponse(accountLink);
            },
        },
        account(stripeAccountId) {
            const tables = dbmage.constrainTables({
                tables: rawTables,
                constraint: { "_connectedAccount": stripeAccountId },
            });
            const subscriptionMechanics = mockSubscriptionMechanics({
                tables,
                generateId,
            });
            return {
                billingPortal: {
                    async create(params) {
                        return stripeResponse({
                            url: fakestripePopups.customerPortal(),
                            customer: params.customer
                        });
                    }
                },
                customers: {
                    ...makeStandardRestResource()({
                        table: tables.customers,
                        handleCreate: async (params) => {
                            var _a;
                            return ({
                                resource: {
                                    email: params.email,
                                    invoice_settings: (_a = params.invoice_settings) !== null && _a !== void 0 ? _a : { default_payment_method: undefined },
                                }
                            });
                        },
                        handleUpdate: async (id, params) => ({
                            email: params.email,
                            invoice_settings: params.invoice_settings,
                        }),
                    }),
                    async listPaymentMethods(customer, params) {
                        const paymentMethods = await tables.paymentMethods.read(dbmage.find({ customer, type: params.type }));
                        return stripeResponse({
                            object: "list",
                            data: paymentMethods,
                        });
                    },
                },
                products: makeStandardRestResource()({
                    table: tables.products,
                    handleCreate: async (params) => ({
                        resource: {
                            name: params.name,
                            description: params.description,
                            active: true,
                        }
                    }),
                    handleUpdate: async (id, params) => ({
                        name: params.name,
                        active: params.active,
                        description: params.description,
                        default_price: params.default_price,
                    }),
                }),
                prices: (() => {
                    const resource = makeStandardRestResource()({
                        table: tables.prices,
                        handleCreate: async (params) => ({
                            resource: {
                                active: params.active === undefined ? true : params.active,
                                product: params.product,
                                currency: params.currency,
                                unit_amount: params.unit_amount,
                                recurring: params.recurring
                                    ? { usage_type: "licensed", ...params.recurring }
                                    : undefined,
                                type: params.recurring ? "recurring" : "one_time",
                            }
                        }),
                        handleUpdate: async (id, params) => ({
                            active: params.active,
                            recurring: params.recurring
                                ? { usage_type: "licensed", ...params.recurring }
                                : undefined,
                        }),
                    });
                    return {
                        ...resource,
                        async list(params) {
                            let prices = await tables.prices.read({ conditions: false });
                            if (params.active !== undefined)
                                prices = prices.filter(p => p.active === params.active);
                            if (params.product !== undefined)
                                prices = prices.filter(p => p.product === params.product);
                            return stripeResponse({
                                object: "list",
                                data: prices,
                            });
                        },
                    };
                })(),
                checkout: {
                    sessions: makeStandardRestResource()({
                        table: tables.checkoutSessions,
                        handleCreate: async (params) => ({
                            resource: {
                                mode: params.mode,
                                url: params.mode === "setup"
                                    ? undefined
                                    : fakestripePopups.checkout({
                                        cancel_url: params.cancel_url,
                                        success_url: params.success_url,
                                    }),
                                customer: params.customer,
                                client_reference_id: params.client_reference_id,
                                line_items: params.mode === "setup"
                                    ? undefined
                                    : {
                                        object: "list",
                                        has_more: false,
                                        url: undefined,
                                        data: params.line_items.map(item => ({
                                            id: rando.randomId().string,
                                            object: "item",
                                            quantity: item.quantity,
                                            price: item.price,
                                        })),
                                    },
                            }
                        }),
                        handleUpdate: async (id, params) => ({}),
                    }),
                },
                paymentMethods: (() => {
                    const resource = makeStandardRestResource()({
                        table: tables.paymentMethods,
                        handleCreate: async (params) => ({
                            resource: {
                                type: params.type,
                                customer: params.customer,
                                card: params.card,
                            }
                        }),
                        handleUpdate: async (id, params) => ({
                            card: params.card,
                        }),
                    });
                    return {
                        ...resource,
                        delete: undefined,
                        async detach(id) {
                            const paymentMethod = resource.retrieve(id);
                            await resource.del(id);
                            return stripeResponse(paymentMethod);
                        }
                    };
                })(),
                setupIntents: makeStandardRestResource()({
                    table: tables.setupIntents,
                    handleCreate: async (params) => ({
                        resource: {
                            customer: params.customer,
                            payment_method: params.payment_method,
                            usage: params.usage,
                        }
                    }),
                    handleUpdate: async (id, params) => ({
                        payment_method: params.payment_method,
                    }),
                }),
                paymentIntents: makeStandardRestResource()({
                    table: tables.setupIntents,
                    handleCreate: async (params) => ({
                        resource: {
                            customer: params.customer,
                            payment_method: params.payment_method,
                            amount: params.amount,
                            currency: params.currency,
                        }
                    }),
                    handleUpdate: async (id, params) => ({
                        customer: params.customer,
                        payment_method: params.payment_method,
                        amount: params.amount,
                        currency: params.currency,
                    }),
                }),
                subscriptionItems: makeStandardRestResource(),
                subscriptions: (() => {
                    const resource = makeStandardRestResource()({
                        table: tables.subscriptions,
                        handleCreate: async (params) => {
                            const subscription = await subscriptionMechanics
                                .interpretCreateParams(params);
                            const { invoice, paymentIntent } = await subscriptionMechanics
                                .generateInvoiceForSubscriptionItems({
                                customer: subscription.customer,
                                default_payment_method: subscription
                                    .default_payment_method,
                                subscriptionId: subscription.id,
                                items: subscription.items,
                                current_period_end: subscription.current_period_end,
                                current_period_start: subscription.current_period_start
                            });
                            const paymentMethodId = getStripeId(paymentIntent.payment_method);
                            const paymentMethodMetaData = await metaDataTables.
                                paymentMethodMetaData.readOne(find({ id: paymentMethodId }));
                            recentDetails.subscriptionCreation = {
                                subscription,
                                paymentIntent: paymentIntent,
                            };
                            subscription.status = (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)
                                ? "incomplete"
                                : "active";
                            return {
                                resource: subscription,
                                afterResourceIsAddedToTable: async () => {
                                    if (!(paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)) {
                                        await dispatchWebhook("invoice.paid", stripeAccountId, invoice);
                                    }
                                    // else {
                                    // 	await dispatchWebhook(
                                    // 		"invoice.payment_failed",
                                    // 		stripeAccountId,
                                    // 		invoice,
                                    // 	)}
                                }
                            };
                        },
                    });
                    return {
                        ...resource,
                        async update(id, params) {
                            const existingSubscription = await resource.retrieve(id);
                            const write = {};
                            const paymentMethodMetaData = await metaDataTables.
                                paymentMethodMetaData.readOne(find({ id: params.default_payment_method }));
                            if (params.cancel_at_period_end !== undefined) {
                                write.cancel_at_period_end = params.cancel_at_period_end;
                            }
                            if (params.default_payment_method !== undefined) {
                                write.default_payment_method = params.default_payment_method;
                            }
                            write.status = (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)
                                ? "incomplete"
                                : "active";
                            if (params.items !== undefined) {
                                const newItems = params.items;
                                const items = await subscriptionMechanics
                                    .interpretUpdateItemsParam(newItems);
                                const { invoice } = await subscriptionMechanics.generateInvoiceForSubscriptionItems({
                                    customer: existingSubscription.customer,
                                    default_payment_method: existingSubscription
                                        .default_payment_method,
                                    subscriptionId: id,
                                    items,
                                    current_period_end: existingSubscription.current_period_end,
                                    current_period_start: existingSubscription.current_period_start
                                });
                                if (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing) {
                                    // await dispatchWebhook(
                                    // 	"invoice.payment_failed",
                                    // 	stripeAccountId,
                                    // 	invoice,
                                    // )
                                }
                                else {
                                    await dispatchWebhook("invoice.paid", stripeAccountId, invoice);
                                }
                                write.items = items;
                            }
                            await tables.subscriptions.update({
                                ...dbmage.find({ id }),
                                write: write,
                            });
                            return resource.retrieve(id);
                        },
                        async list(params) {
                            let equalityQuery = { equal: { customer: params.customer } };
                            let statusQuery = { notEqual: { status: "canceled" } };
                            if (params.price)
                                equalityQuery.equal.price = params.price;
                            if (params.status)
                                statusQuery = params.status === "all"
                                    ? { isSet: { status: true } }
                                    : params.status === "ended"
                                        ? [
                                            "and",
                                            { notEqual: { status: "canceled" } },
                                            { notEqual: { status: "incomplete_expired" } },
                                        ]
                                        : { equal: { status: params.status } };
                            const subscriptions = await tables.subscriptions.read({
                                conditions: [
                                    "and",
                                    equalityQuery,
                                    statusQuery,
                                ],
                            });
                            return stripeResponse({
                                object: "list",
                                data: subscriptions,
                            });
                        },
                    };
                })(),
            };
        }
    };
}
//# sourceMappingURL=mock-stripe-liaison.js.map