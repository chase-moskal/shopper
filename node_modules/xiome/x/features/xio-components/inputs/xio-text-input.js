var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { debounce } from "@chasemoskal/snapstate";
import styles from "./xio-text-input.css.js";
import svgWarning from "../../../framework/icons/warning.svg.js";
import svgCircleCheck from "../../../framework/icons/circle-check.svg.js";
import { noopParser } from "./parsing/noop-parser.js";
import { EnterPressEvent } from "./events/enter-press.js";
import { ValueChangeEvent } from "./events/value-change-event.js";
import { Component, html, mixinStyles, mixinFocusable, property } from "../../../framework/component.js";
let XioTextInput = class XioTextInput extends Component {
    constructor() {
        super(...arguments);
        this["initial"] = "";
        this["readonly"] = false;
        this["textarea"] = false;
        this["hide-validation"] = false;
        this["show-validation-when-empty"] = false;
        this["disabled"] = false;
        this["placeholder"] = "";
        this["hidden"] = false;
        this.parser = noopParser;
        this.problems = [];
        this.onvaluechange = () => { };
        this.onenterpress = () => { };
        this.draft = "";
        this.lastDraft = "";
        this.vettedLength = 0;
        this.dispatchValueChange = () => {
            const { draft, lastDraft } = this;
            if (draft !== lastDraft) {
                this.vettedLength = draft.length;
                this.dispatchEvent(new ValueChangeEvent(this.value));
            }
            this.lastDraft = draft;
        };
        this.dispatchValueChangeDebounced = debounce(250, this.dispatchValueChange);
        this.dispatchEnterPress = () => {
            this.dispatchEvent(new EnterPressEvent());
        };
        this.updateDraft = () => {
            this.draft = this.input.value;
        };
        this.handleInputKeyPress = (event) => {
            if (event.key === "Enter") {
                const isTextArea = this.textarea;
                const isPressingShift = event.shiftKey;
                const fireEnterPress = () => {
                    this.updateDraft();
                    this.dispatchValueChange();
                    this.dispatchEnterPress();
                    event.preventDefault();
                };
                if (isTextArea) {
                    if (isPressingShift)
                        fireEnterPress();
                }
                else
                    fireEnterPress();
            }
        };
        this.handleInput = () => {
            this.updateDraft();
            this.dispatchValueChangeDebounced();
        };
        this.handleChange = () => {
            this.updateDraft();
            this.dispatchValueChange();
        };
    }
    get input() {
        return this.shadowRoot
            ? this.shadowRoot.querySelector("#textinput")
            : undefined;
    }
    focus() {
        if (this.input)
            this.input.focus();
    }
    get value() {
        var _a;
        const { draft } = this;
        const parsed = ((_a = this.parser) !== null && _a !== void 0 ? _a : noopParser)(draft);
        this.problems = this.validator ? this.validator(parsed) : [];
        return this.problems.length === 0
            ? parsed
            : undefined;
    }
    get text() {
        return this.draft;
    }
    set text(value) {
        const { input } = this;
        if (input) {
            this.input.value = value;
            this.updateDraft();
            this.dispatchValueChange();
        }
        else {
            this.initial = value;
        }
    }
    init() {
        const { initial } = this;
        this.draft = initial;
        this.lastDraft = initial;
        this.text = initial;
        this.addEventListener("valuechange", this.onvaluechange);
        this.addEventListener("enterpress", this.onenterpress);
        this.dispatchValueChange();
    }
    render() {
        const { readonly, disabled, problems, vettedLength, placeholder, textarea, validator, handleInput, handleInputKeyPress, handleChange, } = this;
        const valid = problems.length === 0;
        const showValidation = !this["hide-validation"] && !readonly && validator && (this["show-validation-when-empty"]
            ? true
            : vettedLength !== 0);
        const showProblems = showValidation && !valid;
        const icon = showValidation
            ? valid
                ? svgCircleCheck
                : svgWarning
            : null;
        return html `
			<div class=container ?data-valid=${valid}>
				<label for=textinput part=label><slot></slot></label>
				<div class=flexy>
					<div part=inputbox>
						${showValidation ? icon : null}
						${textarea ? html `
							<textarea
								id=textinput
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
							></textarea>
						` : html `
							<input
								id=textinput
								type=text
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
								/>
						`}
					</div>
					<ol part=problems>
						${showProblems
            ? problems.map(problem => html `
								<li>${problem}</li>
							`)
            : null}
					</ol>
				</div>
			</div>
		`;
    }
};
__decorate([
    property({ type: String, reflect: true })
], XioTextInput.prototype, "initial", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "readonly", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "textarea", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "hide-validation", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "show-validation-when-empty", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "disabled", void 0);
__decorate([
    property({ type: String, reflect: true })
], XioTextInput.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], XioTextInput.prototype, "hidden", void 0);
__decorate([
    property({ type: Function })
], XioTextInput.prototype, "parser", void 0);
__decorate([
    property({ type: Function })
], XioTextInput.prototype, "validator", void 0);
__decorate([
    property({ type: Object })
], XioTextInput.prototype, "problems", void 0);
__decorate([
    property({ type: String })
], XioTextInput.prototype, "text", null);
__decorate([
    property({ type: String })
], XioTextInput.prototype, "draft", void 0);
XioTextInput = __decorate([
    mixinFocusable,
    mixinStyles(styles)
], XioTextInput);
export { XioTextInput };
//# sourceMappingURL=xio-text-input.js.map