import * as renraku from "renraku";
import * as dbmage from "dbmage";
import { UnconstrainedTable } from "../../../framework/api/unconstrained-table.js";
import { prepareStatsHub } from "../aspects/permissions/tools/prepare-stats-hub.js";
import { isUserOwnerOfApp } from "../aspects/apps/utils/is-user-the-owner-of-app.js";
import { makePrivilegeChecker } from "../aspects/permissions/tools/make-privilege-checker.js";
import { appPermissions, platformPermissions } from "../../../assembly/backend/permissions/standard-permissions.js";
export function prepareAuthPolicies({ config, databaseRaw, verifyToken, }) {
    const getStatsHub = prepareStatsHub({ database: databaseRaw });
    const greenPolicy = async (meta) => ({
        databaseRaw,
    });
    const anonPolicy = async ({ accessToken }, headers) => {
        const access = await verifyToken(accessToken);
        if (access.origins.some(origin => origin === headers.origin))
            return {
                access,
                database: UnconstrainedTable.constrainDatabaseForApp({
                    appId: dbmage.Id.fromString(access.appId),
                    database: databaseRaw,
                }),
                checker: makePrivilegeChecker(access.permit, appPermissions.privileges),
            };
        else
            throw new renraku.ApiError(403, `request origin not allowed: ${headers.origin}`);
    };
    const userPolicy = async (meta, headers) => {
        const auth = await anonPolicy(meta, headers);
        if (auth.access.user)
            return auth;
        else
            throw new renraku.ApiError(403, "not logged in");
    };
    const platformUserPolicy = async (meta, headers) => {
        const auth = await userPolicy(meta, headers);
        const userId = dbmage.Id.fromString(auth.access.user.userId);
        if (auth.access.appId === config.platform.appDetails.appId) {
            return {
                ...auth,
                databaseRaw,
                checker: makePrivilegeChecker(auth.access.permit, platformPermissions.privileges),
                statsHub: await getStatsHub(userId),
            };
        }
        else
            throw new renraku.ApiError(403, "not platform app");
    };
    const appOwnerPolicy = async (meta, headers) => {
        const auth = await platformUserPolicy(meta, headers);
        const appTables = databaseRaw.tables.apps;
        return {
            access: auth.access,
            database: auth.database,
            checker: auth.checker,
            statsHub: auth.statsHub,
            databaseRaw,
            async authorizeAppOwner(appId) {
                const allowedToEditAnyApp = auth.checker.hasPrivilege("edit any app");
                const isOwnerOfApp = isUserOwnerOfApp({ appId, appTables, access: auth.access });
                const allowed = isOwnerOfApp || allowedToEditAnyApp;
                if (allowed)
                    return UnconstrainedTable.constrainDatabaseForApp({
                        appId,
                        database: databaseRaw,
                    });
                else
                    throw new renraku.ApiError(403, "forbidden: lacking privileges to edit app");
            },
        };
    };
    return {
        greenPolicy,
        anonPolicy,
        userPolicy,
        platformUserPolicy,
        appOwnerPolicy,
    };
}
//# sourceMappingURL=prepare-auth-policies.js.map