import { snapstate } from "@chasemoskal/snapstate";
import { ops } from "../../../../../framework/ops.js";
export function makeAppsModel({ appService, appEditService, getValidAccess, }) {
    const { readable, writable, subscribe } = snapstate({
        active: false,
        appRecords: ops.none(),
        addingNewApp: ops.none(),
    });
    const actions = {
        setAppRecords(op) {
            var _a;
            const appList = (_a = ops.value(op)) !== null && _a !== void 0 ? _a : [];
            let records = {};
            for (const app of appList)
                records[app.appId] = ops.ready(app);
            writable.appRecords = ops.replaceValue(op, records);
        },
        setIndividualAppRecord(appId, op) {
            var _a;
            if (ops.isLoading(writable.appRecords))
                throw new Error("cannot set individual app while apps are loading");
            const apps = (_a = ops.value(writable.appRecords)) !== null && _a !== void 0 ? _a : {};
            writable.appRecords = ops.ready({ ...apps, [appId]: op });
        },
        deleteIndividualAppRecord(appId) {
            if (ops.isReady(writable.appRecords)) {
                const existingRecords = ops.value(writable.appRecords);
                const records = {};
                for (const [key, value] of Object.entries(existingRecords)) {
                    if (key !== appId)
                        records[key] = value;
                }
                writable.appRecords = ops.ready(records);
            }
            else
                throw new Error("cannot delete individual app while apps are loading");
        },
    };
    async function getUserId() {
        var _a;
        const access = await getValidAccess();
        return (_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId;
    }
    async function loadApps() {
        writable.active = true;
        const appsPromise = ops.operation({
            promise: (async () => {
                const userId = await getUserId();
                return userId
                    ? appService.listApps({ ownerUserId: userId })
                    : [];
            })(),
            setOp: op => actions.setAppRecords(op),
        });
        // actions.setLoadingPromise(appsPromise.then(() => undefined))
        return appsPromise;
    }
    async function registerApp(appDraft) {
        const userId = await getUserId();
        const result = await ops.operation({
            errorReason: "failed to register app",
            promise: (async () => {
                const result = await appService.registerApp({
                    appDraft,
                    ownerUserId: userId,
                });
                await appEditService.assignPlatformUserAsAdmin({
                    appId: result.appId,
                    platformUserId: userId,
                });
                return result;
            })(),
            setOp: op => {
                writable.addingNewApp = ops.replaceValue(op, null);
                if (ops.isReady(op)) {
                    const newApp = { ...ops.value(op), ...appDraft };
                    actions.setIndividualAppRecord(newApp.appId, ops.ready(newApp));
                }
            },
        });
        return result;
    }
    async function updateApp(appId, appDraft) {
        const records = ops.value(writable.appRecords);
        if (!records)
            throw new Error("cannot update app while loading records");
        const existingApp = ops.value(records[appId]);
        if (!existingApp)
            throw new Error("cannot update app not present in records");
        return ops.operation({
            promise: appEditService.updateApp({ appId, appDraft }),
            setOp: op => actions.setIndividualAppRecord(appId, ops.replaceValue(op, { ...existingApp, ...appDraft })),
        });
    }
    function getApp(appId) {
        const records = ops.value(writable.appRecords);
        return records
            ? ops.value(records[appId])
            : undefined;
    }
    async function deleteApp(appId) {
        await ops.operation({
            promise: appEditService.deleteApp({ appId }),
            setOp: op => {
                actions.setIndividualAppRecord(appId, ops.replaceValue(op, getApp(appId)));
            },
        });
        actions.deleteIndividualAppRecord(appId);
    }
    return {
        state: readable,
        subscribe,
        appEditService,
        getApp,
        loadApps,
        deleteApp,
        updateApp,
        registerApp,
        async updateAccessOp(op) {
            if (readable.active)
                await loadApps();
        },
    };
}
//# sourceMappingURL=apps-model.js.map