import * as renraku from "renraku";
import { schema } from "../../../../toolbox/darkvalley.js";
import { chatAllowance } from "../../common/chat-allowance.js";
import { validateChatDraft, validateChatRoom, validateChatStatus, validateIdArray } from "../../common/chat-validators.js";
export const makeChatServerside = ({ rando, rateLimiter, clientRecord, persistence, headers, policy, getStatsFromServerCore, }) => renraku.api({
    chatServer: renraku.service()
        .policy(async (meta, headers) => {
        var _a;
        const appId = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.appId;
        const persistenceActions = appId
            ? persistence.namespaceForApp(appId)
            : undefined;
        return { persistenceActions, headers };
    })
        .expose(({ persistenceActions, headers }) => {
        const { clientside: { chatClient } } = clientRecord;
        const getAllowance = () => {
            var _a, _b;
            return chatAllowance((_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.permit.privileges) !== null && _b !== void 0 ? _b : []);
        };
        const isNotMuted = () => {
            var _a, _b;
            return !persistenceActions.isMuted((_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.user) === null || _b === void 0 ? void 0 : _b.userId);
        };
        const isNotBanned = () => !getAllowance().banned;
        function enforceValidation(problems) {
            if (problems.length !== 0)
                throw new Error("chat validation error");
        }
        return {
            async updateUserMeta(meta) {
                clientRecord.auth = await policy(meta, headers);
            },
            async getStats() {
                var _a, _b;
                const appId = (_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access) === null || _b === void 0 ? void 0 : _b.appId;
                if (!appId)
                    throw new renraku.ApiError(400, "cannot get stats before updateUserMeta");
                return getStatsFromServerCore(appId);
            },
            async roomSubscribe(room) {
                enforceValidation(validateChatRoom(room));
                if (!getAllowance().viewAllChats)
                    return undefined;
                clientRecord.rooms.add(room);
                chatClient.roomStatusChanged(room, await persistenceActions.getRoomStatus(room));
                chatClient.postsAdded(room, await persistenceActions.fetchRecentPosts(room));
                chatClient.usersMuted((await persistenceActions.fetchMutes())
                    .map(({ userId }) => userId));
            },
            async roomUnsubscribe(room) {
                enforceValidation(validateChatRoom(room));
                if (!getAllowance().viewAllChats)
                    return undefined;
                clientRecord.rooms.delete(room);
            },
            async post(room, draft) {
                if (rateLimiter.tooMany())
                    return undefined;
                enforceValidation(schema({
                    room: validateChatRoom,
                    draft: validateChatDraft,
                })({ room, draft }));
                if (!getAllowance().participateInAllChats)
                    return undefined;
                if (isNotMuted() && isNotBanned()) {
                    const post = {
                        ...draft,
                        room,
                        time: Date.now(),
                        postId: rando.randomId().toString(),
                        userId: clientRecord.auth.access.user.userId,
                        nickname: clientRecord.auth.access.user.profile.nickname,
                    };
                    await persistenceActions.addPosts(room, [post]);
                }
            },
            async remove(room, postIds) {
                enforceValidation(schema({
                    room: validateChatRoom,
                    postIds: validateIdArray,
                })({ room, postIds }));
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.removePosts(room, postIds);
            },
            async clear(room) {
                enforceValidation(validateChatRoom(room));
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.clearRoom(room);
            },
            async mute(userIds) {
                enforceValidation(validateIdArray(userIds));
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.addMute(userIds);
            },
            async unmute(userIds) {
                enforceValidation(validateIdArray(userIds));
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.removeMute(userIds);
            },
            async unmuteAll() {
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.unmuteAll();
            },
            async setRoomStatus(room, status) {
                enforceValidation(schema({
                    room: validateChatRoom,
                    status: validateChatStatus,
                })({ room, status }));
                if (!getAllowance().moderateAllChats)
                    return undefined;
                await persistenceActions.setRoomStatus(room, status);
            },
        };
    }),
});
//# sourceMappingURL=chat-serverside.js.map