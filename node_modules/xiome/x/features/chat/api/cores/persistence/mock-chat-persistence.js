import * as dbmage from "dbmage";
import { Id, find, findAll } from "dbmage";
import { objectMap } from "../../../../../toolbox/object-map.js";
import { subbies } from "../../../../../toolbox/subbies.js";
import { AssertiveMap } from "../../../../../toolbox/assertive-map.js";
import { maximumNumberOfPostsShownAtOnce } from "../../../common/chat-constants.js";
import { UnconstrainedTable } from "../../../../../framework/api/unconstrained-table.js";
import { ChatStatus, chatShape } from "../../../common/types/chat-concepts.js";
import { makeTableNameWithHyphens } from "../../../../../common/make-table-name-with-hyphens.js";
export async function mockChatPersistence(storage) {
    const chatDatabaseRaw = UnconstrainedTable.wrapDatabase(dbmage.flex({
        shape: chatShape,
        flexStorage: storage,
        makeTableName: makeTableNameWithHyphens,
    }));
    const events = {
        roomStatusChanged: subbies(),
        postsAdded: subbies(),
        postsRemoved: subbies(),
        roomCleared: subbies(),
        mutes: subbies(),
        unmutes: subbies(),
        unmuteAll: subbies(),
    };
    const eventSubscribers = objectMap(events, (event) => event.subscribe);
    const getAppCache = (() => {
        const appCaches = new AssertiveMap(() => ({
            mutedUserIds: new Set()
        }));
        return (appId) => appCaches.assert(appId);
    })();
    // listen to events to update cache
    {
        eventSubscribers.mutes(({ appId, userIds }) => {
            const cache = getAppCache(appId);
            for (const userId of userIds)
                cache.mutedUserIds.add(userId);
        });
        eventSubscribers.unmutes(({ appId, userIds }) => {
            const cache = getAppCache(appId);
            for (const userId of userIds)
                cache.mutedUserIds.delete(userId);
        });
        eventSubscribers.unmuteAll(({ appId }) => {
            const cache = getAppCache(appId);
            cache.mutedUserIds.clear();
        });
    }
    function namespaceForApp(appId) {
        const appCache = getAppCache(appId);
        const chatDatabase = UnconstrainedTable.constrainDatabaseForApp({
            appId: Id.fromString(appId),
            database: chatDatabaseRaw,
        });
        const chatTables = chatDatabase.tables;
        return {
            isMuted(userId) {
                return appCache.mutedUserIds.has(userId);
            },
            async addPosts(room, posts) {
                await chatTables.posts.create(...posts.map(post => ({
                    room: post.room,
                    time: post.time,
                    content: post.content,
                    nickname: post.nickname,
                    userId: Id.fromString(post.userId),
                    postId: Id.fromString(post.postId),
                })));
                events.postsAdded.publish({ appId, room, posts });
            },
            async removePosts(room, postIds) {
                if (postIds.length) {
                    await chatTables.posts.delete(findAll(postIds, postId => ({
                        room,
                        postId: Id.fromString(postId)
                    })));
                    events.postsRemoved.publish({ appId, room, postIds });
                }
            },
            async fetchRecentPosts(room) {
                const rawPosts = await chatTables.posts.read({
                    ...find({ room }),
                    limit: maximumNumberOfPostsShownAtOnce,
                    order: { time: "descend" },
                });
                const recentPosts = rawPosts.map(post => ({
                    room: post.room,
                    time: post.time,
                    content: post.content,
                    nickname: post.nickname,
                    postId: post.postId.toString(),
                    userId: post.userId.toString(),
                }));
                const postsSortedByTime = recentPosts.sort((a, b) => a.time - b.time);
                return postsSortedByTime;
            },
            async fetchMutes() {
                const rows = await chatTables.mutes.read({ conditions: false });
                return rows.map(row => ({ userId: row.userId.toString() }));
            },
            async clearRoom(room) {
                await chatTables.posts.delete(find({ room }));
                events.roomCleared.publish({ appId, room });
            },
            async addMute(userIds) {
                if (userIds.length) {
                    const existingMutes = await chatTables.mutes.read(findAll(userIds, userId => ({
                        userId: Id.fromString(userId),
                    })));
                    const userIdsAlreadyMuted = existingMutes.map(row => row.userId.toString());
                    const userIdsToBeMuted = userIds.filter(userId => !userIdsAlreadyMuted.includes(userId));
                    const newMutes = userIdsToBeMuted.map(userId => ({
                        userId: Id.fromString(userId)
                    }));
                    await chatTables.mutes.create(...newMutes);
                    events.mutes.publish({ appId, userIds: userIdsToBeMuted });
                }
            },
            async removeMute(userIds) {
                if (userIds.length) {
                    await chatTables.mutes.delete(findAll(userIds, userId => ({ userId: Id.fromString(userId) })));
                    events.unmutes.publish({ appId, userIds });
                }
            },
            async unmuteAll() {
                await chatTables.mutes.delete({ conditions: false });
                events.unmuteAll.publish({ appId });
            },
            async setRoomStatus(room, status) {
                await chatTables.roomStatuses.update({
                    ...find({ room }),
                    upsert: { room, status },
                });
                events.roomStatusChanged.publish({ appId, room, status });
            },
            async getRoomStatus(room) {
                const row = await chatTables.roomStatuses.readOne(find({ room }));
                return row
                    ? row.status
                    : ChatStatus.Offline;
            },
        };
    }
    return {
        events: eventSubscribers,
        namespaceForApp,
    };
}
//# sourceMappingURL=mock-chat-persistence.js.map