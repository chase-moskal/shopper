(function () {
    'use strict';

    function encodeHex(binary) {
        let result = "";
        for (const byte of new Uint8Array(binary))
            result += ("0" + (byte & 0xFF).toString(16)).slice(-2);
        return result;
    }
    const hexabet = "0123456789abcdef";
    function isStrictHex(text) {
        for (const character of text)
            if (!hexabet.includes(character))
                return false;
        return true;
    }
    function isHex(text) {
        return isStrictHex(text.toLowerCase());
    }
    function decodeHex(text) {
        const hex = text.toLowerCase();
        if (!isStrictHex(hex))
            throw new Error("decodeHex: invalid hex");
        const result = [];
        for (let i = 0; i < hex.length; i += 2)
            result.push(parseInt(hex.substr(i, 2), 16));
        return new Uint8Array(result).buffer;
    }

    var __classPrivateFieldSet$g = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$r = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Id_binary, _Id_string;
    class Id {
        static fromBinary(binary) {
            return new Id(binary);
        }
        static fromString(text) {
            const binary = decodeHex(text);
            return new Id(binary);
        }
        static isId(text) {
            return text.length === 64 && isHex(text);
        }
        constructor(binary) {
            _Id_binary.set(this, void 0);
            _Id_string.set(this, void 0);
            __classPrivateFieldSet$g(this, _Id_binary, binary, "f");
            __classPrivateFieldSet$g(this, _Id_string, encodeHex(binary), "f");
        }
        get binary() { return __classPrivateFieldGet$r(this, _Id_binary, "f"); }
        get string() { return __classPrivateFieldGet$r(this, _Id_string, "f"); }
        toBinary() { return __classPrivateFieldGet$r(this, _Id_binary, "f"); }
        toString() { return __classPrivateFieldGet$r(this, _Id_string, "f"); }
        equals(id) {
            return typeof id === "string"
                ? __classPrivateFieldGet$r(this, _Id_string, "f") === id
                : __classPrivateFieldGet$r(this, _Id_string, "f") === id.toString();
        }
    }
    _Id_binary = new WeakMap(), _Id_string = new WeakMap();

    ////////
    ////////
    ////////
    var Operation$1;
    (function (Operation) {
        (function (Type) {
            Type[Type["Create"] = 0] = "Create";
            Type[Type["Update"] = 1] = "Update";
            Type[Type["Delete"] = 2] = "Delete";
        })(Operation.Type || (Operation.Type = {}));
    })(Operation$1 || (Operation$1 = {}));
    ////////
    ////////
    ////////
    const serializationKey = "__serialized_type__";

    function and(...conditions) {
        return ["and", ...conditions];
    }
    function or(...conditions) {
        return ["or", ...conditions];
    }
    function find(...rows) {
        return rows.length
            ? { conditions: or(...rows.map(row => ({ equal: row }))) }
            : { conditions: false };
    }
    function findAll(values, valueForRow) {
        return { conditions: or(...values.map(v => ({ equal: valueForRow(v) }))) };
    }
    async function assert(table, conditional, make) {
        let row = await table.readOne(conditional);
        if (!row) {
            row = await make();
            await table.create(row);
        }
        return row;
    }

    function memoryFlexStorage() {
        const map = new Map();
        return {
            async read(key) {
                return map.get(key);
            },
            async write(key, data) {
                map.set(key, data);
            },
            async delete(key) {
                map.delete(key);
            },
        };
    }

    function jsonStorage(storage) {
        return {
            read(key) {
                let data = undefined;
                const raw = storage.getItem(key);
                if (raw) {
                    try {
                        data = JSON.parse(raw);
                    }
                    catch (error) {
                        storage.removeItem(key);
                    }
                }
                return data;
            },
            write(key, data) {
                const json = JSON.stringify(data);
                storage.setItem(key, json);
            },
            delete(key) {
                storage.removeItem(key);
            },
        };
    }

    function simpleFlexStorage(storage) {
        const json = jsonStorage(storage);
        return {
            async read(key) {
                return json.read(key);
            },
            async write(key, data) {
                return json.write(key, data);
            },
            async delete(key) {
                return json.delete(key);
            },
        };
    }

    var _a$2;
    const isNode = (typeof process !== "undefined")
        && (((_a$2 = process === null || process === void 0 ? void 0 : process.release) === null || _a$2 === void 0 ? void 0 : _a$2.name) === "node");

    async function getRando({ isNode: isNode$1 = isNode } = {}) {
        const randomBuffer = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (bytes) => crypto.randomBytes(bytes).buffer;
            })()
            : (bytes) => crypto.getRandomValues(new Uint8Array(bytes)).buffer;
        const compare = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (a, b) => crypto.timingSafeEqual(Buffer.from(a, "utf8"), Buffer.from(b, "utf8"));
            })()
            : (a, b) => {
                console.warn("insecure compare");
                return a === b;
            };
        function random() {
            const buffer = randomBuffer(8);
            const ints = new Int8Array(buffer);
            ints[7] = 63;
            ints[6] |= 0xf0;
            const view = new DataView(buffer);
            return view.getFloat64(0, true) - 1;
        }
        function randomId() {
            const buffer = randomBuffer(32);
            return new Id(buffer);
        }
        function randomSample(palette) {
            return palette[Math.floor(random() * palette.length)];
        }
        function randomSequence(length, palette) {
            const results = [];
            while (results.length < length) {
                const sample = randomSample(palette);
                results.push(sample);
            }
            return results.join("");
        }
        return {
            random,
            compare,
            randomId,
            randomBuffer,
            randomSample,
            randomSequence,
        };
    }

    function obtain$1(object, path) {
        return path.reduce((x, y) => x && x[y] || undefined, object);
    }

    function serialize(row) {
        const serializedRow = {};
        for (const [key, value] of Object.entries(row)) {
            if (value instanceof Id)
                serializedRow[key] = {
                    [serializationKey]: "Id",
                    value: value.toString(),
                };
            else
                serializedRow[key] = value;
        }
        return serializedRow;
    }
    function deserialize(serializedRow) {
        const row = {};
        for (const [key, value] of Object.entries(serializedRow)) {
            if (value && typeof value === "object" && value[serializationKey]) {
                if (value[serializationKey] === "Id")
                    row[key] = Id.fromString(value.value);
                else
                    throw new Error(`unknown serialized type "${value[serializationKey]}"`);
            }
            else
                row[key] = value;
        }
        return row;
    }

    var __classPrivateFieldSet$f = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$q = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _RowStorage_storage;
    class RowStorage {
        constructor(storage) {
            _RowStorage_storage.set(this, void 0);
            __classPrivateFieldSet$f(this, _RowStorage_storage, storage, "f");
        }
        async save(key, rows) {
            return __classPrivateFieldGet$q(this, _RowStorage_storage, "f").write(key, rows.map(serialize));
        }
        async load(key) {
            var _a;
            const serializedRows = (_a = await __classPrivateFieldGet$q(this, _RowStorage_storage, "f").read(key)) !== null && _a !== void 0 ? _a : [];
            return serializedRows.map(deserialize);
        }
    }
    _RowStorage_storage = new WeakMap();

    function objectMap$3(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }
    function objectMap3(input, mapper) {
        return (Object.fromEntries(Object.entries(input).map(([key, value]) => [key, mapper(value, key)])));
    }

    function sequencer(fun) {
        let promiseChain = Promise.resolve();
        return (async (...args) => {
            const next = promiseChain.then(() => fun(...args));
            promiseChain = next.catch(() => { });
            return next;
        });
    }

    function compare(row, conditional, evaluator) {
        let failures = 0;
        for (const [key, value] of Object.entries(conditional)) {
            if (!evaluator(row[key], value))
                failures += 1;
        }
        return !failures;
    }
    function rowVersusCondition(row, condition) {
        if (!Object.keys(condition).length)
            return true;
        let failures = 0;
        const check = (conditions, evaluator) => {
            if (conditions && !compare(row, conditions, evaluator))
                failures += 1;
        };
        const unwrapId = (x) => x instanceof Id
            ? x.string
            : x;
        const checks = {
            set: a => a !== undefined && a !== null,
            equal: (a, b) => unwrapId(a) === unwrapId(b),
            greater: (a, b) => a > b,
            greatery: (a, b) => a >= b,
            less: (a, b) => a < b,
            lessy: (a, b) => a <= b,
            listed: (a, b) => a.includes(b),
            search: (a, b) => typeof b === "string" ? a.includes(b) : b.test(a),
        };
        function not(evaluator) {
            return (a, b) => !evaluator(a, b);
        }
        check(condition.set, checks.set);
        check(condition.equal, checks.equal);
        check(condition.greater, checks.greater);
        check(condition.greatery, checks.greatery);
        check(condition.less, checks.less);
        check(condition.lessy, checks.lessy);
        check(condition.listed, checks.listed);
        check(condition.search, checks.search);
        check(condition.notSet, not(checks.set));
        check(condition.notEqual, not(checks.equal));
        check(condition.notGreater, not(checks.greater));
        check(condition.notGreatery, not(checks.greatery));
        check(condition.notLess, not(checks.less));
        check(condition.notLessy, not(checks.lessy));
        check(condition.notListed, not(checks.listed));
        check(condition.notSearch, not(checks.search));
        return !failures;
    }
    function rowVersusConditional(row, conditional) {
        function crawl(conditions) {
            if (conditions === false)
                return true;
            const [operation, ...rawconds] = conditions;
            const conds = rawconds.filter(c => !!c);
            if (conds.length === 0)
                throw new Error("empty and/or conditions are not allowed");
            const and = operation === "and";
            let valid = and;
            const applyResult = (result) => valid = and
                ? valid && result
                : valid || result;
            for (const condition of conds) {
                if (condition === false || Array.isArray(condition)) {
                    applyResult(crawl(condition));
                }
                else {
                    const result = rowVersusCondition(row, condition);
                    applyResult(result);
                }
            }
            return valid;
        }
        return crawl(conditional.conditions);
    }

    function applyOperation({ rows, operation }) {
        switch (operation.type) {
            case Operation$1.Type.Create: {
                return [...rows, ...operation.rows];
            }
            case Operation$1.Type.Update: {
                let rowsToUpdate = [];
                let otherRows = [];
                for (const row of rows) {
                    if (rowVersusConditional(row, operation.update))
                        rowsToUpdate.push(row);
                    else
                        otherRows.push(row);
                }
                const { write, whole, upsert } = operation.update;
                if (write && rowsToUpdate.length) {
                    rowsToUpdate = rowsToUpdate.map(row => ({ ...row, ...write }));
                }
                else if (upsert) {
                    if (rowsToUpdate.length)
                        rowsToUpdate = rowsToUpdate.map(row => ({ ...row, ...upsert }));
                    else
                        rowsToUpdate.push({ ...upsert });
                }
                else if (whole) {
                    rowsToUpdate = [];
                    rowsToUpdate = [whole];
                }
                else
                    throw new Error("invalid update");
                return [...rowsToUpdate, ...otherRows];
            }
            case Operation$1.Type.Delete: {
                return rows.filter(row => !rowVersusConditional(row, operation.conditional));
            }
            default:
                throw new Error("invalid operation");
        }
    }

    function prefixFunctions(prefix, functions) {
        return objectMap$3(functions, fun => async (...args) => {
            await prefix();
            return fun(...args);
        });
    }

    async function memoryTransaction({ shape, rowStorage, action, makeTableName, }) {
        const operations = [];
        const tables = (() => {
            function recurse(shape, path) {
                return objectMap$3(shape, (value, key) => {
                    const currentPath = [...path, key];
                    const storageKey = makeTableName(currentPath);
                    let cache = undefined;
                    async function loadCacheOnce() {
                        if (!cache)
                            cache = await rowStorage.load(storageKey);
                    }
                    return typeof value === "boolean"
                        ? prefixFunctions(loadCacheOnce, {
                            async create(...rows) {
                                const operation = {
                                    type: Operation$1.Type.Create,
                                    path: currentPath,
                                    rows,
                                };
                                cache = applyOperation({ operation, rows: cache });
                                operations.push(operation);
                            },
                            async read(o) {
                                const rows = cache.filter(row => rowVersusConditional(row, o));
                                const { order, offset = 0, limit = 1000 } = o;
                                if (order) {
                                    for (const [key, value] of Object.entries(order)) {
                                        rows.sort((a, b) => value === "ascend"
                                            ? a[key] > b[key] ? 1 : -1
                                            : a[key] > b[key] ? -1 : 1);
                                    }
                                }
                                return rows.slice(offset, offset + limit);
                            },
                            async update(o) {
                                const operation = {
                                    type: Operation$1.Type.Update,
                                    path: currentPath,
                                    update: o,
                                };
                                cache = applyOperation({ operation, rows: cache });
                                operations.push(operation);
                            },
                            async delete(o) {
                                const operation = {
                                    type: Operation$1.Type.Delete,
                                    path: currentPath,
                                    conditional: o,
                                };
                                cache = applyOperation({ operation, rows: cache });
                                operations.push(operation);
                            },
                            async count(o) {
                                const rows = cache.filter(row => rowVersusConditional(row, o));
                                return rows.length;
                            },
                            async average({ fields, ...o }) {
                                const rows = cache.filter(row => rowVersusConditional(row, o));
                                return objectMap3(fields, (x, key) => {
                                    let sum = 0;
                                    let total = 0;
                                    for (const row of rows) {
                                        const value = row[key];
                                        if (typeof value === "number" && !isNaN(value)) {
                                            sum += value;
                                            total += 1;
                                        }
                                    }
                                    return total > 0
                                        ? sum / total
                                        : 0;
                                });
                            },
                            async readOne(o) {
                                return cache.find(row => rowVersusConditional(row, o));
                            },
                        })
                        : recurse(value, currentPath);
                });
            }
            return recurse(shape, []);
        })();
        let aborted = false;
        const result = await action({
            tables,
            async abort() {
                aborted = true;
            },
        });
        if (!aborted) {
            const loadedRows = new Map();
            for (const { path } of operations) {
                const storageKey = makeTableName(path);
                const rows = await rowStorage.load(storageKey);
                loadedRows.set(storageKey, rows);
            }
            for (const operation of operations) {
                const storageKey = makeTableName(operation.path);
                const rows = loadedRows.get(storageKey);
                const modifiedRows = applyOperation({ operation, rows });
                loadedRows.set(storageKey, modifiedRows);
            }
            for (const [storageKey, rows] of loadedRows.entries()) {
                await rowStorage.save(storageKey, rows);
            }
        }
        return result;
    }

    function makeTableNameWithUnderscores(path) {
        return path.join("_");
    }

    function flex({ shape, flexStorage, makeTableName = makeTableNameWithUnderscores, }) {
        const rowStorage = new RowStorage(flexStorage);
        const safeMemoryTransaction = sequencer(memoryTransaction);
        return {
            tables: (() => {
                function recurse(innerShape, path) {
                    return objectMap$3(innerShape, (value, key) => {
                        const currentPath = [...path, key];
                        function prep(method) {
                            return async (...args) => safeMemoryTransaction({
                                shape,
                                rowStorage,
                                action: async ({ tables }) => (obtain$1(tables, currentPath)[method](...args)),
                                makeTableName,
                            });
                        }
                        return typeof value === "boolean"
                            ? asTable({
                                create: prep("create"),
                                read: prep("read"),
                                update: prep("update"),
                                delete: prep("delete"),
                                count: prep("count"),
                                average: prep("average"),
                                readOne: prep("readOne"),
                            })
                            : recurse(value, currentPath);
                    });
                }
                return recurse(shape, []);
            })(),
            async transaction(action) {
                return safeMemoryTransaction({
                    shape,
                    rowStorage,
                    action,
                    makeTableName,
                });
            },
        };
    }
    function asTable(table) {
        return table;
    }

    function memory({ shape, makeTableName, }) {
        return flex({
            shape,
            flexStorage: memoryFlexStorage(),
            makeTableName,
        });
    }

    function fallback({ table, fallbackRows }) {
        const { tables: { fallbackTable } } = memory({
            shape: { fallbackTable: true },
        });
        let initialized = false;
        async function initialize() {
            if (!initialized) {
                initialized = true;
                await fallbackTable.create(...fallbackRows);
            }
        }
        return {
            create: table.create,
            delete: table.delete,
            update: table.update,
            async read(options) {
                await initialize();
                const [fallbackRows, actualRows] = await Promise.all([
                    fallbackTable.read(options),
                    table.read(options),
                ]);
                return [...fallbackRows, ...actualRows];
            },
            async readOne(options) {
                var _a;
                await initialize();
                return (_a = (await table.readOne(options))) !== null && _a !== void 0 ? _a : (await fallbackTable.readOne(options));
            },
            async count(options) {
                await initialize();
                const [fallbackCount, actualCount] = await Promise.all([
                    fallbackTable.count(options),
                    table.count(options),
                ]);
                return fallbackCount + actualCount;
            },
        };
    }

    function isTable(possibleTable) {
        return typeof possibleTable.create === "function";
    }

    function subsection(database, grabber) {
        return {
            tables: grabber(database.tables),
            async transaction(action) {
                return database.transaction(async ({ tables, abort }) => action({
                    tables: grabber(tables),
                    abort,
                }));
            },
        };
    }

    function constrain({ table, constraint, }) {
        const spike = (conditionTree) => (conditionTree
            ? and({ equal: constraint }, conditionTree)
            : and({ equal: constraint }));
        return {
            async create(...rows) {
                return table.create(...rows.map(row => ({ ...row, ...constraint })));
            },
            async read(options) {
                return table.read({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async readOne(options) {
                return table.readOne({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async update(options) {
                const opts = options;
                return table.update({
                    ...options,
                    conditions: spike(options.conditions),
                    upsert: opts.upsert
                        ? { ...opts.upsert, ...constraint }
                        : undefined,
                    whole: opts.whole
                        ? { ...opts.whole, ...constraint }
                        : undefined,
                    write: opts.write
                        ? { ...opts.write, ...constraint }
                        : undefined,
                });
            },
            async delete(options) {
                return table.delete({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async count(options) {
                return table.count({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
        };
    }
    function constrainTables({ tables, constraint }) {
        function recurse(t) {
            return objectMap$3(t, value => isTable(value)
                ? constrain({ constraint, table: value })
                : recurse(value));
        }
        return recurse(tables);
    }

    async function mockRegisterApp({ ownerEmail, adminEmail, appOrigins, platformOrigin, backend }) {
        const mockBrowserForPlatform = await backend.mockBrowser({ appOrigin: platformOrigin });
        const mockWindowForPlatform = await mockBrowserForPlatform.mockAppWindow({
            appId: backend.platformAppId,
        });
        const { accessModel, appsModel } = mockWindowForPlatform.models;
        await accessModel.sendLoginLink(ownerEmail);
        await accessModel.login(backend.emails.recallLatestLoginEmail().loginToken);
        const { appId } = await appsModel.registerApp({
            label: "Mock App",
            home: window.location.href,
            origins: appOrigins,
        });
        console.log("mock: register app", appId);
        await appsModel.appEditService.assignAdmin({
            appId,
            email: adminEmail,
        });
        // TODO reactivate store
        // // link bank account with stripe
        // await mockWindowForPlatform.models.storeModel.shares.bank.setupStripeAccount(appId)
        // const stripeDetails = await mockWindowForPlatform.models.bankModel.getStripeAccountDetails(appId)
        // console.log("mock: app stripe details", stripeDetails)
        return appId;
    }

    class RenrakuError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    class ApiError extends RenrakuError {
        constructor(code, message) {
            super(message);
            this.code = code;
        }
    }

    function objectMap$2(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    const is_service = Symbol("is_service");

    const mock = (options = {}) => ({
        forService: (service) => mockService(service, [], options),
        forApi(api) {
            return {
                withMetaMap(map, getHeaders = async () => undefined) {
                    const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withMeta(getter, getHeaders));
                    return recurse2(api, map);
                },
                withAuthMap(map) {
                    const recurse2 = prepareRecursiveMapping((service, getter, path) => mockService(service, path, options).withAuth(getter));
                    return recurse2(api, map);
                },
            };
        },
    });
    function mockService(service, path, options) {
        function prepareProxy(getAuth) {
            const overrides = {};
            return new Proxy({}, {
                set: (t, key, value) => {
                    overrides[key] = value;
                    return true;
                },
                get: (t, key) => {
                    var _a;
                    return ((_a = overrides[key]) !== null && _a !== void 0 ? _a : (async (...params) => {
                        const auth = await getAuth();
                        const method = service.expose(auth)[key];
                        if (method) {
                            return options.spike
                                ? options.spike([...path, key].join("."), method, ...params)
                                : method(...params);
                        }
                        else
                            throw new ApiError(400, `renraku remote method "${key}" not found`);
                    }));
                },
            });
        }
        return {
            withMeta(getMeta, getHeaders = async () => undefined) {
                return prepareProxy(async () => service.policy(await getMeta(), await getHeaders()));
            },
            withAuth(getAuth) {
                return prepareProxy(getAuth);
            },
        };
    }
    function prepareRecursiveMapping(handler) {
        return function recursiveMapping(apiGroup, mapGroup, path = []) {
            return objectMap$2(apiGroup, (value, key) => {
                const newPath = [...path, key];
                if (value[is_service]) {
                    const service = value;
                    return handler(service, mapGroup[key], newPath);
                }
                else {
                    const nextApiGroup = value;
                    const nextMapGroup = mapGroup[key];
                    return recursiveMapping(nextApiGroup, nextMapGroup, newPath);
                }
            });
        };
    }

    const service = () => ({
        policy(p) {
            return {
                expose(e) {
                    return {
                        [is_service]: is_service,
                        expose: e,
                        policy: p,
                    };
                },
            };
        },
    });
    function api(api) {
        return api;
    }

    async function waitForMockLatency(mockLatency) {
        if (mockLatency) {
            const { min, max } = mockLatency;
            if (min > max)
                throw new Error("invalid mock latency (min cannot exceed max)");
            const difference = max - min;
            const latency = min + (Math.random() * difference);
            return new Promise(resolve => setTimeout(resolve, latency));
        }
    }

    /**
     * create a pub/sub context
     */
    function pubsub() {
        let listeners = [];
        return {
            publish: (async (...args) => {
                const operations = listeners.map(listener => listener(...args));
                await Promise.all(operations);
            }),
            subscribe(func) {
                listeners.push(func);
                return () => {
                    listeners = listeners.filter(listener => listener !== func);
                };
            },
            dispose: () => {
                listeners = [];
            },
        };
    }

    const browser = typeof atob === "function";
    function encode(text) {
        return browser
            ? btoa(text)
            : Buffer.from(text).toString("base64");
    }
    function decode(base64) {
        return browser
            ? atob(base64)
            : Buffer.from(base64, "base64").toString("binary");
    }
    const url$1 = Object.freeze({
        encode: (text) => {
            const base64 = encode(text);
            const base64url = addEqualsPadding(base64
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_"));
            return base64url;
        },
        decode: (base64url) => {
            const base64 = base64url
                .replace(/-/g, "+")
                .replace(/_/g, "/");
            return decode(base64);
        },
    });
    function addEqualsPadding(base64) {
        return base64 + Array((4 - base64.length % 4) % 4 + 1).join("=");
    }

    const tokenDecode = function decode(token) {
        const [headerPart, dataPart] = token.split(".");
        const header = decodePart(headerPart);
        const data = decodePart(dataPart);
        return { header, data };
    };
    function decodePart(part) {
        return JSON.parse(decodeURIComponent(url$1.decode(part)
            .split("")
            .map(c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
            .join("")));
    }

    const maxExpiryRenewalCushion = 60 * 1000;
    function isTokenTimingExpired({ exp, iat }) {
        const lifespan = (exp - iat) * 1000;
        const expiry = exp * 1000;
        const tenth = lifespan / 10;
        const cushion = tenth > maxExpiryRenewalCushion
            ? maxExpiryRenewalCushion
            : tenth;
        return Date.now() > (expiry - cushion);
    }

    function isTokenValid(token) {
        return !!token
            && !isTokenTimingExpired(tokenDecode(token).data);
    }

    const decodeAccessToken = (accessToken) => {
        return tokenDecode(accessToken).data.payload;
    };

    function makeAuthMediator({ appId, storage, greenService, }) {
        const tokenChangeEvent = pubsub();
        const accessEvent = pubsub();
        const key = `auth-tokens-${appId}`;
        const emptyTokens = () => ({ accessToken: undefined, refreshToken: undefined });
        const getTokens = async () => { var _a; return (_a = await storage.read(key)) !== null && _a !== void 0 ? _a : emptyTokens(); };
        const setTokens = async (tokens) => storage.write(key, tokens);
        async function commitTokens(tokens) {
            const access = decodeAccessToken(tokens.accessToken);
            await setTokens(tokens);
            await tokenChangeEvent.publish();
            await accessEvent.publish(access);
            return access;
        }
        async function authorize(refreshToken) {
            const accessToken = await greenService.authorize({
                appId,
                refreshToken,
                scope: { core: true },
            });
            const access = await commitTokens({ accessToken, refreshToken });
            return { access, accessToken };
        }
        const obtainAccessAndReauthorizeIfNecessary = (async () => {
            const { accessToken, refreshToken } = await getTokens();
            return isTokenValid(accessToken)
                ? { accessToken, access: decodeAccessToken(accessToken) }
                : isTokenValid(refreshToken)
                    ? authorize(refreshToken)
                    : authorize(undefined);
        });
        return {
            subscribeToAccessChange: accessEvent.subscribe,
            subscribeToTokenChange: tokenChangeEvent.subscribe,
            async initialize() {
                const { access } = await obtainAccessAndReauthorizeIfNecessary();
                await accessEvent.publish(access);
                return access;
            },
            async getValidAccess() {
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async getValidAccessToken() {
                return (await obtainAccessAndReauthorizeIfNecessary()).accessToken;
            },
            async login(tokens) {
                return commitTokens(tokens);
            },
            async logout() {
                await setTokens(emptyTokens());
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async reauthorize() {
                const tokens = await getTokens();
                await setTokens({ ...tokens, accessToken: undefined });
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
        };
    }

    function prepareApiShape({ appId, storage }) {
        let authMediator;
        async function getStandardMeta() {
            return {
                accessToken: await authMediator.getValidAccessToken(),
            };
        }
        const metaMap = {
            auth: {
                apps: {
                    appService: getStandardMeta,
                    appEditService: getStandardMeta,
                },
                permissions: {
                    permissionsService: getStandardMeta,
                },
                users: {
                    greenService: async () => undefined,
                    loginService: getStandardMeta,
                    personalService: getStandardMeta,
                    userService: getStandardMeta,
                },
            },
            example: {
                exampleService: getStandardMeta,
            },
            administrative: {
                roleAssignmentService: getStandardMeta,
            },
            questions: {
                questionsModerationService: getStandardMeta,
                questionsPostingService: getStandardMeta,
                questionsReadingService: getStandardMeta,
                questionsAnsweringService: getStandardMeta,
            },
            videos: {
                dacastService: getStandardMeta,
                contentService: getStandardMeta,
            },
            notes: {
                notesService: getStandardMeta,
            },
            store: {
                billing: getStandardMeta,
                connect: getStandardMeta,
                subscriptions: {
                    listing: getStandardMeta,
                    planning: getStandardMeta,
                    shopping: getStandardMeta,
                },
            },
        };
        function installAuthMediator({ greenService }) {
            authMediator = makeAuthMediator({
                appId,
                storage,
                greenService,
            });
            return authMediator;
        }
        return {
            metaMap,
            installAuthMediator,
        };
    }

    async function stopwatch(promise) {
        const start = Date.now();
        const result = await promise;
        const time = Date.now() - start;
        return [time, result];
    }

    function mockRemote({ api, appId, storage, headers, logging, }) {
        const { metaMap, installAuthMediator } = prepareApiShape({
            appId,
            storage,
        });
        let mockLatency;
        function setMockLatency(value) {
            mockLatency = value;
        }
        const spike = async (method, func, ...params) => {
            const [mockTime] = await stopwatch(waitForMockLatency(mockLatency));
            const [executionTime, result] = await stopwatch(func(...params));
            if (logging)
                console.log(`ðŸ“¡ ${method}() ${executionTime}ms + mock ${mockTime}ms`);
            return result;
        };
        const remote = mock({ spike })
            .forApi(api)
            .withMetaMap(metaMap, async () => headers);
        const authMediator = installAuthMediator({
            greenService: remote.auth.users.greenService,
        });
        return { remote, authMediator, setMockLatency };
    }

    (function(global) {
        var channels = [];

        function BroadcastChannel(channel) {
            var $this = this;
            channel = String(channel);

            var id = '$BroadcastChannel$' + channel + '$';

            channels[id] = channels[id] || [];
            channels[id].push(this);

            this._name = channel;
            this._id = id;
            this._closed = false;
            this._mc = new MessageChannel();
            this._mc.port1.start();
            this._mc.port2.start();

            global.addEventListener('storage', function(e) {
                if (e.storageArea !== global.localStorage) return;
                if (e.newValue == null || e.newValue === '') return;
                if (e.key.substring(0, id.length) !== id) return;
                var data = JSON.parse(e.newValue);
                $this._mc.port2.postMessage(data);
            });
        }

        BroadcastChannel.prototype = {
            // BroadcastChannel API
            get name() {
                return this._name;
            },
            postMessage: function(message) {
                var $this = this;
                if (this._closed) {
                    var e = new Error();
                    e.name = 'InvalidStateError';
                    throw e;
                }
                var value = JSON.stringify(message);

                // Broadcast to other contexts via storage events...
                var key = this._id + String(Date.now()) + '$' + String(Math.random());
                global.localStorage.setItem(key, value);
                setTimeout(function() {
                    global.localStorage.removeItem(key);
                }, 500);

                // Broadcast to current context via ports
                channels[this._id].forEach(function(bc) {
                    if (bc === $this) return;
                    bc._mc.port2.postMessage(JSON.parse(value));
                });
            },
            close: function() {
                if (this._closed) return;
                this._closed = true;
                this._mc.port1.close();
                this._mc.port2.close();

                var index = channels[this._id].indexOf(this);
                channels[this._id].splice(index, 1);
            },

            // EventTarget API
            get onmessage() {
                return this._mc.port1.onmessage;
            },
            set onmessage(value) {
                this._mc.port1.onmessage = value;
            },
            addEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.addEventListener.apply(this._mc.port1, arguments);
            },
            removeEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.removeEventListener.apply(this._mc.port1, arguments);
            },
            dispatchEvent: function(/*event*/) {
                return this._mc.port1.dispatchEvent.apply(this._mc.port1, arguments);
            },
        };

        global.BroadcastChannel = global.BroadcastChannel || BroadcastChannel;
    })(self);

    function wireMediatorBroadcastChannel({ appId, authMediator }) {
        const channel = new BroadcastChannel("tokenChangeEvent");
        authMediator.subscribeToTokenChange(() => channel.postMessage({ appId }));
        channel.onmessage = (event) => {
            if (event.data.appId === appId)
                authMediator.initialize();
        };
    }

    async function mockWiredRemote({ appId, appOrigin, storage, backend, }) {
        const { remote, authMediator, setMockLatency } = mockRemote({
            appId,
            storage,
            logging: true,
            api: backend.api,
            headers: { origin: appOrigin },
        });
        wireMediatorBroadcastChannel({ appId, authMediator });
        return { remote, authMediator, setMockLatency };
    }

    const second = 1000;
    const minute = 60 * second;
    const hour = 60 * minute;
    const day = 24 * hour;
    const year = 365 * day;
    const month = year / 12;

    const mockConfig = ({ root, platformHome, platformOrigins }) => ({
        webRoot: root,
        server: {
            port: 4999,
            detailedLogs: true,
        },
        platform: {
            legalLink: "https://xiome.io/legal",
            technician: {
                email: "chasemoskal@gmail.com",
            },
            appDetails: {
                appId: "27a9f4e61286d562c85df1862e88c50e6b5c0707cc84e3e1df4aeb9d9c236814",
                label: "Xiome Cloud",
                home: platformHome,
                origins: platformOrigins,
            },
        },
        dacast: "mock-mode",
        email: "mock-console",
        database: "mock-storage",
        stripe: "mock-mode",
        store: {
            popupReturnUrl: "/popups/return"
        },
        chat: {
            port: 8001
        },
        crypto: {
            keys: "mock-mode",
            tokenLifespans: {
                login: 5 * minute,
                refresh: 30 * day,
                access: 5 * minute,
                external: 5 * minute,
            },
        },
    });

    function pub() {
        const records = new Map();
        return {
            subscribe(...listeners) {
                if (listeners.length) {
                    const id = Symbol();
                    records.set(id, listeners);
                    return () => {
                        records.delete(id);
                    };
                }
            },
            async publish(...args) {
                await Promise.all(Array.from(records.values())
                    .flat()
                    .map(listener => listener(...args)));
            },
            clear() {
                records.clear();
            },
        };
    }

    function onesie(operation) {
        let activeOperation;
        return async function (...args) {
            if (activeOperation)
                return activeOperation;
            else {
                activeOperation = operation(...args);
                const result = await activeOperation;
                activeOperation = undefined;
                return result;
            }
        };
    }

    var Ops;
    (function (Ops) {
        (function (Mode) {
            Mode[Mode["None"] = 0] = "None";
            Mode[Mode["Loading"] = 1] = "Loading";
            Mode[Mode["Error"] = 2] = "Error";
            Mode[Mode["Ready"] = 3] = "Ready";
        })(Ops.Mode || (Ops.Mode = {}));
    })(Ops || (Ops = {}));
    const ops = {
        none: () => ({
            mode: Ops.Mode.None,
        }),
        loading: () => ({
            mode: Ops.Mode.Loading,
        }),
        error: (reason) => ({
            mode: Ops.Mode.Error,
            reason,
        }),
        ready: (value) => ({
            mode: Ops.Mode.Ready,
            value,
        }),
        replaceValue(op, value) {
            return op.mode === Ops.Mode.Ready
                ? { ...op, value }
                : op;
        },
        isNone: (op) => op.mode === Ops.Mode.None,
        isLoading: (op) => op.mode === Ops.Mode.Loading,
        isError: (op) => op.mode === Ops.Mode.Error,
        isReady: (op) => op.mode === Ops.Mode.Ready,
        value(op) {
            return op.mode === Ops.Mode.Ready
                ? op.value
                : undefined;
        },
        select(op, options) {
            switch (op.mode) {
                case Ops.Mode.None: return options.none();
                case Ops.Mode.Loading: return options.loading();
                case Ops.Mode.Error: return options.error(op.reason);
                case Ops.Mode.Ready: return options.ready(op.value);
            }
        },
        async operation({ promise, errorReason = "an error occurred", setOp, }) {
            await setOp(ops.loading());
            try {
                const value = await promise;
                await setOp(ops.ready(value));
                return value;
            }
            catch (error) {
                await setOp(ops.error(errorReason));
                throw error;
            }
        },
        mode(op) {
            return ops.select(op, {
                none: () => "none",
                loading: () => "loading",
                error: () => "error",
                ready: () => "ready",
            });
        },
        combine(...ops) {
            const isAnyError = !!ops.find(op => op.mode === Ops.Mode.Error);
            const isAnyLoading = !!ops.find(op => op.mode === Ops.Mode.Loading);
            const isAnyNotReady = !!ops.find(op => op.mode !== Ops.Mode.Ready);
            return isAnyError
                ? { mode: Ops.Mode.Error, reason: "error" }
                : isAnyLoading
                    ? { mode: Ops.Mode.Loading }
                    : isAnyNotReady
                        ? { mode: Ops.Mode.None }
                        : { mode: Ops.Mode.Ready, value: undefined };
        },
        debug(op) {
            return ops.select(op, {
                none: () => [`<op {mode: None}>`],
                loading: () => [`<op {mode: Loading}>`],
                error: reason => [`<op {mode: Error, reason: "${reason}"}>`],
                ready: value => [`<op {mode: Ready, value: `, value, `}>`],
            });
        },
    };

    function isVoid(x) {
        return x === undefined || x === null;
    }

    function obtain(object, path) {
        let current = object;
        for (const key of path) {
            current = current[key];
            if (isVoid(current))
                break;
        }
        return current;
    }

    function objectMap$1(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    function isPlainObject(value) {
        if (typeof value !== "object" || value === null)
            return false;
        const prototype = Object.getPrototypeOf(value);
        return prototype === Object.prototype || prototype === null;
    }

    const symbolToAllowProxyIntoState = Symbol("symbolToAllowProxyIntoState");

    function unproxy(x, unlessSymbol = symbolToAllowProxyIntoState) {
        return (isPlainObject(x) && !x[unlessSymbol])
            ? objectMap$1(x, value => unproxy(value, unlessSymbol))
            : x;
    }

    function debounce(delay, action) {
        let latestArgs;
        let timeout;
        let waitingQueue = [];
        function reset() {
            latestArgs = undefined;
            if (timeout)
                clearTimeout(timeout);
            timeout = undefined;
            waitingQueue = [];
        }
        reset();
        return ((...args) => {
            latestArgs = args;
            if (timeout)
                clearTimeout(timeout);
            const promise = new Promise((resolve, reject) => {
                waitingQueue.push({ resolve, reject });
            });
            timeout = setTimeout(() => {
                Promise.resolve()
                    .then(() => action(...latestArgs))
                    .then(r => {
                    for (const { resolve } of waitingQueue)
                        resolve(r);
                    reset();
                })
                    .catch(err => {
                    for (const { reject } of waitingQueue)
                        reject(err);
                    reset();
                });
            }, delay);
            return promise;
        });
    }

    function attemptNestedProperty(object, path, value) {
        const pathToSubObject = [...path];
        const finalKey = pathToSubObject.pop();
        let currentSubObject = object;
        for (const key of pathToSubObject) {
            if (typeof currentSubObject[key] === "object") {
                currentSubObject = currentSubObject[key];
            }
            else {
                throw new Error("unable to write property to object tree containing undefined");
            }
        }
        currentSubObject[finalKey] = value;
    }

    class SnapstateError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    class SnapstateReadonlyError extends SnapstateError {
    }
    class SnapstateCircularError extends SnapstateError {
    }

    function containsPath(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length === comparisonPath.length) {
                for (let i = 0; i < path.length; i++) {
                    if (path[i] !== comparisonPath[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }
    function containsPathOrChildren(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length <= comparisonPath.length) {
                for (let i = 0; i < path.length; i++) {
                    if (path[i] !== comparisonPath[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }
    function containsPathOrParents(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length >= comparisonPath.length) {
                for (let i = 0; i < comparisonPath.length; i++) {
                    if (comparisonPath[i] !== path[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }

    function snapstate(tree) {
        const masterTree = unproxy(tree, symbolToAllowProxyIntoState);
        let activeUpdate = false;
        let activeTrackThatIsRecording;
        const trackingSessions = new Map();
        const subscriptions = new Set();
        function findTrackingSessions(path) {
            const sessions = [];
            for (const [, session] of trackingSessions) {
                if (session.flip) {
                    if (containsPathOrParents(session.paths, path))
                        sessions.push(session);
                }
                else {
                    if (containsPathOrChildren(session.paths, path))
                        sessions.push(session);
                }
            }
            return sessions;
        }
        const writable = recurse(masterTree, true, []);
        const readable = recurse(masterTree, false, []);
        let updateQueue = [];
        const update = debounce(1, () => {
            for (const path of updateQueue) {
                activeUpdate = true;
                try {
                    for (const subscription of subscriptions) {
                        subscription(readable);
                    }
                    for (const { observer, reaction } of findTrackingSessions(path)) {
                        if (reaction)
                            reaction(observer(readable));
                        else
                            observer(readable);
                    }
                }
                finally {
                    activeUpdate = false;
                }
            }
            updateQueue = [];
        });
        let waiter = Promise.resolve();
        function queueUpdate(path) {
            if (!containsPath(updateQueue, path))
                updateQueue.push(path);
            waiter = update();
        }
        function recurse(target, allowWrites, path) {
            return new Proxy(target, {
                get(t, property) {
                    var _a;
                    const currentPath = [...path, property];
                    if (activeTrackThatIsRecording) {
                        if (!containsPath(activeTrackThatIsRecording.paths, currentPath)) {
                            activeTrackThatIsRecording.paths.push(currentPath);
                        }
                    }
                    const value = (_a = obtain(masterTree, currentPath)) !== null && _a !== void 0 ? _a : obtain(t, [property]);
                    return isPlainObject(value)
                        ? recurse(value, allowWrites, currentPath)
                        : value;
                },
                set(t, property, value) {
                    const currentPath = [...path, property];
                    if (allowWrites) {
                        if (activeTrackThatIsRecording || activeUpdate)
                            throw new SnapstateCircularError("forbidden state circularity");
                        const existingValue = obtain(masterTree, currentPath);
                        const isChanged = value !== existingValue;
                        if (isChanged) {
                            attemptNestedProperty(masterTree, currentPath, unproxy(value, symbolToAllowProxyIntoState));
                            queueUpdate(currentPath);
                        }
                        return true;
                    }
                    else {
                        throw new SnapstateReadonlyError(`state is read-only here, cannot set ${currentPath.join(".")}`);
                    }
                }
            });
        }
        const untrackers = new Set();
        const unsubscribers = new Set();
        return {
            state: writable,
            writable,
            readable,
            readonly: readable,
            subscribe(subscription) {
                subscriptions.add(subscription);
                const unsubscribe = () => subscriptions.delete(subscription);
                unsubscribers.add(unsubscribe);
                return unsubscribe;
            },
            track(observer, reaction, { flip = false } = {}) {
                const identifier = Symbol();
                activeTrackThatIsRecording = { paths: [], flip, observer, reaction };
                trackingSessions.set(identifier, activeTrackThatIsRecording);
                observer(readable);
                activeTrackThatIsRecording = undefined;
                const untrack = () => trackingSessions.delete(identifier);
                untrackers.add(untrack);
                return untrack;
            },
            unsubscribeAll() {
                for (const unsubscribe of unsubscribers)
                    unsubscribe();
                unsubscribers.clear();
            },
            untrackAll() {
                for (const untrack of untrackers)
                    untrack();
                untrackers.clear();
            },
            async wait() {
                await waiter;
            },
        };
    }

    function makeChatState() {
        return snapstate({
            accessOp: ops.none(),
            connectionOp: ops.none(),
            cache: {
                mutedUserIds: [],
                roomStats: {},
                rooms: {},
            },
        });
    }

    const chatRegularPrivileges = {
        "view all chats": "985dc13378d1129e4dd6303fe9e52dff97d53568ce10814805f481159c788710",
        "participate in all chats": "bd0c8dfdf3eef893a5d9f8b5d0a6cad19ad80e949ebd70428f0d7525099cdd10",
    };
    const chatPowerPrivileges = {
        "moderate all chats": "693d969777a3998de6f9a4a5583917f4e672bb96ed08c571fc7486593ca98993",
    };
    const chatPrivileges = {
        ...chatRegularPrivileges,
        ...chatPowerPrivileges,
    };

    function asPermissions(permissions) {
        return permissions;
    }
    function has(privileges, hasPrivilege) {
        const hasPrivileges = {};
        for (const key of Object.keys(privileges))
            hasPrivileges[key] = hasPrivilege;
        return hasPrivileges;
    }
    function mutable(active, privileges) {
        return has(privileges, { active, immutable: false });
    }
    function immutable(active, privileges) {
        return has(privileges, { active, immutable: true });
    }

    const storePowerPrivileges = {
        "control stripe account": "f236bd2175fbecf7925483884b8c2a2ffe0dd2f0a864cbd638046f6fc58944b5",
        "manage store": "bea0ef0db58a0d8c9ab96bb9b14f889a19893064361b0877626b510b798c6fb8",
        "give away freebies": "c2712efd490c67b44946bc6e1bbe82aee5b8ede384cff614ba7435d429993ec6",
    };
    const storePrivileges = { ...storePowerPrivileges };

    const videoPowerPrivileges = {
        "view all videos": "22f380eb0c5c7463b8a16fcdfc2f5e58257d38f94972924e70d27a08fabb5506",
        "moderate videos": "1b19013344a59cb49bfd9bddc8dd817a9e4cfa29003437021df24bdc832ec246",
    };
    const videoPrivileges = { ...videoPowerPrivileges };

    const universalPrivilege = "c1cb5ac1000af6081ff47e80804de7542b57a1425c3faac8153e708aaf79271a";
    const commonPrivileges = {
        "read questions": "5b19b929648cbbe26c052a5016892b370f048eead1e6a303a50b7f5234ec5161",
        "post questions": "aeaae6139d05f77193ca7c272a65977c70cb188f3070359866237a5ade84ba15",
        "like questions": "5490898c541d733956b28664e7536673842e73b289fc45ab9caf143138c14a3e",
        "report questions": "f2f89d433f398b267e320e0e3b9929eb3934af5c02f7e3fb2e032fd19399ad21",
        ...chatRegularPrivileges,
    };
    const commonPowerPrivileges = {
        "edit any profile": "4240ca0331e8679a444c6c4c6a803d8a12893f1554460af426064b980164c8ee",
        "customize permissions": "f380d9b4d1001da8dc86a6e0b6a0721b92ed8060c52cd4ba433e76cbd9efe6b5",
        "answer questions": "afaa00f7bc9ab09d3bbc61a26f6d9bc666cd9bb7ac270ebbdeba3cf4dd3ab9a9",
        "moderate questions": "f6a3152a13f313a60f84d82ba8f7765afb19f70c04ef14688d802237a5d2ab5e",
        "view stats": "092866ae6378833e43ec7001188aa1829d4cf2858e42da0ad3f44a2fedbcb07b",
        "administrate user roles": "a072e9dd003a762e7d693658d8ac724be352b18da240843f691595c89020e350",
        ...videoPowerPrivileges,
        ...storePowerPrivileges,
        ...chatPowerPrivileges,
    };
    const platformPowerPrivileges = {
        "edit any app": "e5fadb4b03badd6699b355ec43e1d150d6f4df81ecc291b5b742f06ebe62a0f8",
        "view platform stats": "eec7d2ddc20df6080c4166a3dea0b2643b483ce61326cbefad95e45824810692",
    };
    const appPowerPrivileges = {};
    const active = true;
    const INACTIVE = false;
    const universalPermissions = asPermissions({
        privileges: {
            ...commonPrivileges,
            ...commonPowerPrivileges,
            "universal": universalPrivilege,
            "banned": "ffff9ebcbe8f69f3520ec574f5a1489a70bf04521d7a85fcbd25c54cc22802f1",
        },
        roles: {
            "everybody": {
                roleId: "aaaa777dc7d7e9b5e9e0386abf0cf2f059cda4f71779cc910b85e8f504452b23",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: true, immutable: true },
                    "banned": { active: false, immutable: true },
                    "read questions": { active: true, immutable: false },
                    "view all chats": { active: true, immutable: false },
                },
            },
            "authenticated": {
                roleId: "bbbb642d549d06113953a01fb52a8e010150edc502b929395bfb32d250d44b1c",
                public: false,
                assignable: false,
                hasPrivileges: {
                    ...mutable(active, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "banned": {
                roleId: "dead633608412f8eefbb40f4678ef2bafaeb7883d09a6094dafe5f69dd6a8684",
                public: true,
                assignable: true,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: true, immutable: true },
                },
            },
            "technician": {
                roleId: "9999d97119a83ea3853273a93e24ae0a1f2a994eccb21dacacab6ff860d8d869",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
        },
    });
    const platformPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...platformPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, platformPowerPrivileges),
                },
            },
        },
    });
    const appPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...appPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "admin": {
                roleId: "d21e66058b95b3b2e80c1a00c82abd56b8ec7a4b20f0424c2a00cc6ba352efeb",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, appPowerPrivileges),
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, appPowerPrivileges),
                },
            },
        },
    });

    function chatAllowance(privileges) {
        return {
            moderateAllChats: privileges.includes(chatPrivileges["moderate all chats"]),
            participateInAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]),
            viewAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]) ||
                privileges.includes(chatPrivileges["view all chats"]),
            banned: privileges.includes(appPermissions.privileges["banned"]),
        };
    }

    const chatShape = {
        posts: true,
        mutes: true,
        roomStatuses: true,
        roomUsers: true,
    };
    var ChatStatus;
    (function (ChatStatus) {
        ChatStatus[ChatStatus["Offline"] = 0] = "Offline";
        ChatStatus[ChatStatus["Online"] = 1] = "Online";
    })(ChatStatus || (ChatStatus = {}));

    function makeChatRoom({ label, serverside, state }) {
        const getRoomCache = () => state.readable.cache.rooms[label];
        const getAccess = () => ops.value(state.readable.accessOp);
        return {
            get posts() {
                var _a, _b;
                return (_b = (_a = getRoomCache()) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [];
            },
            get status() {
                var _a, _b;
                return (_b = (_a = getRoomCache()) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : ChatStatus.Offline;
            },
            get muted() {
                return state.readable.cache.mutedUserIds;
            },
            get weAreMuted() {
                const { user: { userId } } = getAccess();
                return state.readable.cache.mutedUserIds.includes(userId);
            },
            get weAreBanned() {
                const { permit: { privileges } } = getAccess();
                return privileges.includes(appPermissions.privileges["banned"]);
            },
            setRoomStatus(status) {
                serverside.chatServer.setRoomStatus(label, status);
            },
            post(draft) {
                serverside.chatServer.post(label, draft);
            },
            remove(postIds) {
                serverside.chatServer.remove(label, postIds);
            },
            clear() {
                serverside.chatServer.clear(label);
            },
            mute(userId) {
                serverside.chatServer.mute([userId]);
            },
            unmute(userId) {
                serverside.chatServer.unmute([userId]);
            },
            unmuteAll() {
                serverside.chatServer.unmuteAll();
            },
        };
    }

    function setupRoomManagement({ state, reconnect, disconnect }) {
        async function assertConnection() {
            return ops.isReady(state.readable.connectionOp)
                ? ops.value(state.readable.connectionOp)
                : reconnect();
        }
        const followers = new Map();
        const rooms = new Map();
        function assertFollowing(label) {
            let following = followers.get(label);
            if (!following) {
                following = new Set();
                followers.set(label, following);
            }
            return following;
        }
        function assertRoom(label) {
            let room = rooms.get(label);
            if (!room) {
                room = assertConnection()
                    .then(connection => connection.serverside.chatServer.roomSubscribe(label)
                    .then(() => connection))
                    .then(connection => makeChatRoom({
                    label,
                    state,
                    serverside: connection.serverside,
                }));
                rooms.set(label, room);
            }
            return room;
        }
        function removeRoom(label) {
            const room = rooms.get(label);
            assertConnection()
                .then(connection => room.then(r => {
                connection.serverside.chatServer.roomUnsubscribe(label);
            }))
                .then(() => {
                rooms.delete(label);
                if (rooms.size === 0) {
                    return disconnect();
                }
            });
        }
        async function getRoomSession(label) {
            const following = assertFollowing(label);
            const follower = Symbol();
            following.add(follower);
            function dispose() {
                following.delete(follower);
                if (following.size === 0)
                    removeRoom(label);
            }
            return {
                dispose,
                room: await assertRoom(label),
            };
        }
        async function updateAuthSituation(auth) {
            if (auth) {
                if (rooms.size > 0)
                    await assertConnection();
            }
            else if (rooms.size === 0)
                await disconnect();
        }
        return { getRoomSession, updateAuthSituation };
    }

    function makeStatsFetcher({ state, intervalDuration }) {
        let intervalId = undefined;
        function clearStatsInterval() {
            clearInterval(intervalId);
            intervalId = undefined;
        }
        return {
            startInterval(connection) {
                clearStatsInterval();
                intervalId = setInterval(async () => {
                    const stats = await connection.serverside.chatServer.getStats();
                    state.writable.cache.roomStats = stats;
                }, intervalDuration);
            },
            stopInterval: clearStatsInterval,
        };
    }

    const chatPostMaxLength = 280;
    const chatPostCoolOff = 3000;
    const chatRateLimitingInterval = 60000;
    const maximumNumberOfPostsShownAtOnce = 50;

    const makeChatClientside = ({ state, onChange }) => api({
        chatClient: service()
            .policy(async () => { })
            .expose(() => {
            async function triggerChange() {
                await state.wait();
                onChange();
            }
            return {
                async roomStatusChanged(room, status) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                status,
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsAdded(room, posts) {
                    var _a, _b;
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [
                                    ...(_b = (_a = state.writable.cache.rooms[room]) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [],
                                    ...posts,
                                ].slice(0, maximumNumberOfPostsShownAtOnce)
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsRemoved(room, postIds) {
                    var _a, _b;
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: ((_b = (_a = state.writable.cache.rooms[room]) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [])
                                    .filter(post => !postIds.includes(post.postId))
                            },
                        },
                    };
                    await triggerChange();
                },
                async roomCleared(room) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [],
                            },
                        },
                    };
                    await triggerChange();
                },
                async usersMuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [
                            ...state.writable.cache.mutedUserIds,
                            ...userIds,
                        ],
                    };
                    await triggerChange();
                },
                async usersUnmuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: state.writable.cache.mutedUserIds
                            .filter(userId => !userIds.includes(userId)),
                    };
                    await triggerChange();
                },
                async unmuteAll() {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [],
                    };
                    await triggerChange();
                },
            };
        })
    });

    function makeChatModel({ chatConnect, getChatMeta }) {
        const changeEvent = pub();
        const state = makeChatState();
        const clientsideApi = makeChatClientside({
            state,
            onChange: changeEvent.publish,
        });
        const statsFetcher = makeStatsFetcher({ state, intervalDuration: 2000 });
        const reconnect = onesie(async function () {
            var _a;
            const connection = (_a = ops.value(state.readable.connectionOp)) !== null && _a !== void 0 ? _a : await ops.operation({
                setOp: op => state.writable.connectionOp = op,
                promise: chatConnect({
                    clientsideApi,
                    handleDisconnect: () => state.writable.connectionOp = ops.none(),
                }),
            });
            const meta = await getChatMeta();
            await connection.serverside.chatServer.updateUserMeta(meta);
            statsFetcher.startInterval(connection);
            return connection;
        });
        async function disconnect() {
            statsFetcher.stopInterval();
            const connection = ops.value(state.readable.connectionOp);
            if (connection) {
                connection.disconnect();
                state.writable.connectionOp = ops.none();
            }
        }
        const roomManagement = setupRoomManagement({
            state,
            reconnect,
            disconnect,
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            subscribeToChange: changeEvent.subscribe,
            get allowance() {
                var _a;
                const access = ops.value(state.readable.accessOp);
                const privileges = (_a = access === null || access === void 0 ? void 0 : access.permit.privileges) !== null && _a !== void 0 ? _a : [];
                return chatAllowance(privileges);
            },
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                const access = ops.value(op);
                await roomManagement.updateAuthSituation(!!access);
                const connection = ops.value(state.readable.connectionOp);
                if (connection) {
                    const meta = await getChatMeta();
                    await connection.serverside.chatServer.updateUserMeta(meta);
                }
            },
            session: roomManagement.getRoomSession,
            disconnect,
            reconnect,
        };
    }

    function subbies() {
        const memory = new Map();
        return {
            subscribe(listener) {
                const symbol = Symbol();
                memory.set(symbol, listener);
                return () => {
                    memory.delete(symbol);
                };
            },
            publish: (context => {
                for (const [, listener] of memory)
                    listener(context);
            }),
            clear() {
                memory.clear();
            },
        };
    }

    function prepareNotesCacheCreator({ propagateChangeToOtherTabs, notesService, getStats, loadStats, getIsLoggedIn, }) {
        async function loadNewNotes(pagination) {
            return notesService.getNewNotes(pagination);
        }
        async function loadOldNotes(pagination) {
            return notesService.getOldNotes(pagination);
        }
        async function markNotesNewOrOld(old, noteIds) {
            await notesService.markNotesNewOrOld({ old, noteIds });
            await loadStats();
            propagateChangeToOtherTabs.publish(undefined);
        }
        return function createNotesCache() {
            const cacheState = snapstate({
                old: false,
                pageNumber: 1,
                pageSize: 10,
                notesOp: ops.none(),
            });
            function resetPagination() {
                cacheState.writable.pageNumber = 1;
                cacheState.writable.pageSize = 10;
            }
            async function fetchAppropriateNotes() {
                if (!getIsLoggedIn()) {
                    cacheState.writable.notesOp = ops.ready([]);
                    return [];
                }
                const { old, pageNumber, pageSize } = cacheState.readable;
                const pagination = {
                    offset: ((pageNumber - 1) * pageSize),
                    limit: pageSize,
                };
                await ops.operation({
                    setOp: op => cacheState.writable.notesOp = op,
                    promise: old
                        ? loadOldNotes(pagination)
                        : loadNewNotes(pagination),
                });
            }
            function totalNumberOfPages() {
                const { old, pageSize } = cacheState.readable;
                const { oldCount, newCount } = getStats();
                const count = old
                    ? oldCount
                    : newCount;
                return Math.ceil(count / pageSize);
            }
            const isPageAvailable = {
                next: () => cacheState.writable.pageNumber < totalNumberOfPages(),
                previous: () => cacheState.writable.pageNumber > 1,
            };
            return {
                subscribe: cacheState.subscribe,
                cacheState: cacheState.readable,
                async loginStatusChanged() {
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get notes() {
                    return ops.value(cacheState.readable.notesOp);
                },
                fetchAppropriateNotes,
                async switchTabNew() {
                    cacheState.writable.old = false;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                async switchTabOld() {
                    cacheState.writable.old = true;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get isNextPageAvailable() {
                    return isPageAvailable.next();
                },
                get isPreviousPageAvailable() {
                    return isPageAvailable.previous();
                },
                async nextPage() {
                    if (isPageAvailable.next()) {
                        cacheState.writable.pageNumber += 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no next page");
                },
                async previousPage() {
                    if (isPageAvailable.previous()) {
                        cacheState.writable.pageNumber -= 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no previous page");
                },
                async markAllNotesOld() {
                    await notesService.markAllNotesOld();
                    await loadStats();
                    propagateChangeToOtherTabs.publish(undefined);
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteOld(noteId) {
                    await markNotesNewOrOld(true, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteNew(noteId) {
                    await markNotesNewOrOld(false, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                get totalPages() {
                    return totalNumberOfPages();
                },
            };
        };
    }

    function makeNotesModel({ notesService }) {
        const state = snapstate({
            accessOp: ops.none(),
            statsOp: ops.none(),
        });
        const accessUpdate = subbies();
        const propagateChangeToOtherTabs = subbies();
        function getIsLoggedIn() {
            var _a;
            return !!((_a = ops.value(state.readable.accessOp)) === null || _a === void 0 ? void 0 : _a.user);
        }
        function getStats() {
            var _a;
            return (_a = ops.value(state.readable.statsOp)) !== null && _a !== void 0 ? _a : {
                newCount: 0,
                oldCount: 0,
            };
        }
        const loadStats = onesie(async function loadStats() {
            return ops.operation({
                promise: notesService.getNotesStats(),
                setOp: op => state.writable.statsOp = op,
            });
        });
        let initialized = false;
        async function initialize() {
            if (!initialized) {
                initialized = true;
                if (getIsLoggedIn()) {
                    return loadStats();
                }
            }
        }
        async function loadIfInitialized() {
            if (initialized)
                return loadStats();
        }
        return {
            initialize,
            state: state.readable,
            stateSubscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                if (getIsLoggedIn())
                    await loadIfInitialized();
                accessUpdate.publish(ops.value(op));
            },
            get isLoggedIn() {
                return getIsLoggedIn();
            },
            get stats() {
                return getStats();
            },
            propagateChangeToOtherTabs,
            loadStats,
            overwriteStatsOp(op) {
                state.writable.statsOp = op;
            },
            createNotesCacheDetails: (() => {
                const create = prepareNotesCacheCreator({
                    notesService,
                    propagateChangeToOtherTabs,
                    getStats,
                    loadStats,
                    getIsLoggedIn,
                });
                return () => {
                    const cache = create();
                    return {
                        cache,
                        setup: () => accessUpdate.subscribe(() => cache.loginStatusChanged()),
                    };
                };
            })(),
        };
    }

    function makeDacastModel({ dacastService }) {
        const linkChange = subbies();
        const state = snapstate({
            accessOp: ops.none(),
            linkedAccountOp: ops.none(),
        });
        let alreadyInitialized = false;
        const isModerator = () => {
            const access = ops.value(state.readable.accessOp);
            return access && access.permit.privileges.includes(videoPrivileges["moderate videos"]);
        };
        async function loadLinkedAccount() {
            return ops.operation({
                promise: dacastService.getLink(),
                setOp: op => state.writable.linkedAccountOp = op,
            });
        }
        async function refresh() {
            if (alreadyInitialized && isModerator()) {
                await loadLinkedAccount();
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            onLinkChange: linkChange.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.linkedAccountOp = ops.none();
                await refresh();
            },
            async initialize() {
                if (!alreadyInitialized) {
                    alreadyInitialized = true;
                    await refresh();
                }
            },
            get linkedAccount() {
                return ops.value(state.readable.linkedAccountOp);
            },
            async linkAccount({ apiKey }) {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.setLink({ apiKey })
                        .then(link => {
                        linkChange.publish(link);
                        return link;
                    }),
                });
            },
            async unlinkAccount() {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.clearLink()
                        .then(() => linkChange.publish(undefined)),
                });
            },
        };
    }

    function makeContentModel({ contentService, }) {
        const state = snapstate({
            accessOp: ops.none(),
            catalogOp: ops.none(),
            viewsOp: ops.none(),
            privilegesOp: ops.none(),
            showsOp: ops.none(),
        });
        const activeShowLabels = new Set();
        const currentlyLoadingShows = new Set();
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initialized = false;
        async function loadModerationData() {
            initialized = true;
            const access = getAccess();
            const isModerator = access && access.permit
                .privileges.includes(videoPrivileges["moderate videos"]);
            if (isModerator) {
                await ops.operation({
                    promise: contentService.fetchModerationData(),
                    setOp: op => {
                        var _a, _b, _c;
                        const data = ops.value(op);
                        state.writable.catalogOp = ops.replaceValue(op, (_a = data === null || data === void 0 ? void 0 : data.catalog) !== null && _a !== void 0 ? _a : []);
                        state.writable.viewsOp = ops.replaceValue(op, (_b = data === null || data === void 0 ? void 0 : data.views) !== null && _b !== void 0 ? _b : []);
                        state.writable.privilegesOp = ops.replaceValue(op, (_c = data === null || data === void 0 ? void 0 : data.privileges) !== null && _c !== void 0 ? _c : []);
                    },
                });
            }
        }
        async function loadShow(label) {
            var _a;
            initialized = true;
            activeShowLabels.add(label);
            if (!getAccess() || currentlyLoadingShows.has(label))
                return undefined;
            currentlyLoadingShows.add(label);
            const oldShows = (_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [];
            let updatedShow;
            await ops.operation({
                setOp: op => state.writable.showsOp = op,
                promise: contentService.getShows({ labels: [label] })
                    .then(shows => shows[0])
                    .then(show => updatedShow = show)
                    .then(show => [
                    ...oldShows.filter(s => s.label !== label),
                    show,
                    // ...(show ? [show] : [{label, details: undefined}]),
                ]),
            });
            currentlyLoadingShows.delete(label);
            return updatedShow;
        }
        async function refreshShows() {
            initialized = true;
            if (!getAccess())
                return undefined;
            const labels = Array.from(activeShowLabels)
                .filter(label => !currentlyLoadingShows.has(label));
            if (labels.length) {
                for (const label of labels)
                    currentlyLoadingShows.add(label);
                await ops.operation({
                    setOp: op => state.writable.showsOp = op,
                    promise: contentService.getShows({ labels })
                        .then(shows => shows.filter(s => !!s))
                });
                for (const label of labels)
                    currentlyLoadingShows.delete(label);
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.catalogOp = ops.none();
                state.writable.viewsOp = ops.none();
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async onVideoHostingUpdate() {
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async initializeForModerationData() {
                if (!initialized) {
                    await loadModerationData();
                }
            },
            async initializeForVideo(label) {
                if (!initialized)
                    await loadModerationData();
                await loadShow(label);
            },
            get allowance() {
                const access = ops.value(state.readable.accessOp);
                const can = (p) => access
                    ? access.permit.privileges.includes(videoPrivileges[p])
                    : false;
                return {
                    canModerateVideos: can("moderate videos"),
                    canViewAllVideos: can("moderate videos") || can("view all videos"),
                };
            },
            get catalog() {
                var _a;
                return (_a = ops.value(state.readable.catalogOp)) !== null && _a !== void 0 ? _a : [];
            },
            get views() {
                var _a;
                return (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
            },
            get privileges() {
                var _a;
                return (_a = ops.value(state.readable.privilegesOp)) !== null && _a !== void 0 ? _a : [];
            },
            get shows() {
                var _a;
                return (_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [];
            },
            getView(label) {
                var _a;
                return ((_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [])
                    .find(view => view.label === label);
            },
            getPrivilege(id) {
                var _a;
                return ((_a = ops.value(state.readable.privilegesOp)) !== null && _a !== void 0 ? _a : [])
                    .find(p => p.privilegeId === id);
            },
            getShow(label) {
                var _a;
                return ((_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [])
                    .find(show => show.label === label);
            },
            async setView(view) {
                var _a;
                const oldViews = (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService
                        .writeView(view)
                        .then(() => [
                        ...oldViews.filter(v => v.label !== view.label),
                        view,
                    ]),
                });
                await loadShow(view.label);
            },
            async deleteView(label) {
                var _a, _b;
                const oldViews = (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService
                        .deleteView({ label })
                        .then(() => oldViews.filter(v => v.label !== label)),
                });
                const oldShows = (_b = ops.value(state.readable.showsOp)) !== null && _b !== void 0 ? _b : [];
                state.writable.showsOp = ops.replaceValue(state.readable.showsOp, oldShows.filter(s => s.label !== label));
            },
        };
    }

    function makeVideoModels(options) {
        const dacastModel = makeDacastModel(options);
        const contentModel = makeContentModel(options);
        dacastModel.onLinkChange(contentModel.onVideoHostingUpdate);
        return {
            dacastModel,
            contentModel,
            updateAccessOp(accessOp) {
                dacastModel.updateAccessOp(accessOp);
                contentModel.updateAccessOp(accessOp);
            },
        };
    }

    function makeExampleModel({ getAccessOp }) {
        const state = snapstate({
            accessOp: getAccessOp(),
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            updateAccessOp: (op) => {
                state.writable.accessOp = op;
            },
        };
    }

    function makeAppsModel({ appService, appEditService, getValidAccess, }) {
        const { readable, writable, subscribe } = snapstate({
            active: false,
            appRecords: ops.none(),
            addingNewApp: ops.none(),
        });
        const actions = {
            setAppRecords(op) {
                var _a;
                const appList = (_a = ops.value(op)) !== null && _a !== void 0 ? _a : [];
                let records = {};
                for (const app of appList)
                    records[app.appId] = ops.ready(app);
                writable.appRecords = ops.replaceValue(op, records);
            },
            setIndividualAppRecord(appId, op) {
                var _a;
                if (ops.isLoading(writable.appRecords))
                    throw new Error("cannot set individual app while apps are loading");
                const apps = (_a = ops.value(writable.appRecords)) !== null && _a !== void 0 ? _a : {};
                writable.appRecords = ops.ready({ ...apps, [appId]: op });
            },
            deleteIndividualAppRecord(appId) {
                if (ops.isReady(writable.appRecords)) {
                    const existingRecords = ops.value(writable.appRecords);
                    const records = {};
                    for (const [key, value] of Object.entries(existingRecords)) {
                        if (key !== appId)
                            records[key] = value;
                    }
                    writable.appRecords = ops.ready(records);
                }
                else
                    throw new Error("cannot delete individual app while apps are loading");
            },
        };
        async function getUserId() {
            var _a;
            const access = await getValidAccess();
            return (_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId;
        }
        async function loadApps() {
            writable.active = true;
            const appsPromise = ops.operation({
                promise: (async () => {
                    const userId = await getUserId();
                    return userId
                        ? appService.listApps({ ownerUserId: userId })
                        : [];
                })(),
                setOp: op => actions.setAppRecords(op),
            });
            // actions.setLoadingPromise(appsPromise.then(() => undefined))
            return appsPromise;
        }
        async function registerApp(appDraft) {
            const userId = await getUserId();
            const result = await ops.operation({
                errorReason: "failed to register app",
                promise: (async () => {
                    const result = await appService.registerApp({
                        appDraft,
                        ownerUserId: userId,
                    });
                    await appEditService.assignPlatformUserAsAdmin({
                        appId: result.appId,
                        platformUserId: userId,
                    });
                    return result;
                })(),
                setOp: op => {
                    writable.addingNewApp = ops.replaceValue(op, null);
                    if (ops.isReady(op)) {
                        const newApp = { ...ops.value(op), ...appDraft };
                        actions.setIndividualAppRecord(newApp.appId, ops.ready(newApp));
                    }
                },
            });
            return result;
        }
        async function updateApp(appId, appDraft) {
            const records = ops.value(writable.appRecords);
            if (!records)
                throw new Error("cannot update app while loading records");
            const existingApp = ops.value(records[appId]);
            if (!existingApp)
                throw new Error("cannot update app not present in records");
            return ops.operation({
                promise: appEditService.updateApp({ appId, appDraft }),
                setOp: op => actions.setIndividualAppRecord(appId, ops.replaceValue(op, { ...existingApp, ...appDraft })),
            });
        }
        function getApp(appId) {
            const records = ops.value(writable.appRecords);
            return records
                ? ops.value(records[appId])
                : undefined;
        }
        async function deleteApp(appId) {
            await ops.operation({
                promise: appEditService.deleteApp({ appId }),
                setOp: op => {
                    actions.setIndividualAppRecord(appId, ops.replaceValue(op, getApp(appId)));
                },
            });
            actions.deleteIndividualAppRecord(appId);
        }
        return {
            state: readable,
            subscribe,
            appEditService,
            getApp,
            loadApps,
            deleteApp,
            updateApp,
            registerApp,
            async updateAccessOp(op) {
                if (readable.active)
                    await loadApps();
            },
        };
    }

    function merge(newItems, oldItems, compare) {
        const result = [...newItems];
        for (const oldItem of oldItems) {
            const included = !!result.find(newItem => compare(newItem, oldItem));
            if (!included)
                result.push(oldItem);
        }
        return result;
    }

    function makeQuestionsModelHappy() {
        const adminstate = snapstate({
            access: undefined,
            users: [],
            questions: [],
            boardOps: {},
            postingOp: ops.ready(undefined),
        });
        const state = adminstate.writable;
        const actions = {
            setAccess(access) {
                state.access = access;
            },
            setBoardOp(board, op) {
                state.boardOps = { ...state.boardOps, [board]: op };
            },
            setPostingOp(op) {
                state.postingOp = op;
            },
            addUsers(newUsers) {
                state.users = [...merge(newUsers.filter(u => !!u), state.users, (a, b) => a.userId === b.userId)];
            },
            addQuestions(newQuestions) {
                state.questions = [...merge(newQuestions, state.questions, (a, b) => a.questionId === b.questionId)];
            },
            addAnswer(newAnswer) {
                const question = state.questions
                    .find(q => q.questionId === newAnswer.questionId);
                if (!question)
                    throw new Error(`can't find question to add answer, question id: "${newAnswer.questionId}"`);
                const newQuestion = {
                    ...question,
                    answers: [...question.answers, newAnswer],
                };
                state.questions = [...merge([newQuestion], state.questions, (a, b) => a.questionId === b.questionId)];
            },
            setQuestionLike(questionId, like) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        liked: like,
                        likes: question.liked === like
                            ? question.likes
                            : like
                                ? question.likes + 1
                                : question.likes - 1
                    }
                    : { ...question });
            },
            setAnswerLike(questionId, answerId, status) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? {
                                ...answer,
                                liked: status,
                                likes: answer.liked === status
                                    ? answer.likes
                                    : status
                                        ? answer.likes + 1
                                        : answer.likes - 1
                            }
                            : { ...answer })
                    }
                    : { ...question });
            },
            setAnswerReport(questionId, answerId, status) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? {
                                ...answer,
                                reported: status,
                                reports: answer.reported === status
                                    ? answer.reports
                                    : status
                                        ? answer.reports + 1
                                        : answer.reports - 1
                            }
                            : { ...answer })
                    }
                    : { ...question });
            },
            setQuestionReport(questionId, report) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        reported: report,
                        reports: question.reported === report
                            ? question.reports
                            : report
                                ? question.reports + 1
                                : question.reports - 1
                    }
                    : { ...question });
            },
            setQuestionArchive(questionId, archive) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? { ...question, archive }
                    : { ...question });
            },
            setAnswerArchive(questionId, answerId, archive) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? { ...answer, archive }
                            : { ...answer })
                    }
                    : { ...question });
            },
        };
        return {
            actions,
            state: adminstate.readable,
            subscribe: adminstate.subscribe,
        };
    }

    function prepareQuestionsBoardModelGetter({ state, actions, questionsPostingService, questionsAnsweringService, questionsModerationService, getAccess, loadQuestionsForBoard, }) {
        return (board) => ({
            getPermissions() {
                const { access } = state;
                return {
                    "read questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["read questions"])
                        : false,
                    "post questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["post questions"]) && !access.permit.privileges.includes(appPermissions.privileges["banned"])
                        : false,
                    "moderate questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["moderate questions"])
                        : false,
                    "answer questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["answer questions"])
                        : false,
                    "like questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["like questions"])
                        : false,
                    "report questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["report questions"])
                        : false,
                };
            },
            getBoardName() {
                return board;
            },
            getAccess() {
                return state.access;
            },
            getBoardOp() {
                return state.boardOps[board];
            },
            getPostingOp() {
                return state.postingOp;
            },
            getQuestions() {
                return state.questions
                    .filter(question => question.board === board)
                    .filter(question => question.archive === false)
                    .map(question => ({
                    ...question,
                    answers: question.answers
                        .filter(answer => answer.archive === false)
                }));
            },
            getUser(userId) {
                return state.users.find(user => user.userId === userId);
            },
            async loadQuestions() {
                await loadQuestionsForBoard(board);
            },
            async postQuestion({ content }) {
                const question = await ops.operation({
                    promise: questionsPostingService.postQuestion({
                        questionDraft: { board, content }
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addQuestions([question]);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return question;
            },
            async postAnswer(questionId, answerDraft) {
                const answer = await ops.operation({
                    promise: questionsAnsweringService.postAnswer({
                        questionId,
                        answerDraft,
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addAnswer(answer);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return answer;
            },
            async likeQuestion(questionId, like) {
                await questionsPostingService.likeQuestion({
                    like: like,
                    questionId,
                });
                actions.setQuestionLike(questionId, like);
            },
            async likeAnswer(questionId, answerId, like) {
                await questionsAnsweringService.likeAnswer({ answerId, like });
                actions.setAnswerLike(questionId, answerId, like);
            },
            async reportQuestion(questionId, report) {
                await questionsPostingService.reportQuestion({
                    report,
                    questionId,
                });
                actions.setQuestionReport(questionId, report);
            },
            async reportAnswer(questionId, answerId, report) {
                await questionsAnsweringService.reportAnswer({ answerId, report });
                actions.setAnswerReport(questionId, answerId, report);
            },
            async archiveQuestion(questionId, archive) {
                await questionsPostingService.archiveQuestion({
                    archive,
                    questionId,
                });
                actions.setQuestionArchive(questionId, archive);
            },
            async archiveAnswer(questionId, answerId, archive) {
                await questionsAnsweringService.archiveAnswer({ answerId, archive });
                actions.setAnswerArchive(questionId, answerId, archive);
            },
            async archiveBoard() {
                await questionsModerationService.archiveBoard({ board });
                for (const question of state.questions)
                    actions.setQuestionArchive(question.questionId, true);
            },
        });
    }

    function makeQuestionsModel(options) {
        const { questionsReadingService } = options;
        const { state, actions, subscribe } = makeQuestionsModelHappy();
        async function loadQuestionsForBoard(board) {
            await ops.operation({
                promise: (async () => {
                    const { users, questions } = await questionsReadingService
                        .fetchQuestions({ board });
                    actions.addUsers(users);
                    actions.addQuestions(questions);
                })(),
                setOp: op => actions.setBoardOp(board, op),
            });
        }
        async function refreshAllBoards() {
            await Promise.all(Object.keys(state.boardOps).map(loadQuestionsForBoard));
        }
        return {
            subscribe,
            makeBoardModel: prepareQuestionsBoardModelGetter({
                state,
                actions,
                loadQuestionsForBoard,
                ...options,
            }),
            accessChange: (access) => {
                actions.setAccess(access);
                if (access === null || access === void 0 ? void 0 : access.user)
                    actions.addUsers([access.user]);
                refreshAllBoards();
            },
        };
    }

    var _a$1;
    const _structured_clone = ((_a$1 = (typeof window !== "undefined" ? window : global)) === null || _a$1 === void 0 ? void 0 : _a$1.structuredClone);
    const clone = (typeof _structured_clone === "function")
        ? x => _structured_clone(x)
        : x => JSON.parse(JSON.stringify(x));

    class AccessError extends Error {
    }
    class AccessLoginExpiredError extends AccessError {
        constructor() {
            super("login token has expired");
        }
    }

    function makeAccessModel({ authMediator, loginService }) {
        let accessOp = ops.none();
        const accessOpEvent = pub();
        async function setAccessOp(op) {
            accessOp = op;
            await accessOpEvent.publish(op);
        }
        authMediator.subscribeToAccessChange(async (access) => setAccessOp(ops.ready(access)));
        async function accessOperation(promise) {
            return ops.operation({
                promise,
                setOp: setAccessOp,
            });
        }
        const loginFacilities = {
            async useExistingLogin() {
                await accessOperation(authMediator.initialize());
            },
            async sendLoginLink(email) {
                return loginService.sendLoginLink({ email });
            },
            async login(loginToken) {
                try {
                    if (isTokenValid(loginToken))
                        await accessOperation(loginService
                            .authenticateViaLoginToken({ loginToken })
                            .then(tokens => authMediator.login(tokens)));
                    else
                        throw new AccessLoginExpiredError();
                }
                catch (error) {
                    console.error(error);
                    await setAccessOp(ops.none());
                    await accessOperation(authMediator.initialize());
                    throw error;
                }
            },
            async logout() {
                await accessOperation(authMediator.logout());
                await ops.operation({
                    promise: authMediator.logout(),
                    setOp: setAccessOp,
                });
            },
            async reauthorize() {
                await accessOperation(authMediator.reauthorize());
            },
        };
        return {
            ...loginFacilities,
            subscribe: accessOpEvent.subscribe,
            getAccessOp() {
                return clone(accessOp);
            },
            getAccess() {
                return ops.value(clone(accessOp));
            },
            getValidAccess() {
                return authMediator.getValidAccess();
            },
        };
    }

    function makePersonalModel({ personalService, getAccessOp, reauthorize, }) {
        const { readable, writable, track, subscribe } = snapstate({
            accessOp: getAccessOp(),
            submitDraftOp: ops.ready(undefined),
        });
        return {
            track,
            subscribe,
            readable,
            async saveProfile(profileDraft) {
                await ops.operation({
                    promise: (async () => {
                        const { user: { userId } } = ops.value(readable.accessOp);
                        await personalService.setProfile({ userId, profileDraft });
                        await reauthorize();
                    })(),
                    errorReason: "error saving profile",
                    setOp(op) { writable.submitDraftOp = op; },
                });
            },
            updateAccessOp(op) {
                writable.accessOp = op;
            },
        };
    }

    function makeAllowanceChecker(access, privileges) {
        const allowed = {};
        for (const [key, privilegeId] of Object.entries(privileges))
            allowed[key] = access
                ? access.permit.privileges.includes(privilegeId)
                : false;
        return (privilege) => allowed[privilege];
    }

    function makeAdministrativeModel({ roleAssignmentService, reauthorize, }) {
        const state = snapstate({
            accessOp: ops.none(),
            permissionsOp: ops.none(),
        });
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initializedInDom = false;
        function allowanceChecker() {
            return makeAllowanceChecker(getAccess(), appPermissions.privileges);
        }
        async function loadPermissions() {
            if (initializedInDom && allowanceChecker()("administrate user roles"))
                await ops.operation({
                    promise: roleAssignmentService.fetchPermissions(),
                    setOp: op => state.writable.permissionsOp = op,
                });
        }
        async function initialize() {
            initializedInDom = true;
            await loadPermissions();
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            getAccess,
            initialize,
            get isAllowed() {
                return allowanceChecker();
            },
            reauthorize,
            searchUsers: roleAssignmentService.searchUsers,
            assignRoleToUser: roleAssignmentService.assignRoleToUser,
            revokeRoleFromUser: roleAssignmentService.revokeRoleFromUser,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                loadPermissions();
            },
        };
    }

    function makePermissionsModel({ permissionsService, reauthorize, }) {
        const { readable, writable, subscribe, track } = snapstate({
            active: false,
            accessOp: ops.none(),
            permissionsDisplay: ops.none(),
        });
        function getAccess() {
            return ops.value(readable.accessOp);
        }
        function sortPermissions(permissions) {
            const softPrivileges = [];
            const hardPrivileges = [];
            for (const privilege of permissions.privileges) {
                if (privilege.hard)
                    hardPrivileges.push(privilege);
                else
                    softPrivileges.push(privilege);
            }
            softPrivileges.sort((a, b) => b.time - a.time);
            return {
                ...permissions,
                privileges: [...softPrivileges, ...hardPrivileges],
            };
        }
        async function reload() {
            await ops.operation({
                promise: Promise.resolve()
                    .then(async () => getUserCanCustomizePermissions()
                    ? permissionsService.fetchPermissions().then(sortPermissions)
                    : undefined),
                setOp: op => writable.permissionsDisplay = op,
            });
        }
        function getUserCanCustomizePermissions() {
            const access = getAccess();
            return (access === null || access === void 0 ? void 0 : access.user)
                ? access.permit.privileges.includes(appPermissions.privileges["customize permissions"])
                : false;
        }
        async function initialize() {
            writable.active = true;
            if (getUserCanCustomizePermissions())
                await reload();
        }
        function reloadAfter(func) {
            return (async (...args) => {
                const result = await func(...args);
                await reload();
                await reauthorize();
                return result;
            });
        }
        return {
            readable,
            subscribe,
            track,
            getAccess,
            initialize,
            getUserCanCustomizePermissions,
            createRole: reloadAfter(permissionsService.createRole),
            deleteRole: reloadAfter(permissionsService.deleteRole),
            assignPrivilege: reloadAfter(permissionsService.assignPrivilege),
            unassignPrivilege: reloadAfter(permissionsService.unassignPrivilege),
            deletePrivilege: reloadAfter(permissionsService.deletePrivilege),
            createPrivilege: reloadAfter(permissionsService.createPrivilege),
            async updateAccessOp(op) {
                writable.accessOp = op;
                const access = getAccess();
                if ((access === null || access === void 0 ? void 0 : access.user) && writable.active)
                    await reload();
            },
        };
    }

    var StripeConnectStatus;
    (function (StripeConnectStatus) {
        StripeConnectStatus[StripeConnectStatus["Unlinked"] = 0] = "Unlinked";
        StripeConnectStatus[StripeConnectStatus["Incomplete"] = 1] = "Incomplete";
        StripeConnectStatus[StripeConnectStatus["Paused"] = 2] = "Paused";
        StripeConnectStatus[StripeConnectStatus["Ready"] = 3] = "Ready";
    })(StripeConnectStatus || (StripeConnectStatus = {}));
    var SubscriptionStatus;
    (function (SubscriptionStatus) {
        SubscriptionStatus[SubscriptionStatus["Unsubscribed"] = 0] = "Unsubscribed";
        SubscriptionStatus[SubscriptionStatus["Active"] = 1] = "Active";
        SubscriptionStatus[SubscriptionStatus["Unpaid"] = 2] = "Unpaid";
        SubscriptionStatus[SubscriptionStatus["Cancelled"] = 3] = "Cancelled";
    })(SubscriptionStatus || (SubscriptionStatus = {}));
    var PurchaseScenario;
    (function (PurchaseScenario) {
        PurchaseScenario[PurchaseScenario["Update"] = 0] = "Update";
        PurchaseScenario[PurchaseScenario["UsePaymentMethod"] = 1] = "UsePaymentMethod";
        PurchaseScenario[PurchaseScenario["CheckoutPopup"] = 2] = "CheckoutPopup";
    })(PurchaseScenario || (PurchaseScenario = {}));

    function makeStoreStateSystem() {
        const snap = snapstate({
            user: {
                accessOp: ops.none(),
            },
            stripeConnect: {
                connectStatusOp: ops.none(),
                connectDetailsOp: ops.none(),
            },
            subscriptions: {
                subscriptionPlansOp: ops.none(),
                mySubscriptionDetailsOp: ops.none(),
            },
            billing: {
                paymentMethodOp: ops.none(),
            },
        });
        const state = snap.readable;
        const allowance = (() => {
            const has = (key) => {
                var _a, _b;
                const privileges = (_b = (_a = ops.value(state.user.accessOp)) === null || _a === void 0 ? void 0 : _a.permit.privileges) !== null && _b !== void 0 ? _b : [];
                return privileges.includes(storePrivileges[key]);
            };
            return {
                get manageStore() { return has("manage store"); },
                get connectStripeAccount() { return has("control stripe account"); },
                get giveAwayFreebies() { return has("give away freebies"); },
            };
        })();
        return {
            snap,
            state,
            allowance,
            get: {
                is: {
                    get storeActive() {
                        return ops.value(snap.state.stripeConnect.connectStatusOp)
                            === StripeConnectStatus.Ready;
                    },
                    get userLoggedIn() {
                        var _a;
                        return !!((_a = ops.value(snap.state.user.accessOp)) === null || _a === void 0 ? void 0 : _a.user);
                    },
                },
                user: {
                    get access() { return ops.value(state.user.accessOp); },
                },
                connect: {
                    get status() { return ops.value(state.stripeConnect.connectStatusOp); },
                    get details() { return ops.value(state.stripeConnect.connectDetailsOp); },
                },
                subscriptions: {
                    get plans() { return ops.value(state.subscriptions.subscriptionPlansOp); },
                    get mySubscriptionDetails() { return ops.value(state.subscriptions.mySubscriptionDetailsOp); },
                },
                billing: {
                    get paymentMethod() { return ops.value(state.billing.paymentMethodOp); },
                }
            },
        };
    }

    function makeConnectSubmodel({ stripePopups, services, stateSystem, reloadStore, }) {
        const state = stateSystem.snap.writable;
        const { allowance } = stateSystem;
        async function load() {
            state.stripeConnect.connectStatusOp = ops.none();
            state.stripeConnect.connectDetailsOp = ops.none();
            if (allowance.connectStripeAccount) {
                await ops.operation({
                    promise: services.connect.loadConnectDetails(),
                    setOp: op => {
                        var _a, _b;
                        state.stripeConnect.connectStatusOp = ops.replaceValue(op, (_a = ops.value(op)) === null || _a === void 0 ? void 0 : _a.connectStatus);
                        state.stripeConnect.connectDetailsOp = ops.replaceValue(op, (_b = ops.value(op)) === null || _b === void 0 ? void 0 : _b.connectDetails);
                    },
                });
            }
            else {
                await ops.operation({
                    promise: services.connect.loadConnectStatus(),
                    setOp: op => state.stripeConnect.connectStatusOp = op,
                });
            }
        }
        return {
            load,
            get isOnboardingNeeded() {
                var _a;
                const { get } = stateSystem;
                return get.connect.status === StripeConnectStatus.Unlinked
                    || !((_a = get.connect.details) === null || _a === void 0 ? void 0 : _a.details_submitted);
            },
            get isAllowedToOnboard() {
                var _a;
                const { get } = stateSystem;
                const access = get.user.access;
                if (!(access === null || access === void 0 ? void 0 : access.user))
                    return false;
                if (!access.permit.privileges.includes(storePrivileges["control stripe account"]))
                    return false;
                return get.connect.status === StripeConnectStatus.Unlinked
                    ? true
                    : access.user.userId === ((_a = get.connect.details) === null || _a === void 0 ? void 0 : _a.userId);
            },
            async stripeAccountOnboarding() {
                var _a;
                const popupInfo = await services
                    .connect
                    .generatePopupForStripeAccountOnboarding();
                const result = await stripePopups
                    .connect(popupInfo);
                if (((_a = result.details) === null || _a === void 0 ? void 0 : _a.status) === "return")
                    await reloadStore();
            },
            async stripeLogin() {
                const connectStatus = ops.value(state.stripeConnect.connectStatusOp);
                const connectDetails = ops.value(state.stripeConnect.connectDetailsOp);
                if (connectStatus === StripeConnectStatus.Unlinked)
                    throw new Error("no stripe account to generate login link for");
                if (!connectDetails)
                    throw new Error("stripe connect details missing for login");
                const { stripeLoginLink, popupId } = await services.connect.generateStripeLoginLink();
                const { stripeAccountId } = connectDetails;
                await stripePopups.login({ stripeAccountId, stripeLoginLink, popupId });
                await reloadStore();
            },
            async pause() {
                await services.connect.pause();
                state.stripeConnect.connectStatusOp = ops.ready(StripeConnectStatus.Paused);
                if (allowance.manageStore)
                    state.stripeConnect.connectDetailsOp = ops.ready({
                        ...ops.value(state.stripeConnect.connectDetailsOp),
                        paused: true,
                    });
            },
            async resume() {
                await services.connect.resume();
                state.stripeConnect.connectStatusOp = ops.ready(StripeConnectStatus.Ready);
                if (allowance.manageStore)
                    state.stripeConnect.connectDetailsOp = ops.ready({
                        ...ops.value(state.stripeConnect.connectDetailsOp),
                        paused: false,
                    });
            },
        };
    }

    function makeBillingSubmodel({ stripePopups, services, stateSystem, reloadStore, }) {
        const state = stateSystem.snap.writable;
        const { get, allowance } = stateSystem;
        async function load() {
            state.billing.paymentMethodOp = ops.none();
            if (get.is.storeActive && get.is.userLoggedIn) {
                await ops.operation({
                    promise: services.billing.getDefaultPaymentMethod(),
                    setOp: op => state.billing.paymentMethodOp = op,
                });
            }
        }
        async function customerPortal() {
            const { popupId, stripeSessionUrl, customer, stripeAccountId } = await services
                .billing
                .generateCustomerPortalLink();
            await stripePopups.openStoreCustomerPortal({
                popupId, customer, stripeSessionUrl, stripeAccountId
            });
            await reloadStore();
        }
        return {
            load,
            allowance,
            customerPortal,
        };
    }

    function makeSubscriptionsSubmodel({ services, stateSystem, stripePopups, reauthorize, }) {
        const state = stateSystem.snap.writable;
        const { get } = stateSystem;
        async function load() {
            state
                .subscriptions
                .subscriptionPlansOp = ops.none();
            state
                .subscriptions
                .mySubscriptionDetailsOp = ops.none();
            if (get.is.storeActive) {
                await ops.operation({
                    setOp: op => state
                        .subscriptions
                        .subscriptionPlansOp = op,
                    promise: services
                        .subscriptions
                        .listing
                        .listPlans(),
                });
                if (get.is.userLoggedIn) {
                    await ops.operation({
                        setOp: op => state
                            .subscriptions
                            .mySubscriptionDetailsOp = op,
                        promise: services
                            .subscriptions
                            .shopping
                            .fetchDetailsAboutMySubscriptions(),
                    });
                }
            }
        }
        const actions = {
            async purchase({ stripePriceId, showLoadingSpinner }) {
                if (showLoadingSpinner)
                    state
                        .subscriptions
                        .mySubscriptionDetailsOp = ops.loading();
                const { checkoutDetails } = await services
                    .subscriptions
                    .shopping
                    .buy(stripePriceId);
                if (checkoutDetails)
                    await stripePopups.checkoutSubscription(checkoutDetails);
            },
            async cancel(tierId) {
                state
                    .subscriptions
                    .mySubscriptionDetailsOp = ops.loading();
                await services
                    .subscriptions
                    .shopping
                    .cancel(tierId);
            },
            async uncancel(tierId) {
                state
                    .subscriptions
                    .mySubscriptionDetailsOp = ops.loading();
                await services
                    .subscriptions
                    .shopping
                    .uncancel(tierId);
            },
        };
        const reauthorizeAndRefreshAfter = objectMap$1(actions, fun => async (...args) => {
            await fun(...args);
            await reauthorize();
        });
        function getPlans() {
            var _a;
            return (_a = ops.value(unproxy(state.subscriptions.subscriptionPlansOp))) !== null && _a !== void 0 ? _a : [];
        }
        return {
            load,
            ...reauthorizeAndRefreshAfter,
            async addPlan(options) {
                const newPlan = await services
                    .subscriptions
                    .planning
                    .addPlan(options);
                const oldPlans = getPlans();
                state
                    .subscriptions
                    .subscriptionPlansOp = ops.replaceValue(state.subscriptions.subscriptionPlansOp, [...oldPlans, newPlan]);
                return newPlan;
            },
            async addTier(options) {
                const plans = getPlans();
                const tier = await services
                    .subscriptions
                    .planning
                    .addTier(options);
                const plan = plans.find(plan => plan.planId === options.planId);
                plan.tiers = [...plan.tiers, tier];
                state
                    .subscriptions
                    .subscriptionPlansOp = ops.ready(plans);
                return tier;
            },
            async editPlan({ planId, label, archived }) {
                await services
                    .subscriptions
                    .planning
                    .editPlan({ planId, label, archived });
                const plans = getPlans();
                const plan = plans.find(plan => plan.planId === planId);
                plan.label = label;
                plan.archived = archived;
                state
                    .subscriptions
                    .subscriptionPlansOp = ops.ready(plans);
            },
            async editTier({ planId, tierId, label, active, pricing }) {
                const newTier = await services
                    .subscriptions
                    .planning
                    .editTier({
                    tierId,
                    active,
                    label,
                    pricing,
                });
                const plans = getPlans();
                const plan = plans.find(plan => plan.planId === planId);
                plan.tiers = plan.tiers.map(function swapTierInPlace(existingTier) {
                    const isEditedTier = (existingTier.tierId === newTier.tierId);
                    return isEditedTier
                        ? newTier
                        : existingTier;
                });
                state
                    .subscriptions
                    .subscriptionPlansOp = ops.ready(plans);
            },
        };
    }

    function setupLogicForInitAndLoading({ state, loadStore, }) {
        async function load() {
            if (ops.isReady(state.user.accessOp))
                await loadStore();
        }
        let initialized = false;
        async function initialize() {
            if (!initialized) {
                initialized = true;
                await load();
            }
        }
        async function refresh() {
            if (initialized) {
                await load();
            }
        }
        return { load, initialize, refresh };
    }

    function makeStoreModel(options) {
        const stateSystem = makeStoreStateSystem();
        const submodelOptions = {
            ...options,
            stateSystem,
            reloadStore: async () => initLogic.load(),
        };
        const submodels = {
            subscriptions: makeSubscriptionsSubmodel(submodelOptions),
            billing: makeBillingSubmodel(submodelOptions),
            connect: makeConnectSubmodel(submodelOptions),
        };
        const initLogic = setupLogicForInitAndLoading({
            state: stateSystem.state,
            loadStore: async () => {
                await submodels.connect.load();
                await Promise.all([
                    submodels.billing.load(),
                    submodels.subscriptions.load(),
                ]);
            }
        });
        return {
            ...stateSystem,
            ...submodels,
            ...initLogic,
            async updateAccessOp(op) {
                stateSystem.snap.state.user.accessOp = op;
                await initLogic.refresh();
            },
        };
    }

    async function assembleModels({ appId, remote, storage, authMediator, stripePopups, chatConnect, }) {
        const accessModel = makeAccessModel({
            authMediator,
            loginService: remote.auth.users.loginService,
        });
        const { getAccessOp, getAccess, getValidAccess, reauthorize } = accessModel;
        const exampleModel = makeExampleModel({ getAccessOp });
        const personalModel = makePersonalModel({
            personalService: remote.auth.users.personalService,
            getAccessOp,
            reauthorize,
        });
        const appsModel = makeAppsModel({
            appService: remote.auth.apps.appService,
            appEditService: remote.auth.apps.appEditService,
            getValidAccess,
        });
        const permissionsModel = makePermissionsModel({
            permissionsService: remote.auth.permissions.permissionsService,
            reauthorize,
        });
        const videoModels = makeVideoModels({
            dacastService: remote.videos.dacastService,
            contentService: remote.videos.contentService,
        });
        const chatModel = makeChatModel({
            chatConnect,
            getChatMeta: async () => ({
                accessToken: await authMediator.getValidAccessToken(),
            }),
        });
        const notesModel = makeNotesModel({
            notesService: remote.notes.notesService,
        });
        const storeModel = makeStoreModel({
            stripePopups,
            services: remote.store,
            reauthorize,
        });
        const administrativeModel = makeAdministrativeModel({
            roleAssignmentService: remote.administrative.roleAssignmentService,
            reauthorize: () => accessModel.reauthorize(),
        });
        const questionsModel = makeQuestionsModel({
            ...remote.questions,
            getAccess: getAccessOp,
        });
        accessModel.subscribe(async (accessOp) => {
            const access = getAccess();
            await Promise.all([
                exampleModel.updateAccessOp(accessOp),
                personalModel.updateAccessOp(accessOp),
                appsModel.updateAccessOp(accessOp),
                permissionsModel.updateAccessOp(accessOp),
                questionsModel.accessChange(access),
                administrativeModel.updateAccessOp(accessOp),
                videoModels.dacastModel.updateAccessOp(accessOp),
                videoModels.contentModel.updateAccessOp(accessOp),
                chatModel.updateAccessOp(accessOp),
                notesModel.updateAccessOp(accessOp),
                storeModel.updateAccessOp(accessOp),
            ]);
        });
        return {
            exampleModel,
            appsModel,
            chatModel,
            accessModel,
            videoModels,
            notesModel,
            storeModel,
            personalModel,
            questionsModel,
            permissionsModel,
            administrativeModel,
        };
    }

    function mockModalSystem() {
        const nextModalResults = {
            confirm: true,
            prompt: undefined,
        };
        const modals = {
            popup() {
                return {
                    controls: {
                        close() { },
                        rerender() { },
                    },
                    modal: {},
                };
            },
            async alert() { },
            async confirm() {
                return nextModalResults.confirm;
            },
            async prompt() {
                return nextModalResults.prompt;
            },
            async confirmAction() { },
        };
        return {
            modals,
            nextModalResults,
        };
    }

    function mockStoreRig() {
        return {
            stripeAccountFate: "complete",
            stripeLoginCount: 0,
            customerPortalAction: "link successful payment method"
        };
    }

    function chatMockClient(serverCore) {
        return async function chatConnect({ clientsideApi, handleDisconnect }) {
            const clientside = mock()
                .forApi(clientsideApi)
                .withMetaMap({ chatClient: async () => { } });
            const { api, disconnect } = serverCore.acceptNewClient({
                headers: {},
                controls: {
                    ping() { },
                    close() { },
                },
                clientside,
                handleDisconnect: () => { },
            });
            return {
                serverside: mock()
                    .forApi(api)
                    .withMetaMap({ chatServer: async () => { } }),
                disconnect() {
                    disconnect();
                    handleDisconnect();
                },
            };
        };
    }

    function validator$1(...conditions) {
        return value => {
            let problems = [];
            for (const condition of conditions) {
                problems = condition(value);
                if (problems.length > 0)
                    break;
            }
            return problems;
        };
    }
    function schema(schematic) {
        const schematicKeys = Object.keys(schematic);
        return object => (Object.entries(object).flatMap(([key, value]) => schematicKeys.includes(key)
            ? schematic[key](value)
                .map(problem => `"${key}": ${problem}`)
            : [`"${key} not in schema"`]));
    }
    function branch(...conditions) {
        return value => {
            const results = conditions.map(condition => condition(value));
            let anySuccess = false;
            for (const problems of results)
                if (problems.length === 0)
                    anySuccess = true;
            return anySuccess
                ? []
                : results.flat()
                    .map((problem, index) => index > 0 ? `or, ${problem}` : problem);
        };
    }
    function each(...conditions) {
        return arr => {
            if (!Array.isArray(arr))
                return ["must be array"];
            const validate = validator$1(...conditions);
            const problems = [];
            arr.forEach((item, index) => {
                for (const problem of validate(item))
                    problems.push(`(${index + 1}) ${problem}`);
            });
            return problems;
        };
    }
    const is = (x) => value => value === x
        ? []
        : ["wrong value"];
    const notDefined = () => value => (value !== undefined && value !== null)
        ? ["must be undefined or null"]
        : [];
    const string = () => value => typeof value !== "string"
        ? ["must be a string"]
        : [];
    const number = () => value => typeof value !== "number"
        ? ["must be a number"]
        : [];
    const boolean = () => value => typeof value !== "boolean"
        ? ["must be a boolean"]
        : [];
    const min = (threshold) => value => value < threshold
        ? ["too small"]
        : [];
    const max = (threshold) => value => value > threshold
        ? ["too big"]
        : [];
    const array = () => value => Array.isArray(value)
        ? []
        : ["must be an array"];
    const length = (len) => value => value.length !== len
        ? [`length must be ${len}`]
        : [];
    const minLength = (min) => value => value.length < min
        ? ["too small"]
        : [];
    const maxLength = (max) => value => value.length > max
        ? ["too big"]
        : [];
    const notWhitespace = () => value => value.length > 0 && value.trim().length === 0
        ? ["can't be all whitespace"]
        : [];
    const zeroWhitespace = () => value => /\s/.test(value)
        ? ["must not have any spaces"]
        : [];
    const url = () => value => {
        try {
            void new URL(value);
            return [];
        }
        catch (error) {
            return ["invalid url"];
        }
    };
    const localhost = () => value => {
        return /^https?:\/\/(127\.0\.0\.1|localhost)(|:\d{1,5})(|\/\S*)$/i.test(value)
            ? []
            : ["must be a localhost address"];
    };
    const https = () => value => {
        return /^https:\/\//i.test(value)
            ? []
            : ["must be secure, starting with 'https'"];
    };
    const origin = () => value => /^https?:\/\/[a-zA-Z\.\d-]+(?:|:\d+)$/i.test(value)
        ? []
        : ["invalid origin"];
    const regex = (r, problem = "invalid string") => value => r.test(value)
        ? []
        : [problem];
    const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const email = () => value => emailRegex.test(value)
        ? []
        : ["invalid email"];
    // const labelValidator = validator<string>(string(), minLength(1), maxLength(50), notWhitespace())
    // const problems = labelValidator("hello")
    // const problems2 = validator<string[]>(array(string()))

    const validateId = validator$1(string(), length(64), regex(/^[0-9a-z]{64}$/));

    const validateChatRoom = validator$1(string(), minLength(1), maxLength(32), zeroWhitespace());
    const validateChatContent = validator$1(string(), minLength(1), maxLength(chatPostMaxLength), notWhitespace());
    const validateChatDraft = schema({
        content: validateChatContent,
    });
    const validateIdArray = validator$1(array(), each(validateId));
    const validateChatStatus = validator$1(number(), min(0), max(1));

    const makeChatServerside = ({ rando, rateLimiter, clientRecord, persistence, headers, policy, getStatsFromServerCore, }) => api({
        chatServer: service()
            .policy(async (meta, headers) => {
            var _a;
            const appId = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.appId;
            const persistenceActions = appId
                ? persistence.namespaceForApp(appId)
                : undefined;
            return { persistenceActions, headers };
        })
            .expose(({ persistenceActions, headers }) => {
            const { clientside: { chatClient } } = clientRecord;
            const getAllowance = () => {
                var _a, _b;
                return chatAllowance((_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.permit.privileges) !== null && _b !== void 0 ? _b : []);
            };
            const isNotMuted = () => {
                var _a, _b;
                return !persistenceActions.isMuted((_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access.user) === null || _b === void 0 ? void 0 : _b.userId);
            };
            const isNotBanned = () => !getAllowance().banned;
            function enforceValidation(problems) {
                if (problems.length !== 0)
                    throw new Error("chat validation error");
            }
            return {
                async updateUserMeta(meta) {
                    clientRecord.auth = await policy(meta, headers);
                },
                async getStats() {
                    var _a, _b;
                    const appId = (_b = (_a = clientRecord.auth) === null || _a === void 0 ? void 0 : _a.access) === null || _b === void 0 ? void 0 : _b.appId;
                    if (!appId)
                        throw new ApiError(400, "cannot get stats before updateUserMeta");
                    return getStatsFromServerCore(appId);
                },
                async roomSubscribe(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().viewAllChats)
                        return undefined;
                    clientRecord.rooms.add(room);
                    chatClient.roomStatusChanged(room, await persistenceActions.getRoomStatus(room));
                    chatClient.postsAdded(room, await persistenceActions.fetchRecentPosts(room));
                    chatClient.usersMuted((await persistenceActions.fetchMutes())
                        .map(({ userId }) => userId));
                },
                async roomUnsubscribe(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().viewAllChats)
                        return undefined;
                    clientRecord.rooms.delete(room);
                },
                async post(room, draft) {
                    if (rateLimiter.tooMany())
                        return undefined;
                    enforceValidation(schema({
                        room: validateChatRoom,
                        draft: validateChatDraft,
                    })({ room, draft }));
                    if (!getAllowance().participateInAllChats)
                        return undefined;
                    if (isNotMuted() && isNotBanned()) {
                        const post = {
                            ...draft,
                            room,
                            time: Date.now(),
                            postId: rando.randomId().toString(),
                            userId: clientRecord.auth.access.user.userId,
                            nickname: clientRecord.auth.access.user.profile.nickname,
                        };
                        await persistenceActions.addPosts(room, [post]);
                    }
                },
                async remove(room, postIds) {
                    enforceValidation(schema({
                        room: validateChatRoom,
                        postIds: validateIdArray,
                    })({ room, postIds }));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.removePosts(room, postIds);
                },
                async clear(room) {
                    enforceValidation(validateChatRoom(room));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.clearRoom(room);
                },
                async mute(userIds) {
                    enforceValidation(validateIdArray(userIds));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.addMute(userIds);
                },
                async unmute(userIds) {
                    enforceValidation(validateIdArray(userIds));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.removeMute(userIds);
                },
                async unmuteAll() {
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.unmuteAll();
                },
                async setRoomStatus(room, status) {
                    enforceValidation(schema({
                        room: validateChatRoom,
                        status: validateChatStatus,
                    })({ room, status }));
                    if (!getAllowance().moderateAllChats)
                        return undefined;
                    await persistenceActions.setRoomStatus(room, status);
                },
            };
        }),
    });

    var __classPrivateFieldSet$e = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$p = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Bucket_maximum, _Bucket_storage;
    class Bucket {
        constructor({ maximum }) {
            _Bucket_maximum.set(this, void 0);
            _Bucket_storage.set(this, []);
            __classPrivateFieldSet$e(this, _Bucket_maximum, maximum, "f");
        }
        add(item) {
            __classPrivateFieldGet$p(this, _Bucket_storage, "f").push(item);
            if (__classPrivateFieldGet$p(this, _Bucket_storage, "f").length > __classPrivateFieldGet$p(this, _Bucket_maximum, "f"))
                __classPrivateFieldSet$e(this, _Bucket_storage, __classPrivateFieldGet$p(this, _Bucket_storage, "f").slice(-__classPrivateFieldGet$p(this, _Bucket_maximum, "f")), "f");
        }
        read() {
            return [...__classPrivateFieldGet$p(this, _Bucket_storage, "f")];
        }
    }
    _Bucket_maximum = new WeakMap(), _Bucket_storage = new WeakMap();

    var __classPrivateFieldSet$d = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$o = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _RateLimiter_timeframe, _RateLimiter_maximum, _RateLimiter_bucket;
    class RateLimiter {
        constructor({ timeframe, maximum }) {
            _RateLimiter_timeframe.set(this, void 0);
            _RateLimiter_maximum.set(this, void 0);
            _RateLimiter_bucket.set(this, void 0);
            __classPrivateFieldSet$d(this, _RateLimiter_timeframe, timeframe, "f");
            __classPrivateFieldSet$d(this, _RateLimiter_maximum, maximum, "f");
            __classPrivateFieldSet$d(this, _RateLimiter_bucket, new Bucket({ maximum }), "f");
        }
        hit() {
            const now = Date.now();
            const old = now - __classPrivateFieldGet$o(this, _RateLimiter_timeframe, "f");
            const hitsWithinTimeframe = __classPrivateFieldGet$o(this, _RateLimiter_bucket, "f").read().filter(time => time > old);
            if (hitsWithinTimeframe.length < __classPrivateFieldGet$o(this, _RateLimiter_maximum, "f")) {
                __classPrivateFieldGet$o(this, _RateLimiter_bucket, "f").add(now);
                return true;
            }
            else {
                return false;
            }
        }
        tooMany() {
            return !this.hit();
        }
    }
    _RateLimiter_timeframe = new WeakMap(), _RateLimiter_maximum = new WeakMap(), _RateLimiter_bucket = new WeakMap();

    const pingInterval = 10 * 1000;
    function makeChatServerCore({ rando, persistence, policy, }) {
        const clientRecords = new Set();
        function getStatsFromServerCore(appId) {
            const clientRecordsForThisApp = Array.from(clientRecords)
                .filter(record => { var _a, _b; return ((_b = (_a = record.auth) === null || _a === void 0 ? void 0 : _a.access) === null || _b === void 0 ? void 0 : _b.appId) === appId; });
            const statsForRooms = {};
            for (const record of clientRecordsForThisApp) {
                for (const roomName of record.rooms) {
                    if (!statsForRooms[roomName]) {
                        statsForRooms[roomName] = {
                            totalUsers: 0,
                            viewers: 0,
                            participants: 0,
                            moderators: 0,
                        };
                    }
                    const roomStats = statsForRooms[roomName];
                    roomStats.totalUsers += 1;
                    const isModerator = record.auth.access.permit.privileges
                        .includes(chatPrivileges["moderate all chats"]);
                    const isParticipant = record.auth.access.permit.privileges
                        .includes(chatPrivileges["participate in all chats"]);
                    const isViewer = record.auth.access.permit.privileges
                        .includes(chatPrivileges["view all chats"]);
                    if (isModerator)
                        roomStats.moderators += 1;
                    else if (isParticipant)
                        roomStats.participants += 1;
                    else if (isViewer)
                        roomStats.viewers += 1;
                }
            }
            return {
                numberOfConnections: clientRecordsForThisApp.length,
                statsForRooms,
            };
        }
        async function broadcastToAll(appId, action) {
            for (const record of clientRecords.values())
                if (record.auth && record.auth.access.appId === appId)
                    action(record, chatAllowance(record.auth.access.permit.privileges));
        }
        async function broadcastToRoom(appId, room, action) {
            for (const record of clientRecords.values())
                if (record.auth && record.auth.access.appId === appId && record.rooms.has(room))
                    action(record, chatAllowance(record.auth.access.permit.privileges));
        }
        persistence.events.roomStatusChanged(({ appId, room, status }) => {
            broadcastToRoom(appId, room, record => record.clientside.chatClient.roomStatusChanged(room, status));
        });
        persistence.events.postsAdded(({ appId, room, posts }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.postsAdded(room, posts);
            });
        });
        persistence.events.postsRemoved(({ appId, room, postIds }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.postsRemoved(room, postIds);
            });
        });
        persistence.events.mutes(({ appId, userIds }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.usersMuted(userIds);
            });
        });
        persistence.events.unmutes(({ appId, userIds }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.usersUnmuted(userIds);
            });
        });
        persistence.events.unmuteAll(({ appId }) => {
            broadcastToAll(appId, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.unmuteAll();
            });
        });
        persistence.events.roomCleared(({ appId, room }) => {
            broadcastToRoom(appId, room, (record, allowance) => {
                if (allowance.viewAllChats)
                    record.clientside.chatClient.roomCleared(room);
            });
        });
        function acceptNewClient({ headers, controls, clientside, handleDisconnect }) {
            const clientRecord = {
                auth: undefined,
                rooms: new Set(),
                clientside,
                controls,
            };
            clientRecords.add(clientRecord);
            const rateLimiter = new RateLimiter({
                timeframe: chatRateLimitingInterval,
                maximum: chatRateLimitingInterval / chatPostCoolOff,
            });
            const interval = setInterval(controls.ping, pingInterval);
            return {
                api: makeChatServerside({
                    rando,
                    rateLimiter,
                    persistence,
                    clientRecord,
                    headers,
                    policy,
                    getStatsFromServerCore,
                }),
                disconnect() {
                    clearInterval(interval);
                    handleDisconnect();
                    clientRecords.delete(clientRecord);
                },
            };
        }
        return {
            acceptNewClient,
            get clientCount() { return clientRecords.size; },
        };
    }

    const tokenize$1 = (object) => (url$1.encode(JSON.stringify(object)));
    function mockSignToken() {
        return async ({ payload, lifespan, }) => {
            const data = {
                payload,
                iat: Date.now() / 1000,
                exp: (Date.now() + lifespan) / 1000,
            };
            const header = {
                alg: null,
                typ: "JWT",
            };
            const signature = "fake-mock-token-signature";
            return [
                tokenize$1(header),
                tokenize$1(data),
                tokenize$1(signature),
            ].join(".");
        };
    }

    const mockVerifyToken = () => async (token) => {
        const decoded = tokenDecode(token);
        const expiry = decoded.data.exp * 1000;
        if (Date.now() > expiry)
            throw new Error("token expired");
        return decoded.data.payload;
    };

    const verifyToken = mockVerifyToken();
    async function mockChatPolicy({ accessToken }) {
        return { access: await verifyToken(accessToken) };
    }

    function objectMap(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    var __classPrivateFieldSet$c = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$n = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _AssertiveMap_makeValue;
    class AssertiveMap extends Map {
        constructor(makeValue, entries) {
            super(entries);
            _AssertiveMap_makeValue.set(this, void 0);
            __classPrivateFieldSet$c(this, _AssertiveMap_makeValue, makeValue, "f");
        }
        assert(key) {
            if (this.has(key)) {
                return this.get(key);
            }
            else {
                const value = __classPrivateFieldGet$n(this, _AssertiveMap_makeValue, "f").call(this, key);
                this.set(key, value);
                return value;
            }
        }
    }
    _AssertiveMap_makeValue = new WeakMap();

    const appConstraintKey = "namespace-appId";

    class UnconstrainedTable {
        static wrapTables(tables) {
            function recurse(t) {
                return objectMap(t, value => isTable(value)
                    ? new UnconstrainedTable(value)
                    : recurse(value));
            }
            return recurse(tables);
        }
        static unwrapTables(unconstrainedTables) {
            function recurse(tables) {
                return objectMap(tables, value => value instanceof UnconstrainedTable
                    ? value.unconstrained
                    : recurse(value));
            }
            return recurse(unconstrainedTables);
        }
        static wrapDatabase(database) {
            return subsection(database, tables => UnconstrainedTable.wrapTables(tables));
        }
        static constrainTablesForApp({ appId, unconstrainedTables, }) {
            function recurse(tables) {
                return objectMap(tables, value => value instanceof UnconstrainedTable
                    ? value.constrainForApp(appId)
                    : recurse(value));
            }
            return recurse(unconstrainedTables);
        }
        static constrainDatabaseForApp({ appId, database, }) {
            function recurse(tables) {
                return objectMap(tables, value => value instanceof UnconstrainedTable
                    ? value.constrainForApp(appId)
                    : isTable(value)
                        ? value
                        : recurse(value));
            }
            return {
                tables: recurse(database.tables),
                transaction: (async (action) => database.transaction(async ({ tables, abort }) => action({
                    tables: recurse(tables),
                    abort,
                })))
            };
        }
        constructor(table) {
            this.unconstrained = table;
        }
        constrainForApp(appId) {
            return constrain({
                table: this.unconstrained,
                constraint: { [appConstraintKey]: appId },
            });
        }
    }

    function makeTableNameWithHyphens(path) {
        return path.join("-");
    }

    async function mockChatPersistence(storage) {
        const chatDatabaseRaw = UnconstrainedTable.wrapDatabase(flex({
            shape: chatShape,
            flexStorage: storage,
            makeTableName: makeTableNameWithHyphens,
        }));
        const events = {
            roomStatusChanged: subbies(),
            postsAdded: subbies(),
            postsRemoved: subbies(),
            roomCleared: subbies(),
            mutes: subbies(),
            unmutes: subbies(),
            unmuteAll: subbies(),
        };
        const eventSubscribers = objectMap(events, (event) => event.subscribe);
        const getAppCache = (() => {
            const appCaches = new AssertiveMap(() => ({
                mutedUserIds: new Set()
            }));
            return (appId) => appCaches.assert(appId);
        })();
        // listen to events to update cache
        {
            eventSubscribers.mutes(({ appId, userIds }) => {
                const cache = getAppCache(appId);
                for (const userId of userIds)
                    cache.mutedUserIds.add(userId);
            });
            eventSubscribers.unmutes(({ appId, userIds }) => {
                const cache = getAppCache(appId);
                for (const userId of userIds)
                    cache.mutedUserIds.delete(userId);
            });
            eventSubscribers.unmuteAll(({ appId }) => {
                const cache = getAppCache(appId);
                cache.mutedUserIds.clear();
            });
        }
        function namespaceForApp(appId) {
            const appCache = getAppCache(appId);
            const chatDatabase = UnconstrainedTable.constrainDatabaseForApp({
                appId: Id.fromString(appId),
                database: chatDatabaseRaw,
            });
            const chatTables = chatDatabase.tables;
            return {
                isMuted(userId) {
                    return appCache.mutedUserIds.has(userId);
                },
                async addPosts(room, posts) {
                    await chatTables.posts.create(...posts.map(post => ({
                        room: post.room,
                        time: post.time,
                        content: post.content,
                        nickname: post.nickname,
                        userId: Id.fromString(post.userId),
                        postId: Id.fromString(post.postId),
                    })));
                    events.postsAdded.publish({ appId, room, posts });
                },
                async removePosts(room, postIds) {
                    if (postIds.length) {
                        await chatTables.posts.delete(findAll(postIds, postId => ({
                            room,
                            postId: Id.fromString(postId)
                        })));
                        events.postsRemoved.publish({ appId, room, postIds });
                    }
                },
                async fetchRecentPosts(room) {
                    const rawPosts = await chatTables.posts.read({
                        ...find({ room }),
                        limit: maximumNumberOfPostsShownAtOnce,
                        order: { time: "descend" },
                    });
                    const recentPosts = rawPosts.map(post => ({
                        room: post.room,
                        time: post.time,
                        content: post.content,
                        nickname: post.nickname,
                        postId: post.postId.toString(),
                        userId: post.userId.toString(),
                    }));
                    const postsSortedByTime = recentPosts.sort((a, b) => a.time - b.time);
                    return postsSortedByTime;
                },
                async fetchMutes() {
                    const rows = await chatTables.mutes.read({ conditions: false });
                    return rows.map(row => ({ userId: row.userId.toString() }));
                },
                async clearRoom(room) {
                    await chatTables.posts.delete(find({ room }));
                    events.roomCleared.publish({ appId, room });
                },
                async addMute(userIds) {
                    if (userIds.length) {
                        const existingMutes = await chatTables.mutes.read(findAll(userIds, userId => ({
                            userId: Id.fromString(userId),
                        })));
                        const userIdsAlreadyMuted = existingMutes.map(row => row.userId.toString());
                        const userIdsToBeMuted = userIds.filter(userId => !userIdsAlreadyMuted.includes(userId));
                        const newMutes = userIdsToBeMuted.map(userId => ({
                            userId: Id.fromString(userId)
                        }));
                        await chatTables.mutes.create(...newMutes);
                        events.mutes.publish({ appId, userIds: userIdsToBeMuted });
                    }
                },
                async removeMute(userIds) {
                    if (userIds.length) {
                        await chatTables.mutes.delete(findAll(userIds, userId => ({ userId: Id.fromString(userId) })));
                        events.unmutes.publish({ appId, userIds });
                    }
                },
                async unmuteAll() {
                    await chatTables.mutes.delete({ conditions: false });
                    events.unmuteAll.publish({ appId });
                },
                async setRoomStatus(room, status) {
                    await chatTables.roomStatuses.update({
                        ...find({ room }),
                        upsert: { room, status },
                    });
                    events.roomStatusChanged.publish({ appId, room, status });
                },
                async getRoomStatus(room) {
                    const row = await chatTables.roomStatuses.readOne(find({ room }));
                    return row
                        ? row.status
                        : ChatStatus.Offline;
                },
            };
        }
        return {
            events: eventSubscribers,
            namespaceForApp,
        };
    }

    async function chatMockClientEntirely(storage) {
        const serverCore = makeChatServerCore({
            rando: await getRando(),
            persistence: await mockChatPersistence(storage),
            policy: mockChatPolicy,
        });
        return chatMockClient(serverCore);
    }

    function riggedStripePopups({ rig, mockStripeOperations }) {
        return {
            async connect({ popupId, stripeAccountId }) {
                if (rig.stripeAccountFate === "complete") {
                    await mockStripeOperations.linkStripeAccount(stripeAccountId);
                    return { popupId, details: { status: "return" } };
                }
                else {
                    await mockStripeOperations.linkStripeAccountThatIsIncomplete(stripeAccountId);
                    return { popupId, details: { status: "return" } };
                }
            },
            async login({ popupId, stripeAccountId }) {
                rig.stripeLoginCount += 1;
                if (rig.stripeAccountFate === "complete")
                    await mockStripeOperations.linkStripeAccount(stripeAccountId);
                else
                    await mockStripeOperations.linkStripeAccountThatIsIncomplete(stripeAccountId);
                return { popupId };
            },
            async checkoutSubscription({ popupId, stripeAccountId, stripeSessionId }) {
                await mockStripeOperations.checkoutSubscriptionTier(stripeAccountId, stripeSessionId);
                return { popupId };
            },
            async openStoreCustomerPortal({ popupId, stripeAccountId, customer }) {
                if (rig.customerPortalAction === "link successful payment method") {
                    await mockStripeOperations.createNewDefaultPaymentMethod({
                        stripeAccountId, customer, isFailing: false
                    });
                }
                else if (rig.customerPortalAction === "link failing payment method") {
                    await mockStripeOperations.createNewDefaultPaymentMethod({
                        stripeAccountId, customer, isFailing: true
                    });
                }
                else if (rig.customerPortalAction === "detach payment method") {
                    await mockStripeOperations.removeAllPaymentMethods(customer);
                }
                return { popupId };
            },
        };
    }

    async function mockBrowser({ api, appOrigin, mockStripeOperations }) {
        async function mockAppWindow({ appId }) {
            const storage = memoryFlexStorage();
            const { remote, authMediator } = mockRemote({
                api,
                appId,
                storage,
                logging: false,
                headers: { origin: appOrigin },
            });
            const { nextModalResults } = mockModalSystem();
            const models = await assembleModels({
                appId,
                remote,
                storage,
                authMediator,
                stripePopups: riggedStripePopups({
                    rig: mockStoreRig(),
                    mockStripeOperations,
                }),
                chatConnect: await chatMockClientEntirely(storage),
            });
            return { models, remote, nextModalResults };
        }
        return { mockAppWindow };
    }

    function isPlatform(appId, config) {
        return config.platform.appDetails.appId === appId;
    }

    async function concurrent(obj) {
        const keys = Object.keys(obj);
        const awaitables = Object.values(obj);
        const values = await Promise.all(awaitables);
        const result = {};
        keys.forEach((key, i) => result[key] = values[i]);
        return result;
    }

    const validateAppOrigin = validator$1(string(), maxLength(1000), origin(), branch(https(), localhost()));
    const appDraftValidators = Object.freeze({
        home: validator$1(string(), minLength(1), maxLength(2000), branch(validator$1(url(), https()), localhost())),
        label: validator$1(string(), minLength(1), maxLength(50), notWhitespace()),
        origins: validator$1(minLength(1), maxLength(100), each(validateAppOrigin)),
        additionalOrigins: validator$1(array(), minLength(0), maxLength(99), each(validateAppOrigin)),
    });

    const validator = schema({
        home: appDraftValidators.home,
        label: appDraftValidators.label,
        origins: appDraftValidators.origins,
    });
    function validateAppDraft(appDraft) {
        return validator(appDraft);
    }

    function originsFromDatabase(origins) {
        return origins.split(";");
    }

    function throwProblems(problems) {
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
    }

    function originsToDatabase(origins) {
        return origins.join(";");
    }

    async function addApp({ rando, appsDatabase, appDraft, ownerUserId: ownerUserIdString, }) {
        const ownerUserId = Id.fromString(ownerUserIdString);
        const appId = rando.randomId();
        await Promise.all([
            appsDatabase.tables.registrations.create({
                appId,
                label: appDraft.label,
                home: appDraft.home,
                origins: originsToDatabase(appDraft.origins),
                archived: false,
            }),
            appsDatabase.tables.owners.create({
                appId,
                userId: ownerUserId,
            }),
        ]);
        return {
            ...appDraft,
            appId: appId.toString(),
            stats: {
                users: 1,
                usersActiveDaily: 0,
                usersActiveMonthly: 0,
            },
        };
    }

    const makeAppService = ({ rando, config, authPolicies, }) => service()
        .policy(authPolicies.platformUserPolicy)
        .expose(({ database, statsHub }) => ({
        async listApps({ ownerUserId: ownerUserIdString }) {
            const ownerUserId = Id.fromString(ownerUserIdString);
            const ownerships = await database.tables.apps.owners.read(find({ userId: ownerUserId }));
            const appRows = ownerships.length
                ? await database.tables.apps.registrations.read({
                    conditions: and(or(...ownerships.map(own => ({ equal: { appId: own.appId } }))), { equal: { archived: false } })
                })
                : [];
            return Promise.all(appRows.map(async (row) => ({
                appId: row.appId.toString(),
                label: row.label,
                home: row.home,
                origins: originsFromDatabase(row.origins),
                platform: isPlatform(row.appId.toString(), config),
                stats: await concurrent({
                    users: statsHub.countUsers(row.appId),
                    usersActiveDaily: statsHub.countUsersActiveDaily(row.appId),
                    usersActiveMonthly: statsHub.countUsersActiveMonthly(row.appId),
                }),
            })));
        },
        async registerApp({ appDraft, ownerUserId }) {
            throwProblems(validateAppDraft(appDraft));
            return addApp({
                rando,
                appDraft,
                ownerUserId,
                appsDatabase: subsection(database, tables => tables.apps),
            });
        },
    }));

    const profileFromRow = ({ avatar, tagline, nickname, }) => ({
        tagline,
        nickname,
        avatar: JSON.parse(avatar),
    });

    async function fetchUsers({ userIds, authTables, permissionsEngine }) {
        if (!userIds.length)
            throw new Error("invalid: userIds cannot be empty");
        const conditions = or(...userIds.map(userId => ({ equal: { userId } })));
        const accounts = await authTables.users.accounts.read({ conditions });
        const profiles = await authTables.users.profiles.read({ conditions });
        const publicRolesForUsers = await permissionsEngine
            .getPublicRolesForUsers(userIds.map(id => id.toString()));
        function assembleDetailsForEachUser(userId) {
            const account = accounts.find(a => a.userId.toString() === userId.toString());
            const profile = profiles.find(p => p.userId.toString() === userId.toString());
            if (!account)
                throw new ApiError(404, `account not found for user id ${userId}`);
            if (!profile)
                throw new ApiError(404, `profile not found for user id ${userId}`);
            const roles = publicRolesForUsers
                .find(r => r.userId.toString() === userId.toString())
                .publicUserRoles;
            const stats = {
                joined: account.created,
            };
            return {
                userId: userId.toString(),
                profile: profileFromRow(profile),
                roles,
                stats,
            };
        }
        return userIds.map(assembleDetailsForEachUser);
    }

    async function fetchUser({ userId, ...options }) {
        const results = await fetchUsers({ ...options, userIds: [userId] });
        return results.find(r => r.userId);
    }

    function permissionsMergingFacility({ isPlatform }) {
        const hardPermissions = isPlatform
            ? platformPermissions
            : appPermissions;
        function getHardPrivilegeDetails(...roleIds) {
            const results = [];
            for (const roleId of roleIds) {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role2]) => role2.roleId === roleId);
                if (found) {
                    const [, role] = found;
                    for (const [label, has] of Object.entries(role.hasPrivileges)) {
                        const privilegeId = hardPermissions.privileges[label];
                        const already = results.find(detail => detail.roleId === roleId &&
                            detail.privilegeId === privilegeId);
                        if (!already) {
                            results.push({
                                privilegeId,
                                roleId,
                                active: has.active,
                                immutable: has.immutable,
                            });
                        }
                    }
                }
            }
            return results;
        }
        function mergeRoleHasPrivileges({ hard, soft }) {
            const results = [];
            function rowMatch(hardy, softy) {
                return hardy.roleId === softy.roleId.toString()
                    && hardy.privilegeId === softy.privilegeId.toString();
            }
            function toSofty(hardy) {
                return {
                    roleId: Id.fromString(hardy.roleId),
                    privilegeId: Id.fromString(hardy.privilegeId),
                    active: hardy.active,
                    immutable: hardy.immutable,
                    time: 0,
                };
            }
            for (const softy of soft) {
                const hardy = hard.find(h => rowMatch(h, softy));
                results.push(hardy && hardy.immutable
                    ? toSofty(hardy)
                    : softy);
            }
            for (const hardy of hard) {
                const alreadyIncluded = !!results.find(softy => rowMatch(hardy, softy));
                if (!alreadyIncluded)
                    results.push(toSofty(hardy));
            }
            return results;
        }
        function getActivePrivilegeIds(roleHasPrivileges) {
            return roleHasPrivileges
                .filter(row => row.active)
                .map(row => row.privilegeId);
        }
        return {
            hardPermissions,
            mergeRoleHasPrivileges,
            getActivePrivilegeIds,
            getHardPrivilegeDetails,
        };
    }

    function isDefined(x) {
        return x !== undefined && x !== null;
    }

    function isCurrentlyWithinTimeframe({ timeframeStart, timeframeEnd }) {
        const time = Date.now();
        const tooEarly = isDefined(timeframeStart)
            ? time < timeframeStart
            : false;
        const tooLate = isDefined(timeframeEnd)
            ? time > timeframeEnd
            : false;
        return !tooEarly && !tooLate;
    }

    function makePermissionsEngine({ isPlatform, permissionsTables }) {
        const { hardPermissions, mergeRoleHasPrivileges, getActivePrivilegeIds, getHardPrivilegeDetails, } = permissionsMergingFacility({ isPlatform });
        async function getAnonymousPrivileges() {
            const roleId = hardPermissions.roles.everybody.roleId;
            const hard = getHardPrivilegeDetails(roleId);
            const soft = await permissionsTables.roleHasPrivilege
                .read(find({ roleId: Id.fromString(roleId) }));
            return getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }))
                .map(id => id.toString());
        }
        async function getUsersHaveRoles({ userIds, onlyGetPublicRoles }) {
            const isPublic = (row) => row.public;
            const all = (x) => x;
            const usersHaveRoles = await (async () => {
                if (userIds.length === 0)
                    throw new Error("invalid: user ids cannot be empty");
                const usersHaveRolesRaw = await permissionsTables.userHasRole.read({
                    conditions: or(...userIds.map(userId => ({
                        equal: { userId: Id.fromString(userId) }
                    }))),
                });
                const roleIds = usersHaveRolesRaw.map(u => u.roleId);
                const roles = roleIds.length
                    ? await permissionsTables.role.read({
                        conditions: or(...roleIds.map(roleId => ({ equal: { roleId } })))
                    })
                    : [];
                const roleIdsThatActuallyExist = [
                    ...roles.map(r => r.roleId.toString()),
                    ...Object.entries(hardPermissions.roles)
                        .map(([, role]) => role.roleId),
                ];
                return usersHaveRolesRaw
                    .filter(u => roleIdsThatActuallyExist.includes(u.roleId.toString()));
            })();
            return userIds.map(userId => {
                const raw = usersHaveRoles.filter(r => r.userId.toString() === userId);
                const userHasRoles = raw
                    .filter(isCurrentlyWithinTimeframe)
                    .filter(onlyGetPublicRoles ? isPublic : all);
                return { userId, userHasRoles };
            });
        }
        async function getPrivilegesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: false,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles.map(r2 => r2.roleId));
            const allRolesHavePrivileges = allRoleIds.length
                ? await permissionsTables.roleHasPrivilege.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: ({ roleId }) })))
                })
                : [];
            function resolvePrivilegesForEachUser(userId) {
                const roleIds = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles
                    .map(r => r.roleId.toString());
                // roleIds.push(universalPermissions.roles.authenticated.roleId)
                const hard = getHardPrivilegeDetails(...roleIds);
                const soft = roleIds
                    .flatMap(roleId => allRolesHavePrivileges.filter(p => p.roleId.toString() === roleId));
                const privileges = getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }))
                    .map(id => id.toString());
                return { userId, privileges };
            }
            return userIds.map(resolvePrivilegesForEachUser);
        }
        async function getPublicRolesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: true,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles
                .filter(r2 => r2.public)
                .map(r2 => r2.roleId.toString()));
            const allHardRoles = allRoleIds.map(roleId => {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role]) => role.roleId === roleId);
                if (found) {
                    const [label, role] = found;
                    return {
                        roleId: Id.fromString(roleId),
                        label,
                        hard: true,
                        public: role.public,
                        assignable: role.assignable,
                        time: 0,
                    };
                }
                else {
                    return undefined;
                }
            }).filter(r => !!r);
            const allSoftRoles = allRoleIds.length
                ? await permissionsTables.role.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: { roleId: Id.fromString(roleId) } })))
                })
                : [];
            const mergedRoles = [...allHardRoles];
            for (const role of allSoftRoles) {
                const found = mergedRoles.find(r => r.roleId === role.roleId);
                if (!found)
                    mergedRoles.push(role);
            }
            function assemblePublicRolesForEachUser(userId) {
                const userHasRoles = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles;
                const publicUserRoles = userHasRoles
                    .map(userHasRole => {
                    const role = mergedRoles.find(r => r.roleId.toString() === userHasRole.roleId.toString());
                    if (!role)
                        console.warn(`missing role "${userHasRole.roleId.toString()}"`);
                    return role
                        ? { ...userHasRole, ...role }
                        : undefined;
                })
                    .filter(r => !!r)
                    .filter(isCurrentlyWithinTimeframe)
                    .map(r => ({
                    label: r.label,
                    roleId: r.roleId.toString(),
                    timeframeEnd: r.timeframeEnd,
                    timeframeStart: r.timeframeStart,
                }));
                return { userId, publicUserRoles };
            }
            return userIds.map(assemblePublicRolesForEachUser);
        }
        const { getPrivileges, getAllPrivileges } = (() => {
            function getAllHardPrivileges() {
                return Object.entries(hardPermissions.privileges)
                    .map(([label, privilegeId]) => ({
                    privilegeId: Id.fromString(privilegeId),
                    label,
                    hard: true,
                    time: 0,
                }));
            }
            function mergePrivileges(soft, hard) {
                return merge(soft, hard, (a, b) => a.privilegeId === b.privilegeId)
                    .map(({ hard, label, time, privilegeId }) => ({
                    hard,
                    label,
                    time: time !== null && time !== void 0 ? time : 0,
                    privilegeId: privilegeId.toString(),
                }));
            }
            return {
                async getPrivileges(privilegeIds) {
                    const soft = privilegeIds.length
                        ? await permissionsTables.privilege
                            .read(findAll(privilegeIds, id => ({
                            privilegeId: Id.fromString(id)
                        })))
                        : [];
                    const hard = getAllHardPrivileges()
                        .filter(p => privilegeIds.includes(p.privilegeId.toString()));
                    return mergePrivileges(soft, hard);
                },
                async getAllPrivileges() {
                    const soft = await permissionsTables.privilege.read({ conditions: false });
                    const hard = getAllHardPrivileges();
                    return mergePrivileges(soft, hard);
                },
            };
        })();
        async function getPermissionsDisplay() {
            const all = { conditions: false };
            return concurrent({
                roles: (async () => {
                    const soft = await permissionsTables.role.read(all);
                    const hard = Object.entries(hardPermissions.roles)
                        .map(([label, r]) => ({
                        label,
                        hard: true,
                        roleId: Id.fromString(r.roleId),
                        public: r.public,
                        assignable: r.assignable,
                        time: 0,
                    }));
                    return merge(soft, hard, (a, b) => a.roleId === b.roleId)
                        .map(result => {
                        var _a;
                        return ({
                            roleId: result.roleId.toString(),
                            assignable: result.assignable,
                            label: result.label,
                            hard: result.hard,
                            public: result.public,
                            time: (_a = result.time) !== null && _a !== void 0 ? _a : 0,
                        });
                    });
                })(),
                privileges: getAllPrivileges(),
                rolesHavePrivileges: (async () => {
                    const roleIds = Object.values(hardPermissions.roles)
                        .map(role => role.roleId);
                    const hard = getHardPrivilegeDetails(...roleIds);
                    const soft = await permissionsTables.roleHasPrivilege.read(all);
                    return mergeRoleHasPrivileges({ hard, soft })
                        .map(({ active, privilegeId, immutable, roleId, time }) => ({
                        active,
                        immutable,
                        time: time !== null && time !== void 0 ? time : 0,
                        roleId: roleId.toString(),
                        privilegeId: privilegeId.toString(),
                    }));
                })(),
            });
        }
        async function getUserPrivileges(userId) {
            const result = await getPrivilegesForUsers([userId]);
            return result
                .find(r => r.userId === userId)
                .privileges;
        }
        // async function getUserPublicRoles(userId: string) {
        // 	const result = await getPublicRolesForUsers([userId])
        // 	return result
        // 		.find(r => r.userId === userId)
        // 		.publicUserRoles
        // }
        return {
            getUsersHaveRoles,
            getAnonymousPrivileges,
            getPrivilegesForUsers,
            getPublicRolesForUsers,
            getPermissionsDisplay,
            getPrivileges,
            getAllPrivileges,
            getUserPrivileges,
        };
    }

    const makeUserService = (options) => service()
        .policy(options.authPolicies.anonPolicy)
        .expose(({ database, access }) => ({
        async getUser({ userId }) {
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: database.tables.auth.permissions,
                isPlatform: access.appId === options.config.platform.appDetails.appId,
            });
            return await fetchUser({
                authTables: database.tables.auth,
                permissionsEngine,
                userId: Id.fromString(userId),
            });
        },
    }));

    const makeGreenService = (options) => service()
        .policy(options.authPolicies.greenPolicy)
        .expose(({ databaseRaw }) => ({
        async authorize({ scope, refreshToken, appId: appIdString, }) {
            const appId = Id.fromString(appIdString);
            const databaseForApp = UnconstrainedTable.constrainDatabaseForApp({
                appId,
                database: databaseRaw,
            });
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: databaseForApp.tables.auth.permissions,
                isPlatform: appId.toString() === options.config.platform.appDetails.appId,
            });
            const appRow = await databaseRaw.tables.apps.registrations.readOne(find({ appId }));
            if (!appRow)
                throw new ApiError(400, "incorrect app id");
            if (appRow.archived)
                throw new ApiError(403, "app has been archived");
            if (refreshToken) {
                const { userId: userIdString } = await options.verifyToken(refreshToken);
                const userId = Id.fromString(userIdString);
                const user = await fetchUser({
                    userId,
                    permissionsEngine,
                    authTables: databaseForApp.tables.auth,
                });
                await databaseForApp.tables.auth.users.latestLogins.update({
                    ...find({ userId }),
                    upsert: { userId, time: Date.now() },
                });
                const privileges = await permissionsEngine
                    .getUserPrivileges(userId.toString());
                return options.signToken({
                    lifespan: options.config.crypto.tokenLifespans.access,
                    payload: {
                        user,
                        scope,
                        permit: { privileges },
                        appId: appId.toString(),
                        origins: originsFromDatabase(appRow.origins),
                    },
                });
            }
            else {
                const privileges = await permissionsEngine.getAnonymousPrivileges();
                return options.signToken({
                    lifespan: options.config.crypto.tokenLifespans.access,
                    payload: {
                        user: undefined,
                        appId: appId.toString(),
                        scope,
                        origins: originsFromDatabase(appRow.origins),
                        permit: { privileges },
                    },
                });
            }
        }
    }));

    async function signAuthTokens({ scope, appId, userId, origins, lifespans, authTables, permissionsEngine, signToken, }) {
        const { user, permit } = await concurrent({
            user: fetchUser({ userId, authTables, permissionsEngine }),
            permit: (async () => ({
                privileges: await permissionsEngine.getUserPrivileges(userId.toString()),
            }))(),
        });
        return concurrent({
            accessToken: signToken({
                payload: { appId, origins, user, permit, scope },
                lifespan: lifespans.access,
            }),
            refreshToken: signToken({
                payload: { userId: user.userId },
                lifespan: lifespans.refresh,
            }),
        });
    }

    function generateAccountRow({ rando }) {
        return {
            userId: rando.randomId(),
            created: Date.now(),
        };
    }

    const generateProfileRow = ({ userId, avatar, generateNickname }) => ({
        userId,
        avatar,
        tagline: "",
        nickname: generateNickname(),
    });

    function randomXioAvatarSimpleSpec() {
        return {
            type: "simple",
            value: Math.random(),
        };
    }

    async function initializeUserProfile({ userId, database, email, generateNickname }) {
        const avatar = JSON.stringify(randomXioAvatarSimpleSpec());
        await database.tables.auth.users.profiles.create(generateProfileRow({
            userId,
            avatar,
            generateNickname,
        }));
    }

    const standardRoleIds = {
        everybody: universalPermissions.roles.everybody.roleId,
        authenticated: universalPermissions.roles.authenticated.roleId,
        technician: universalPermissions.roles.technician.roleId,
    };
    async function assertEmailAccount({ rando, email, databaseForApp, config, generateNickname, }) {
        email = email.toLowerCase();
        const authTables = databaseForApp.tables.auth;
        const accountViaEmail = await assert(authTables.users.emails, find({ email }), async function makeNewAccountViaEmail() {
            const isTechnician = email === config.platform.technician.email;
            const account = generateAccountRow({ rando });
            const { userId } = account;
            const createAccount = authTables.users.accounts.create(account);
            const createProfile = initializeUserProfile({
                userId,
                email,
                database: databaseForApp,
                generateNickname,
            });
            const assignEverybody = authTables.permissions.userHasRole.create({
                userId,
                hard: true,
                public: false,
                roleId: Id.fromString(standardRoleIds.everybody),
                timeframeEnd: undefined,
                timeframeStart: undefined,
                time: Date.now(),
            });
            const assignAuthenticated = authTables.permissions.userHasRole.create({
                userId,
                hard: true,
                public: false,
                roleId: Id.fromString(standardRoleIds.authenticated),
                timeframeEnd: undefined,
                timeframeStart: undefined,
                time: Date.now(),
            });
            const assignTechnician = isTechnician
                ? authTables.permissions.userHasRole.create({
                    userId,
                    hard: true,
                    public: true,
                    timeframeEnd: undefined,
                    roleId: Id.fromString(standardRoleIds.technician),
                    timeframeStart: undefined,
                    time: Date.now(),
                })
                : Promise.resolve();
            await Promise.all([
                createAccount,
                createProfile,
                assignEverybody,
                assignAuthenticated,
                assignTechnician,
            ]);
            return { email, userId };
        });
        return { userId: accountViaEmail.userId };
    }

    function runValidation(value, validator) {
        const problems = validator(value);
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
        else
            return value;
    }

    const makeLoginService = ({ rando, config, authPolicies, signToken, verifyToken, sendLoginEmail, generateNickname, }) => service()
        .policy(authPolicies.anonPolicy)
        .expose(({ access, database }) => ({
        async sendLoginLink(inputs) {
            const { email: rawEmail } = runValidation(inputs, schema({ email: email() }));
            const email$1 = rawEmail.toLowerCase();
            const appId = Id.fromString(access.appId);
            const appRow = await database.tables.apps.registrations.readOne(find({ appId }));
            const { userId } = await assertEmailAccount({
                rando, email: email$1, config, databaseForApp: database, generateNickname,
            });
            const loginTokenPayload = { userId: userId.toString() };
            await sendLoginEmail({
                appHome: appRow.home,
                appLabel: appRow.label,
                to: email$1,
                legalLink: config.platform.legalLink,
                platformLink: config.platform.appDetails.home,
                lifespan: config.crypto.tokenLifespans.login,
                loginToken: await signToken({
                    payload: loginTokenPayload,
                    lifespan: config.crypto.tokenLifespans.login,
                }),
            });
        },
        async authenticateViaLoginToken({ loginToken }) {
            const authTables = database.tables.auth;
            const verified = await verifyToken(loginToken);
            const userId = Id.fromString(verified.userId);
            const authTokens = await signAuthTokens({
                userId,
                authTables,
                scope: { core: true },
                appId: access.appId,
                origins: access.origins,
                lifespans: config.crypto.tokenLifespans,
                permissionsEngine: makePermissionsEngine({
                    isPlatform: access.appId === config.platform.appDetails.appId,
                    permissionsTables: authTables.permissions,
                }),
                signToken,
            });
            await authTables.users.latestLogins.update({
                ...find({ userId }),
                upsert: { userId, time: Date.now() },
            });
            return authTokens;
        },
    }));

    const adminRoleId$1 = Id.fromString(appPermissions.roles.admin.roleId);
    async function appointAdmin({ email, rando, config, databaseForApp, generateNickname, }) {
        const { userId: adminUserId } = await assertEmailAccount({
            rando,
            email,
            config,
            databaseForApp,
            generateNickname,
        });
        await assert(databaseForApp.tables.auth.permissions.userHasRole, find({ userId: adminUserId, roleId: adminRoleId$1 }), async () => ({
            userId: adminUserId,
            roleId: adminRoleId$1,
            hard: false,
            public: true,
            timeframeEnd: undefined,
            timeframeStart: undefined,
            time: Date.now()
        }));
    }

    const emailValidator = validator$1(string(), maxLength(256), email());

    const adminRoleId = Id.fromString(appPermissions.roles.admin.roleId);
    const makeAppEditService = ({ rando, config, authPolicies, generateNickname, }) => service()
        .policy(authPolicies.appOwnerPolicy)
        .expose(({ database, authorizeAppOwner }) => ({
        async updateApp({ appId: appIdString, appDraft }) {
            throwProblems(validateAppDraft(appDraft));
            const appId = Id.fromString(appIdString);
            await authorizeAppOwner(appId);
            await database.tables.apps.registrations.update({
                ...find({ appId }),
                whole: {
                    appId,
                    home: appDraft.home,
                    label: appDraft.label,
                    origins: originsToDatabase(appDraft.origins),
                    archived: false,
                },
            });
        },
        async deleteApp({ appId: appIdString }) {
            const appId = Id.fromString(appIdString);
            await authorizeAppOwner(appId);
            await database.tables.apps.registrations.update({
                ...find({ appId }),
                write: { archived: true },
            });
        },
        async listAdmins({ appId: appIdString }) {
            const appId = Id.fromString(appIdString);
            const databaseForApp = await authorizeAppOwner(appId);
            const usersWithAdminRole = await databaseForApp
                .tables.auth.permissions.userHasRole
                .read(find({ roleId: adminRoleId }));
            const adminsViaEmail = await databaseForApp.tables.auth.users.emails
                .read(find(...usersWithAdminRole.map(({ userId }) => ({ userId }))));
            return adminsViaEmail.map(({ userId, email }) => ({
                userId: userId.toString(),
                email,
            }));
        },
        async assignPlatformUserAsAdmin({ appId: appIdString, platformUserId: platformUserIdString }) {
            const appId = Id.fromString(appIdString);
            const databaseForApp = await authorizeAppOwner(appId);
            const platformUserId = Id.fromString(platformUserIdString);
            const platformAccount = await database.tables.auth.users.emails
                .readOne(find({ userId: platformUserId }));
            if (!platformAccount)
                throw new ApiError(404, "platform email account not found");
            const { email } = platformAccount;
            await appointAdmin({
                rando,
                config,
                email,
                databaseForApp,
                generateNickname,
            });
        },
        async assignAdmin({ appId: appIdString, email }) {
            const appId = Id.fromString(appIdString);
            const databaseForApp = await authorizeAppOwner(appId);
            const problems = emailValidator(email);
            if (problems.length)
                throw new ApiError(400, "email failed validation: " + problems.join(";"));
            await appointAdmin({
                rando,
                config,
                email: email.toLowerCase(),
                databaseForApp,
                generateNickname,
            });
        },
        async revokeAdmin({ appId: appIdString, userId: userIdString }) {
            const appId = Id.fromString(appIdString);
            const userId = Id.fromString(userIdString);
            const databaseForApp = await authorizeAppOwner(appId);
            await databaseForApp.tables.auth.permissions.userHasRole.delete(find({
                userId,
                roleId: adminRoleId,
            }));
        },
    }));

    const profileValidators = {
        nickname: validator$1(string(), minLength(1), maxLength(24), notWhitespace()),
        tagline: validator$1(string(), minLength(0), maxLength(32), notWhitespace()),
    };
    const validateProfileDraft = schema({
        ...profileValidators,
    });

    const makePersonalService = (options) => service()
        .policy(options.authPolicies.userPolicy)
        .expose(({ access, database, checker }) => ({
        async setProfile({ userId: userIdString, profileDraft }) {
            const userId = Id.fromString(userIdString);
            const isProfileOwner = access.user.userId === userIdString;
            const canEditAnyProfile = checker.hasPrivilege("edit any profile");
            const allowed = isProfileOwner || canEditAnyProfile;
            if (!allowed)
                throw new ApiError(403, "forbidden: you are not allowed to edit this profile");
            throwProblems(validateProfileDraft(profileDraft));
            await database.tables.auth.users.profiles.update({
                ...find({ userId }),
                write: {
                    nickname: profileDraft.nickname,
                    tagline: profileDraft.tagline,
                },
            });
        },
    }));

    const roleLabelValidator = validator$1(string(), minLength(1), maxLength(16), notWhitespace());

    const makePermissionsService = ({ rando, config, authPolicies, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        auth.checker.requirePrivilege("customize permissions");
        const engine = makePermissionsEngine({
            permissionsTables: auth.database.tables.auth.permissions,
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
        });
        return { ...auth, engine };
    })
        .expose(({ database, engine }) => ({
        async fetchPermissions() {
            return engine.getPermissionsDisplay();
        },
        async createRole({ label }) {
            const problems = roleLabelValidator(label);
            if (problems.length)
                throw new ApiError(400, `validation error on label: ${problems.join("; ")}`);
            await database.tables.auth.permissions.role.create({
                label,
                hard: false,
                public: true,
                assignable: true,
                roleId: rando.randomId(),
                time: Date.now(),
            });
        },
        async deleteRole({ roleId: roleIdString }) {
            const roleId = Id.fromString(roleIdString);
            const role = await database.tables.auth.permissions.role
                .readOne(find({ roleId }));
            if (!role)
                throw new ApiError(404, "role not found");
            if (role.hard)
                throw new ApiError(400, "cannot delete hard role");
            await Promise.all([
                database.tables.auth.permissions.userHasRole.delete(find({ roleId })),
                database.tables.auth.permissions.role.delete(find({ roleId })),
            ]);
        },
        async assignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }) {
            const roleId = Id.fromString(roleIdString);
            const privilegeId = Id.fromString(privilegeIdString);
            await database.tables.auth.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: true,
                    immutable: false,
                    time: Date.now(),
                },
            });
        },
        async unassignPrivilege({ roleId: roleIdString, privilegeId: privilegeIdString }) {
            const roleId = Id.fromString(roleIdString);
            const privilegeId = Id.fromString(privilegeIdString);
            await database.tables.auth.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: false,
                    immutable: false,
                    time: Date.now(),
                },
            });
        },
        async createPrivilege({ label }) {
            const privilege = {
                label,
                hard: false,
                privilegeId: rando.randomId(),
                time: Date.now(),
            };
            await database.tables.auth.permissions.privilege.create(privilege);
            return {
                hard: privilege.hard,
                label: privilege.label,
                privilegeId: privilege.privilegeId.toString(),
                time: Date.now(),
            };
        },
        async deletePrivilege({ privilegeId: privilegeIdString }) {
            const privilegeId = Id.fromString(privilegeIdString);
            const [privilege] = await engine.getPrivileges([privilegeId.toString()]);
            if (!privilege)
                throw new ApiError(400, `cannot delete missing privilege "${privilege.privilegeId.toString()}"`);
            if (privilege.hard)
                throw new ApiError(400, `cannot delete hard privilege "${privilege.privilegeId.toString()}"`);
            await Promise.all([
                database.tables.auth.permissions
                    .roleHasPrivilege.delete(find({ privilegeId })),
                database.tables.auth.permissions
                    .privilege.delete(find({ privilegeId })),
            ]);
        },
    }));

    function authApi(options) {
        return api({
            apps: {
                appService: makeAppService(options),
                appEditService: makeAppEditService(options),
            },
            users: {
                greenService: makeGreenService(options),
                loginService: makeLoginService(options),
                userService: makeUserService(options),
                personalService: makePersonalService(options),
            },
            permissions: {
                permissionsService: makePermissionsService(options),
            },
        });
    }

    const maxNotesPerPage = 100;
    const validatePagination = schema({
        offset: validator$1(number(), min(0)),
        limit: validator$1(number(), min(0), max(maxNotesPerPage))
    });

    const makeNotesService = ({ config, basePolicy, }) => service()
        .policy(async (meta, headers) => {
        const auth = await basePolicy(meta, headers);
        return {
            ...auth,
            notesDatabase: subsection(auth.database, tables => tables.notes),
        };
    })
        .expose(({ notesDatabase, access }) => ({
        async getNotesStats() {
            const { userId } = access.user;
            const newCount = await notesDatabase.tables.notes.count(find({
                to: Id.fromString(userId),
                old: false
            }));
            const oldCount = await notesDatabase.tables.notes.count(find({
                to: Id.fromString(userId),
                old: true
            }));
            return { newCount, oldCount };
        },
        async getNewNotes(pagination) {
            const { offset, limit } = runValidation(pagination, validatePagination);
            const { userId } = access.user;
            const newNotes = await notesDatabase.tables.notes.read({
                ...find({
                    to: Id.fromString(userId),
                    old: false
                }),
                offset,
                limit,
                order: { time: "descend" }
            });
            return newNotes.map(note => ({
                type: "message",
                noteId: note.noteId.toString(),
                time: note.time,
                old: note.old,
                from: undefined,
                to: note.to.toString(),
                text: note.text,
                title: note.title,
                details: {},
            }));
        },
        async getOldNotes(pagination) {
            const { offset, limit } = runValidation(pagination, validatePagination);
            const { userId } = access.user;
            const oldNotes = await notesDatabase.tables.notes.read({
                ...find({
                    to: Id.fromString(userId),
                    old: true
                }),
                offset,
                limit,
                order: { time: "descend" }
            });
            return oldNotes.map(note => ({
                type: "message",
                noteId: note.noteId.toString(),
                time: note.time,
                old: note.old,
                from: undefined,
                to: note.to.toString(),
                text: note.text,
                title: note.title,
                details: {},
            }));
        },
        async markAllNotesOld() {
            const { userId } = access.user;
            await notesDatabase.tables.notes.update({
                ...find({
                    to: Id.fromString(userId),
                    old: false,
                }),
                write: { old: true },
            });
        },
        async markNotesNewOrOld(input) {
            const { userId } = access.user;
            const { old, noteIds: noteIdStrings } = runValidation(input, schema({
                old: boolean(),
                noteIds: validator$1(array(), maxLength(1000), each(validateId)),
            }));
            const noteIds = noteIdStrings.map(id => Id.fromString(id));
            const notes = await notesDatabase.tables.notes.read(findAll(noteIds, noteId => ({ noteId })));
            for (const note of notes) {
                if (userId !== note.to.toString())
                    throw new ApiError(403, `user is not privileged for note ${note.to.toString()}`);
            }
            await notesDatabase.tables.notes.update({
                ...findAll(noteIds, noteId => ({ noteId })),
                write: { old }
            });
        }
    }));

    function notesApi({ config, authPolicies }) {
        return api({
            notesService: makeNotesService({
                config,
                basePolicy: authPolicies.userPolicy,
            })
        });
    }

    const goodApiKey = "good";

    const validateDacastApiKey = validator$1(validator$1(string(), minLength(16), maxLength(64), zeroWhitespace()));
    const validateDacastApiKeyAllowingMock = value => value === goodApiKey
        ? []
        : validateDacastApiKey(value);

    function makePrivilegeChecker(permit, privileges) {
        function s(k) {
            return typeof k === "string"
                ? k
                : String(k);
        }
        function hasPrivilege(key) {
            return permit.privileges.includes(privileges[key]);
        }
        function requirePrivilege(key) {
            if (!hasPrivilege(key))
                throw new ApiError(403, `forbidden; privilege required "${s(key)}"`);
        }
        function requireNotHavePrivilege(key) {
            if (hasPrivilege(key))
                throw new ApiError(403, `forbidden: must not have privilege "${s(key)}"`);
        }
        return {
            hasPrivilege,
            requirePrivilege,
            requireNotHavePrivilege,
        };
    }

    function toLinkDisplay(secret) {
        return secret
            ? { time: secret.time }
            : undefined;
    }
    const makeDacastService = ({ config, dacastSdk, basePolicy, }) => service()
        .policy(async (meta, request) => {
        const auth = await basePolicy(meta, request);
        Id.fromString(auth.access.appId);
        const checker = makePrivilegeChecker(auth.access.permit, videoPrivileges);
        checker.requirePrivilege("moderate videos");
        const engine = makePermissionsEngine({
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
            permissionsTables: auth.database.tables.auth.permissions,
        });
        return {
            ...auth,
            checker,
            engine,
        };
    })
        .expose(({ database }) => ({
        async getLink() {
            const secret = await database.tables.videos.dacastAccountLinks.readOne({
                conditions: false,
            });
            return toLinkDisplay(secret);
        },
        async setLink(inputs) {
            const { apiKey } = runValidation(inputs, schema({
                apiKey: validateDacastApiKeyAllowingMock,
            }));
            const good = await dacastSdk.verifyApiKey(apiKey);
            let secret;
            if (good) {
                secret = { apiKey, time: Date.now() };
                await database.tables.videos.dacastAccountLinks.update({
                    conditions: false,
                    upsert: secret,
                });
            }
            return toLinkDisplay(secret);
        },
        async clearLink() {
            await database.tables.videos.dacastAccountLinks.delete({
                conditions: false,
            });
            return undefined;
        },
    }));

    function ingestDacastContent({ type, data, }) {
        var _a, _b;
        const pictures = ((_a = data.pictures) !== null && _a !== void 0 ? _a : []);
        const picture = pictures[0];
        const thumb = picture
            ? ((_b = picture.thumbnail) !== null && _b !== void 0 ? _b : [])[0]
            : undefined;
        return {
            type,
            thumb,
            id: data.id,
            title: data.title,
            provider: "dacast",
        };
    }

    async function getCatalog({ dacast }) {
        const results = await concurrent({
            vods: dacast.vods.get(),
            channels: dacast.channels.get(),
            playlists: dacast.playlists.get(),
        });
        function convert2(type, paginated) {
            var _a;
            return ((_a = paginated === null || paginated === void 0 ? void 0 : paginated.data) !== null && _a !== void 0 ? _a : []).map(data => ingestDacastContent({
                type,
                data,
            }));
        }
        return [
            ...convert2("vod", results.vods),
            ...convert2("channel", results.channels),
            ...convert2("playlist", results.playlists),
        ];
    }

    async function getAllViews({ videoTables }) {
        const viewDacastRows = await videoTables.viewDacast.read({
            conditions: false,
        });
        const viewPrivilegeRows = await videoTables.viewPrivileges.read({
            conditions: false,
        });
        return viewDacastRows.map(dacastRow => {
            const privileges = viewPrivilegeRows
                .filter(privilegeRow => privilegeRow.label === dacastRow.label)
                .map(r => r.privilegeId.toString());
            return {
                label: dacastRow.label,
                privileges,
                reference: {
                    provider: "dacast",
                    type: dacastRow.type,
                    id: dacastRow.dacastId,
                },
            };
        });
    }

    function isPermittedToView({ viewPrivileges, userPrivileges }) {
        for (const requiredPrivilege of viewPrivileges) {
            const userHasPrivilege = userPrivileges
                .find(p => p === requiredPrivilege);
            if (userHasPrivilege)
                return true;
        }
        return false;
    }

    async function getVideoViews({ labels, videoTables, checker, userPrivileges, }) {
        if (labels.length === 0)
            return [];
        const dacastRows = await videoTables.viewDacast.read(findAll(labels, label => ({ label })));
        const privilegeRows = await videoTables.viewPrivileges.read(findAll(labels, label => ({ label })));
        return labels.map(label => {
            const privileges = privilegeRows
                .filter(p => p.label === label)
                .map(p => p.privilegeId.toString());
            const hasExplicitPrivilege = isPermittedToView({
                viewPrivileges: privileges,
                userPrivileges,
            });
            const isPermitted = hasExplicitPrivilege
                || checker.hasPrivilege("view all videos")
                || checker.hasPrivilege("moderate videos");
            const dacastRow = dacastRows.find(r => r.label === label);
            return dacastRow
                ? {
                    label,
                    privileges,
                    reference: isPermitted
                        ? {
                            type: dacastRow.type,
                            id: dacastRow.dacastId,
                            provider: "dacast",
                        }
                        : undefined
                }
                : undefined;
        });
    }

    const embedType = "iframe";
    async function getDacastEmbed({ dacast, reference: { id, type }, }) {
        switch (type) {
            case "vod": return dacast.vods.id(id).embed(embedType).get();
            case "channel": return dacast.channels.id(id).embed(embedType).get();
            case "playlist": return dacast.playlists.id(id).embed(embedType).get();
            default: throw new Error(`unknown dacast type "${type}"`);
        }
    }

    async function getDacastApiKey(videoTables) {
        const link = await videoTables.dacastAccountLinks
            .readOne({ conditions: false });
        return link
            ? link.apiKey
            : undefined;
    }

    async function getAllPrivileges({ access, platformAppId, permissionsTables, }) {
        const permissionsEngine = makePermissionsEngine({
            permissionsTables,
            isPlatform: access.appId === platformAppId
        });
        const permissionsDisplay = await permissionsEngine
            .getPermissionsDisplay();
        return permissionsDisplay.privileges;
    }

    async function getDacastContent({ dacast, reference: { provider, type, id }, }) {
        if (provider !== "dacast")
            throw new ApiError(500, `video content provider mismatch (expected "dacast", got "${provider}")`);
        switch (type) {
            case "vod": return dacast.vods.id(id).get();
            case "channel": return dacast.channels.id(id).get();
            case "playlist": return dacast.playlists.id(id).get();
            default: throw new ApiError(500, `unknown dacast type "${type}"`);
        }
    }

    async function setViewPermissions({ label, engine, videoTables, privileges: privilegesInput, }) {
        // delete all privileges associated with this view
        await videoTables.viewPrivileges.delete(find({ label }));
        // select only privileges that actually exist
        const privileges = await engine.getPrivileges(privilegesInput)
            .then(displays => displays
            .filter(d => !!d)
            .map(d => d.privilegeId.toString()));
        // add new privileges for this view
        await videoTables.viewPrivileges.create(...privileges.map(privilege => ({
            label,
            privilegeId: Id.fromString(privilege),
        })));
    }

    const makeContentService = ({ config, dacastSdk, basePolicy, }) => service()
        .policy(async (meta, headers) => {
        const auth = await basePolicy(meta, headers);
        const checker = makePrivilegeChecker(auth.access.permit, videoPrivileges);
        const engine = makePermissionsEngine({
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
            permissionsTables: auth.database.tables.auth.permissions,
        });
        return {
            ...auth,
            engine,
            checker,
        };
    })
        .expose(({ access, database, checker, engine }) => ({
        async fetchModerationData() {
            checker.requirePrivilege("moderate videos");
            return concurrent({
                views: getAllViews({ videoTables: database.tables.videos }),
                privileges: getAllPrivileges({
                    access,
                    permissionsTables: database.tables.auth.permissions,
                    platformAppId: config.platform.appDetails.appId,
                }),
                catalog: getDacastApiKey(database.tables.videos)
                    .then(async (apiKey) => apiKey
                    ? getCatalog({ dacast: dacastSdk.getClient(apiKey) })
                    : []),
            });
        },
        async writeView({ label, privileges, reference, }) {
            checker.requirePrivilege("moderate videos");
            await database.tables.videos.viewDacast.update({
                ...find({ label }),
                whole: {
                    label,
                    type: reference.type,
                    dacastId: reference.id,
                },
            });
            await setViewPermissions({
                label,
                engine,
                privileges,
                videoTables: database.tables.videos,
            });
        },
        async deleteView({ label }) {
            checker.requirePrivilege("moderate videos");
            await database.tables.videos.viewDacast.delete(find({ label }));
            await database.tables.videos.viewPrivileges.delete(find({ label }));
        },
        async getShows({ labels }) {
            const apiKey = await getDacastApiKey(database.tables.videos);
            if (!apiKey)
                return [];
            const views = await getVideoViews({
                labels,
                checker,
                videoTables: database.tables.videos,
                userPrivileges: access.permit.privileges,
            });
            const dacast = dacastSdk.getClient(apiKey);
            return Promise.all(views.map(async (view, index) => {
                const label = labels[index];
                let status = view
                    ? view.reference
                        ? "available"
                        : "unprivileged"
                    : "unavailable";
                let details;
                if (view === null || view === void 0 ? void 0 : view.reference) {
                    const [data, embed] = await Promise.all([
                        getDacastContent({ dacast, reference: view.reference }),
                        getDacastEmbed({ dacast, reference: view.reference }),
                    ]);
                    if (data) {
                        status = "available";
                        details = {
                            ...ingestDacastContent({
                                type: view.reference.type,
                                data,
                            }),
                            embed: embed === null || embed === void 0 ? void 0 : embed.code,
                        };
                    }
                    else {
                        status = "unavailable";
                    }
                }
                return { label, status, details };
            }));
        },
    }));

    function videosApi({ config, authPolicies, dacastSdk, }) {
        const options = {
            config,
            basePolicy: authPolicies.anonPolicy,
        };
        return api({
            dacastService: makeDacastService({
                ...options,
                dacastSdk,
            }),
            contentService: makeContentService({
                ...options,
                dacastSdk,
            }),
        });
    }

    const makeExampleService = ({ rando, authPolicies, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        return {
            ...auth,
            database: subsection(auth.database, tables => tables.example),
        };
    })
        .expose(({ database }) => ({
        async exampleFunction({ something }) {
            await database.tables.examplePosts.create({
                exampleId: rando.randomId(),
                something,
            });
        },
    }));

    function exampleApi(options) {
        return api({
            exampleService: makeExampleService(options),
        });
    }

    async function makeVotingBooth({ userId, itemIds, likesTable, reportsTable }) {
        const likes = await makeVoteCounter({ itemIds, voteTable: likesTable });
        const reports = await makeVoteCounter({ itemIds, voteTable: reportsTable });
        return {
            getVotingDetails(itemId) {
                return {
                    likes: likes.countVotes(itemId),
                    reports: reports.countVotes(itemId),
                    liked: userId
                        ? likes.voteStatus({ userId, itemId })
                        : false,
                    reported: userId
                        ? reports.voteStatus({ userId, itemId })
                        : false,
                };
            }
        };
    }
    async function makeVoteCounter({ itemIds, voteTable }) {
        const votes = itemIds.length
            ? await voteTable.read(findAll(itemIds, itemId => ({ itemId })))
            : [];
        return {
            countVotes(itemId) {
                return votes
                    .filter(vote => vote.itemId.toString() === itemId.toString())
                    .length;
            },
            voteStatus({ userId, itemId }) {
                const votesByUser = votes
                    .filter(vote => vote.userId.toString() === userId.toString());
                const userVotedForItem = !!votesByUser
                    .find(vote => vote.itemId.toString() === itemId.toString());
                return userVotedForItem;
            },
        };
    }

    async function resolveQuestions({ userId, questionPosts, questionsTables }) {
        const questionIds = questionPosts.map(post => post.questionId);
        const answerPosts = questionIds.length
            ? await questionsTables.answerPosts
                .read(findAll(questionIds, questionId => ({ questionId, archive: false })))
            : [];
        const answerIds = answerPosts.map(post => post.answerId);
        const boothDetails = {
            userId,
            likesTable: questionsTables.likes,
            reportsTable: questionsTables.reports,
        };
        const questionsVotingBooth = await makeVotingBooth({
            ...boothDetails,
            itemIds: questionIds,
        });
        const answersVotingBooth = await makeVotingBooth({
            ...boothDetails,
            itemIds: answerIds,
        });
        return questionIds.map(questionId => {
            const questionPost = questionPosts.find(post => post.questionId === questionId);
            const question = {
                archive: questionPost.archive,
                authorUserId: questionPost.authorUserId.toString(),
                questionId: questionPost.questionId.toString(),
                board: questionPost.board,
                content: questionPost.content,
                timePosted: questionPost.timePosted,
                ...questionsVotingBooth.getVotingDetails(questionId),
                answers: answerPosts
                    .filter(answer => answer.questionId.toString() === questionId.toString())
                    .map(answerPost => ({
                    answerId: answerPost.answerId.toString(),
                    questionId: answerPost.questionId.toString(),
                    authorUserId: answerPost.authorUserId.toString(),
                    content: answerPost.content,
                    archive: answerPost.archive,
                    timePosted: answerPost.timePosted,
                    ...answersVotingBooth.getVotingDetails(answerPost.answerId),
                })),
            };
            return question;
        });
    }

    function anonQuestionsPolicy({ authPolicies, }) {
        return async (meta, headers) => {
            const auth = await authPolicies.anonPolicy(meta, headers);
            return {
                ...auth,
                database: subsection(auth.database, tables => ({
                    auth: tables.auth,
                    questions: tables.questions
                })),
            };
        };
    }
    function authenticatedQuestionsPolicy({ authPolicies, }) {
        return async (meta, headers) => {
            const auth = await authPolicies.userPolicy(meta, headers);
            return {
                ...auth,
                database: subsection(auth.database, tables => ({
                    auth: tables.auth,
                    questions: tables.questions
                })),
            };
        };
    }

    const makeQuestionsReadingService = (options) => service()
        .policy(async (meta, request) => {
        const auth = await anonQuestionsPolicy(options)(meta, request);
        auth.checker.requirePrivilege("read questions");
        return auth;
    })
        .expose(({ access, database }) => ({
        async fetchQuestions({ board }) {
            var _a;
            const posts = await database.tables.questions.questionPosts.read({
                ...find({ board, archive: false }),
                limit: 100,
                offset: 0,
                order: { timePosted: "descend" },
            });
            if (!posts.length)
                return { users: [], questions: [] };
            const resolvedQuestions = await resolveQuestions({
                questionsTables: database.tables.questions,
                questionPosts: posts,
                userId: ((_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId)
                    ? Id.fromString(access.user.userId)
                    : undefined,
            });
            const userIds = (() => {
                const ids = [];
                const rememberUserId = (userId) => {
                    if (!ids.includes(userId))
                        ids.push(userId);
                };
                for (const question of resolvedQuestions) {
                    rememberUserId(question.authorUserId);
                    for (const answer of question.answers)
                        rememberUserId(answer.authorUserId);
                }
                return ids;
            })();
            const permissionsEngine = makePermissionsEngine({
                permissionsTables: database.tables.auth.permissions,
                isPlatform: access.appId === options.config.platform.appDetails.appId,
            });
            const bannedUserIds = (await permissionsEngine.getPrivilegesForUsers(userIds))
                .filter(p => p.privileges.includes(appPermissions.privileges["banned"]))
                .map(p => p.userId);
            const users = (await fetchUsers({
                authTables: database.tables.auth,
                permissionsEngine,
                userIds: userIds.map(id => Id.fromString(id)),
            }))
                .filter(u => !bannedUserIds.includes(u.userId));
            const questions = resolvedQuestions
                .filter(q => !bannedUserIds.includes(q.authorUserId.toString()))
                .map(q => ({
                ...q,
                answers: q.answers.filter(a => !bannedUserIds.includes(a.authorUserId))
            }));
            return { users, questions };
        },
    }));

    async function vote({ status, userId, itemId, voteTable }) {
        const previousVote = await voteTable.count(find({ userId, itemId }))
            > 0;
        const addVote = () => voteTable.create({ userId, itemId });
        const removeVote = () => voteTable.delete(find({ userId, itemId }));
        if (!previousVote && status)
            await addVote();
        else if (previousVote && !status)
            await removeVote();
    }

    const timeframe = 1 * day;
    const allowedNumberOfPostsInTimeframe = 10;
    async function rateLimitQuestions({ userId, database }) {
        const count = await database.tables.questions.questionPosts.count({
            conditions: and({ equal: { authorUserId: userId, archive: false } }, { greater: { timePosted: Date.now() - timeframe } })
        });
        if (count > allowedNumberOfPostsInTimeframe)
            throw new ApiError(429, "too many posts");
    }
    async function rateLimitAnswers({ userId, questionId, database }) {
        const count = await database.tables.questions.answerPosts.count({
            conditions: and({ equal: { authorUserId: userId, questionId, archive: false } }, { greater: { timePosted: Date.now() - timeframe } })
        });
        if (count > allowedNumberOfPostsInTimeframe)
            throw new ApiError(429, "too many posts");
    }

    const validatePostContent = validator$1(string(), minLength(10), maxLength(280), notWhitespace());
    const validateQuestionDraft = schema({
        board: validator$1(string(), minLength(1), maxLength(32), notWhitespace()),
        content: validatePostContent,
    });
    const validateAnswerDraft = schema({
        content: validatePostContent,
    });

    function requireUserCanEditQuestion({ userId, questionPost, checker }) {
        const userIsModerator = checker.hasPrivilege("moderate questions");
        const userIsOwner = questionPost.authorUserId.toString() === userId;
        const isAllowed = userIsModerator || userIsOwner;
        if (!isAllowed)
            throw new Error(`user is not authorized to edit question`);
    }

    const makeQuestionsPostingService = (options) => service()
        .policy(async (meta, headers) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, headers);
        auth.checker.requireNotHavePrivilege("banned");
        const canPostQuestions = auth.checker.hasPrivilege("post questions");
        const isModerator = auth.checker.hasPrivilege("moderate questions");
        const allowed = canPostQuestions || isModerator;
        if (!allowed)
            throw new ApiError(403, "not allowed to post questions");
        return auth;
    })
        .expose(({ access, database, checker }) => ({
        async postQuestion(inputs) {
            const { questionDraft } = runValidation(inputs, schema({
                questionDraft: validateQuestionDraft,
            }));
            await rateLimitQuestions({
                database,
                userId: Id.fromString(access.user.userId),
            });
            const row = {
                questionId: options.rando.randomId(),
                authorUserId: Id.fromString(access.user.userId),
                archive: false,
                timePosted: Date.now(),
                ...questionDraft,
            };
            await database.tables.questions.questionPosts.create(row);
            return {
                archive: row.archive,
                authorUserId: row.authorUserId.toString(),
                questionId: row.questionId.toString(),
                content: row.content,
                timePosted: row.timePosted,
                board: row.board,
                likes: 0,
                reports: 0,
                liked: false,
                reported: false,
                answers: [],
            };
        },
        async archiveQuestion(inputs) {
            const { archive, questionId: questionIdString } = runValidation(inputs, schema({
                archive: boolean(),
                questionId: validateId,
            }));
            const questionId = Id.fromString(questionIdString);
            const questionPost = await database.tables.questions.questionPosts
                .readOne(find({ questionId }));
            requireUserCanEditQuestion({ userId: access.user.userId, checker, questionPost });
            await database.tables.questions.questionPosts.update({
                ...find({ questionId }),
                write: { archive: !!archive },
            });
        },
        async likeQuestion(inputs) {
            const { like, questionId: questionIdString } = runValidation(inputs, schema({
                like: boolean(),
                questionId: validateId,
            }));
            checker.requirePrivilege("like questions");
            await vote({
                status: like,
                voteTable: database.tables.questions.likes,
                userId: Id.fromString(access.user.userId),
                itemId: Id.fromString(questionIdString),
            });
        },
        async reportQuestion(inputs) {
            const { report, questionId: questionIdString } = runValidation(inputs, schema({
                report: boolean(),
                questionId: validateId,
            }));
            checker.requirePrivilege("report questions");
            await vote({
                status: report,
                voteTable: database.tables.questions.reports,
                userId: Id.fromString(access.user.userId),
                itemId: Id.fromString(questionIdString),
            });
        },
    }));

    function requireUserCanEditAnswer({ userId, answerPost, checker }) {
        const userIsModerator = checker.hasPrivilege("moderate questions");
        const userIsOwner = answerPost.authorUserId.toString() === userId;
        const isAllowed = userIsModerator || userIsOwner;
        if (!isAllowed)
            throw new Error(`user is not authorized to edit answer`);
    }

    const makeQuestionsAnsweringService = (options) => service()
        .policy(async (meta, request) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, request);
        auth.checker.requireNotHavePrivilege("banned");
        const canPostQuestions = auth.checker.hasPrivilege("answer questions");
        const isModerator = auth.checker.hasPrivilege("moderate questions");
        const allowed = canPostQuestions || isModerator;
        if (!allowed)
            throw new ApiError(403, "not allowed to post questions");
        return auth;
    })
        .expose(({ access, database, checker }) => ({
        async postAnswer(inputs) {
            const { questionId: questionIdString, answerDraft } = runValidation(inputs, schema({
                questionId: validateId,
                answerDraft: validateAnswerDraft,
            }));
            const questionId = Id.fromString(questionIdString);
            const questionPost = await database.tables.questions.questionPosts
                .readOne(find({ questionId }));
            if (!questionPost)
                throw new ApiError(400, "unknown questionId");
            const userId = Id.fromString(access.user.userId);
            await rateLimitAnswers({
                userId,
                database,
                questionId,
            });
            const row = {
                questionId,
                answerId: options.rando.randomId(),
                authorUserId: userId,
                archive: false,
                timePosted: Date.now(),
                board: questionPost.board,
                ...answerDraft,
            };
            await database.tables.questions.answerPosts.create(row);
            const answer = {
                answerId: row.answerId.toString(),
                questionId: row.questionId.toString(),
                authorUserId: row.authorUserId.toString(),
                content: row.content,
                timePosted: row.timePosted,
                liked: false,
                likes: 0,
                archive: false,
                reported: false,
                reports: 0,
            };
            return answer;
        },
        async archiveAnswer(inputs) {
            const { archive, answerId: answerIdString } = runValidation(inputs, schema({
                archive: boolean(),
                answerId: validateId,
            }));
            const answerId = Id.fromString(answerIdString);
            const answerPost = await database.tables.questions.answerPosts.readOne(find({ answerId }));
            requireUserCanEditAnswer({ userId: access.user.userId, checker, answerPost });
            await database.tables.questions.answerPosts.update({
                ...find({ answerId }),
                write: { archive },
            });
        },
        async likeAnswer(inputs) {
            const { like, answerId: answerIdString } = runValidation(inputs, schema({
                like: boolean(),
                answerId: validateId,
            }));
            checker.requirePrivilege("like questions");
            await vote({
                status: like,
                voteTable: database.tables.questions.likes,
                userId: Id.fromString(access.user.userId),
                itemId: Id.fromString(answerIdString),
            });
        },
        async reportAnswer(inputs) {
            const { report, answerId: answerIdString } = runValidation(inputs, schema({
                report: boolean(),
                answerId: validateId,
            }));
            checker.requirePrivilege("report questions");
            await vote({
                status: report,
                voteTable: database.tables.questions.reports,
                userId: Id.fromString(access.user.userId),
                itemId: Id.fromString(answerIdString),
            });
        },
    }));

    const makeQuestionsModerationService = (options) => service()
        .policy(async (meta, headers) => {
        const auth = await authenticatedQuestionsPolicy(options)(meta, headers);
        auth.checker.requirePrivilege("moderate questions");
        auth.checker.requireNotHavePrivilege("banned");
        return auth;
    })
        .expose(({ database }) => ({
        async archiveBoard({ board }) {
            await database.tables.questions.questionPosts.update({
                ...find({ board }),
                write: { archive: true },
            });
        },
        async fetchReportedQuestions() { },
    }));

    function questionsApi(options) {
        return api({
            questionsReadingService: makeQuestionsReadingService(options),
            questionsPostingService: makeQuestionsPostingService(options),
            questionsAnsweringService: makeQuestionsAnsweringService(options),
            questionsModerationService: makeQuestionsModerationService(options),
        });
    }

    function prepareStatsHub({ database }) {
        return async function getStatsHub(userId) {
            async function throwForbiddenUser(appId) {
                const row = await database.tables.apps.owners.readOne(find({ appId }));
                if (row.userId.toString() !== userId.toString())
                    throw new ApiError(403, "forbidden");
            }
            return {
                countUsers: async (appId) => {
                    await throwForbiddenUser(appId);
                    const accountsTable = database.tables.auth.users.accounts
                        .constrainForApp(appId);
                    return accountsTable.count({ conditions: false });
                },
                countUsersActiveDaily: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - day;
                    const latestLoginsTable = database.tables.auth.users.latestLogins
                        .constrainForApp(appId);
                    return latestLoginsTable.count({
                        conditions: and({ greater: { time: timeToStartCounting } }),
                    });
                },
                countUsersActiveMonthly: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - month;
                    const latestLoginsTable = database.tables.auth.users.latestLogins
                        .constrainForApp(appId);
                    return latestLoginsTable.count({
                        conditions: and({ greater: { time: timeToStartCounting } }),
                    });
                },
            };
        };
    }

    async function isUserOwnerOfApp({ appId, access, appTables }) {
        const { userId: userIdString } = access.user;
        const userId = Id.fromString(userIdString);
        const ownershipRow = await appTables.owners.readOne(find({ userId, appId }));
        return !!ownershipRow;
    }

    function prepareAuthPolicies({ config, databaseRaw, verifyToken, }) {
        const getStatsHub = prepareStatsHub({ database: databaseRaw });
        const greenPolicy = async (meta) => ({
            databaseRaw,
        });
        const anonPolicy = async ({ accessToken }, headers) => {
            const access = await verifyToken(accessToken);
            if (access.origins.some(origin => origin === headers.origin))
                return {
                    access,
                    database: UnconstrainedTable.constrainDatabaseForApp({
                        appId: Id.fromString(access.appId),
                        database: databaseRaw,
                    }),
                    checker: makePrivilegeChecker(access.permit, appPermissions.privileges),
                };
            else
                throw new ApiError(403, `request origin not allowed: ${headers.origin}`);
        };
        const userPolicy = async (meta, headers) => {
            const auth = await anonPolicy(meta, headers);
            if (auth.access.user)
                return auth;
            else
                throw new ApiError(403, "not logged in");
        };
        const platformUserPolicy = async (meta, headers) => {
            const auth = await userPolicy(meta, headers);
            const userId = Id.fromString(auth.access.user.userId);
            if (auth.access.appId === config.platform.appDetails.appId) {
                return {
                    ...auth,
                    databaseRaw,
                    checker: makePrivilegeChecker(auth.access.permit, platformPermissions.privileges),
                    statsHub: await getStatsHub(userId),
                };
            }
            else
                throw new ApiError(403, "not platform app");
        };
        const appOwnerPolicy = async (meta, headers) => {
            const auth = await platformUserPolicy(meta, headers);
            const appTables = databaseRaw.tables.apps;
            return {
                access: auth.access,
                database: auth.database,
                checker: auth.checker,
                statsHub: auth.statsHub,
                databaseRaw,
                async authorizeAppOwner(appId) {
                    const allowedToEditAnyApp = auth.checker.hasPrivilege("edit any app");
                    const isOwnerOfApp = isUserOwnerOfApp({ appId, appTables, access: auth.access });
                    const allowed = isOwnerOfApp || allowedToEditAnyApp;
                    if (allowed)
                        return UnconstrainedTable.constrainDatabaseForApp({
                            appId,
                            database: databaseRaw,
                        });
                    else
                        throw new ApiError(403, "forbidden: lacking privileges to edit app");
                },
            };
        };
        return {
            greenPolicy,
            anonPolicy,
            userPolicy,
            platformUserPolicy,
            appOwnerPolicy,
        };
    }

    function escapeRegex(subject) {
        return subject.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }

    const validateTimeframe = branch(notDefined(), number());

    const validateUserSearchTerm = validator$1(string(), minLength(1), maxLength(64));

    const makeRoleAssignmentService = ({ config, authPolicies, }) => service()
        .policy(async (meta, headers) => {
        const auth = await authPolicies.userPolicy(meta, headers);
        auth.checker.requirePrivilege("administrate user roles");
        const engine = makePermissionsEngine({
            permissionsTables: auth.database.tables.auth.permissions,
            isPlatform: auth.access.appId === config.platform.appDetails.appId,
        });
        return { ...auth, engine };
    })
        .expose(({ engine, database }) => ({
        async fetchPermissions() {
            return engine.getPermissionsDisplay();
        },
        async searchUsers(options) {
            const { term } = runValidation(options, schema({
                term: validateUserSearchTerm,
            }));
            const regex = new RegExp(escapeRegex(term), "i");
            const profiles = await database.tables.auth.users.profiles.read({
                limit: 100,
                conditions: Id.isId(term)
                    ? or({ equal: { userId: Id.fromString(term) } })
                    : or({ search: { nickname: regex } }, { search: { tagline: regex } })
            });
            const userIds = profiles.map(profile => profile.userId);
            if (!userIds.length)
                return [];
            const users = await fetchUsers({
                userIds,
                permissionsEngine: engine,
                authTables: database.tables.auth,
            });
            const usersAndRoles = await engine.getUsersHaveRoles({
                userIds: users.map(user => user.userId),
                onlyGetPublicRoles: false,
            });
            return users.map(user => ({
                user,
                roleIds: usersAndRoles
                    .find(u => u.userId === user.userId)
                    .userHasRoles
                    .map(role => role.roleId.toString())
            }));
        },
        async assignRoleToUser(options) {
            const { roleId: roleIdString, userId: userIdString, isPublic, timeframeEnd, timeframeStart } = (runValidation(options, schema({
                roleId: validateId,
                userId: validateId,
                isPublic: boolean(),
                timeframeEnd: validateTimeframe,
                timeframeStart: validateTimeframe,
            })));
            const roleId = Id.fromString(roleIdString);
            const userId = Id.fromString(userIdString);
            const existing = await database.tables.auth.permissions.userHasRole.readOne(find({
                userId,
                roleId,
            }));
            if (existing === null || existing === void 0 ? void 0 : existing.hard)
                throw new ApiError(400, "hard role assignment cannot be overwritten");
            else
                await assert(database.tables.auth.permissions.userHasRole, find({ roleId, userId }), async () => ({
                    hard: false,
                    public: isPublic,
                    roleId,
                    userId,
                    timeframeEnd,
                    timeframeStart,
                    time: Date.now(),
                }));
        },
        async revokeRoleFromUser(options) {
            const { roleId: roleIdString, userId: userIdString } = runValidation(options, schema({
                roleId: validateId,
                userId: validateId,
            }));
            const roleId = Id.fromString(roleIdString);
            const userId = Id.fromString(userIdString);
            const existing = await database.tables.auth.permissions.userHasRole.readOne(find({
                userId,
                roleId,
            }));
            if (existing === null || existing === void 0 ? void 0 : existing.hard)
                throw new ApiError(400, "hard role assignment cannot be overwritten");
            else
                await database.tables.auth.permissions.userHasRole.delete({
                    conditions: or({ equal: { roleId, userId } }),
                });
        },
    }));

    function makeAdministrativeApi(options) {
        return api({
            roleAssignmentService: makeRoleAssignmentService(options),
        });
    }

    const colors = [
        "Red",
        "Yellow",
        "Green",
        "Cyan",
        "Blue",
        "Magenta",
        "Dark",
        "Grey",
        "Silver",
        "Bright",
        "Light",
        "Gold",
        "Golden",
        "Aqua",
        "Minty",
    ];

    const animals = [
        "Aardvark",
        "Mongoose",
        "Alligator",
        "Robin",
        "Monkey",
        "Seahorse",
        "Shark",
        "Leopard",
        "Eagle",
        "Raven",
        "Owl",
        "Hawk",
        "Duck",
        "Wolf",
        "Coyote",
        "Dingo",
        "Ostrich",
        "Llama",
        "Alpaca",
        "Zebra",
        "Bear",
        "Kiwi",
        "Penguin",
        "Otter",
        "Dolphin",
        "Starfish",
        "Sunfish",
        "Salmon",
        "Swordfish",
        "Sparrow",
        "Turtle",
        "Puppy",
        "Kitten",
    ];

    const adjectives = [
        "Funny",
        "Charming",
        "Wonderful",
        "Fancy",
        "Whimsical",
        "Gregarious",
        "Curious",
        "Fabulous",
        "Saavy",
        "Groovy",
        "Happy",
        "Snappy",
        "Quick",
        "Super",
        "Fast",
        "Fuzzy",
        "Clever",
        "Genius",
        "Marvelous",
        "Eccentric",
        "Fantastic",
        "Quaint",
        "Young",
        "Wise",
        "Creative",
        "Helpful",
        "Nice",
        "Sincere",
        "Loyal",
        "Honest",
        "Truthful",
        "Thoughtful",
        "Clean",
        "Friendly",
        "Gentle",
        "Pleasant",
        "Brilliant",
        "Polite",
        "Original",
        "Ambitious",
        "Lively",
        "Wholesome",
        "Cordial",
        "Eager",
        "Relaxed",
        "Skilled",
        "Tidy",
        "Calm",
        "Hopeful",
        "Positive",
        "Social",
        "Quick",
        "Fearless",
        "Daring",
        "Bold",
        "Quiet",
    ];

    const standardDictionary = {
        colors,
        animals,
        adjectives,
    };

    function makeNicknameGenerator({ rando, delimiter, dictionary, nicknameStructure, }) {
        const nicknameData = nicknameStructure.map(dictionarySet => dictionarySet.reduce((previous, wordGroupName) => [
            ...previous,
            ...dictionary[wordGroupName],
        ], []));
        return () => nicknameData
            .map(names => rando.randomSample(names))
            .join(delimiter);
    }

    function standardNicknameGenerator({ rando }) {
        return makeNicknameGenerator({
            rando,
            delimiter: " ",
            dictionary: standardDictionary,
            nicknameStructure: [["adjectives", "colors"], ["animals"]],
        });
    }

    async function fetchStripeConnectDetails({ storeDatabaseUnconnected }) {
        const active = await storeDatabaseUnconnected
            .tables
            .connect
            .active
            .readOne({ conditions: false });
        if (!active)
            return {
                connectDetails: undefined,
                connectId: undefined,
            };
        const account = await storeDatabaseUnconnected
            .tables
            .connect
            .accounts
            .readOne(find({ connectId: active.connectId }));
        const connectDetails = {
            userId: account.userId.string,
            stripeAccountId: account.stripeAccountId,
            email: account.email,
            paused: account.paused,
            timeLinked: account.time,
            payouts_enabled: account.payouts_enabled,
            charges_enabled: account.charges_enabled,
            details_submitted: account.details_submitted,
        };
        return {
            connectDetails,
            connectId: active.connectId,
        };
    }

    function getConnectedStoreDatabase({ tables, transaction, }, connectId) {
        const constraint = { connectId };
        return {
            tables: constrainStoreTables(tables, constraint),
            transaction: (async (action) => transaction(async ({ tables: t2, ...more }) => action({
                tables: constrainStoreTables(t2, constraint),
                ...more
            }))),
        };
    }
    function constrainStoreTables(tables, constraint) {
        const { connect, ...tablesThatShouldBeConstrained } = tables;
        return {
            connect,
            ...constrainTables({
                constraint,
                tables: tablesThatShouldBeConstrained,
            }),
        };
    }

    function determineConnectStatus(details) {
        return details
            ? isStripeAccountComplete(details)
                ? details.paused
                    ? StripeConnectStatus.Paused
                    : StripeConnectStatus.Ready
                : StripeConnectStatus.Incomplete
            : StripeConnectStatus.Unlinked;
    }
    function isStripeAccountComplete(details) {
        return details.details_submitted
            && details.charges_enabled;
    }

    const getStripeId = (x) => {
        return x && (typeof x === "string"
            ? x
            : x.id);
    };

    function derivePricingFromStripePrice(stripePrice) {
        return {
            stripePriceId: stripePrice.id,
            price: stripePrice.unit_amount,
            currency: stripePrice.currency,
            interval: stripePrice.recurring.interval
        };
    }

    function isStripePriceValidForSubscriptionUsage(stripePrice) {
        var _a, _b, _c;
        const conditions = [
            (stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.active),
            (stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.recurring),
            (((_a = stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.recurring) === null || _a === void 0 ? void 0 : _a.usage_type) === "licensed"),
            (((_b = stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.recurring) === null || _b === void 0 ? void 0 : _b.interval) === "month" ||
                ((_c = stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.recurring) === null || _c === void 0 ? void 0 : _c.interval) === "year"),
        ];
        const failure = conditions.some(condition => !condition);
        return !failure;
    }

    function buildFinalTierObject(tierRow, stripePrice, stripeProduct) {
        return {
            tierId: tierRow.tierId.string,
            roleId: tierRow.roleId.string,
            label: stripeProduct.name,
            time: tierRow.time,
            active: stripeProduct.active,
            pricing: isStripePriceValidForSubscriptionUsage(stripePrice)
                ? [derivePricingFromStripePrice(stripePrice)]
                : undefined
        };
    }

    const helpersForManagingSubscriptions = ({ storeDatabase, stripeLiaisonAccount, roleManager, generateId, }) => {
        const storeTables = storeDatabase.tables;
        async function createStripeProductAndPriceResources({ productLabel, pricing }) {
            const { id: stripeProductId } = await stripeLiaisonAccount
                .products
                .create({ name: productLabel });
            const { id: stripePriceId } = await stripeLiaisonAccount
                .prices
                .create({
                active: true,
                product: stripeProductId,
                currency: pricing.currency,
                unit_amount: pricing.price,
                recurring: { interval: pricing.interval },
            });
            await stripeLiaisonAccount
                .products
                .update(stripeProductId, { default_price: stripePriceId });
            return { stripeProductId, stripePriceId };
        }
        return {
            async createPlanAndTier({ planLabel, tier }) {
                const planId = generateId();
                const tierId = generateId();
                const { roleId } = await roleManager
                    .createPrivateSystemRole({
                    label: tier.label,
                });
                await storeTables
                    .subscriptions
                    .plans
                    .create({
                    planId,
                    label: planLabel,
                    time: Date.now(),
                    archived: false,
                });
                const { stripeProductId, stripePriceId } = await createStripeProductAndPriceResources({
                    productLabel: tier.label,
                    pricing: tier.pricing,
                });
                await storeTables
                    .subscriptions
                    .tiers
                    .create({
                    tierId,
                    planId,
                    roleId,
                    time: Date.now(),
                    stripeProductId,
                });
                return {
                    planId,
                    tierId,
                    stripePriceId,
                    tierRoleId: roleId,
                    time: Date.now(),
                };
            },
            async createTierForPlan({ planId, label, pricing }) {
                const planRow = await storeTables
                    .subscriptions
                    .plans
                    .readOne(find({ planId: Id.fromString(planId) }));
                if (!planRow)
                    throw new Error(`unknown subscription plan ${planId}`);
                const { stripeProductId, stripePriceId } = await createStripeProductAndPriceResources({
                    productLabel: label,
                    pricing,
                });
                const { roleId } = await roleManager.createPrivateSystemRole({ label });
                const time = Date.now();
                const tierId = generateId();
                await storeTables
                    .subscriptions
                    .tiers
                    .create({
                    time,
                    tierId,
                    roleId,
                    stripeProductId,
                    planId: planRow.planId,
                });
                return { tierId, roleId, time, stripePriceId };
            },
            async updatePlan({ planId: planIdString, label, archived }) {
                const planId = Id.fromString(planIdString);
                const planRow = await storeTables
                    .subscriptions
                    .plans
                    .readOne(find({ planId }));
                if (!planRow)
                    throw new ApiError(400, `unable to find plan ${planIdString}`);
                await storeTables
                    .subscriptions
                    .plans
                    .update({
                    ...find({ planId }),
                    write: { label, archived },
                });
            },
            async updateTier({ tierId: tierIdString, label, active, pricing }) {
                const tierId = Id.fromString(tierIdString);
                const tierRow = await storeTables
                    .subscriptions
                    .tiers
                    .readOne(find({ tierId }));
                if (!tierRow)
                    throw new ApiError(400, `tier not found ${tierIdString}`);
                const roleRow = await roleManager.readRole(tierRow.roleId);
                if (!roleRow)
                    throw new ApiError(400, `role not found ${tierRow.roleId.string}`);
                let { stripeProductId } = tierRow;
                let stripeProduct = await stripeLiaisonAccount
                    .products
                    .retrieve(stripeProductId);
                if (!stripeProduct)
                    throw new ApiError(500, `stripe product not found ${stripeProductId}`);
                const stripePriceId = getStripeId(stripeProduct.default_price);
                let stripePrice = undefined;
                if (stripePriceId)
                    stripePrice = await stripeLiaisonAccount
                        .prices
                        .retrieve(stripePriceId);
                const isPricingDifferent = (pricing.price !== (stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.unit_amount) ||
                    pricing.currency !== (stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.currency) ||
                    pricing.interval !== (stripePrice === null || stripePrice === void 0 ? void 0 : stripePrice.recurring.interval));
                if (!stripePrice || isPricingDifferent) {
                    stripePrice = await stripeLiaisonAccount
                        .prices
                        .create({
                        active,
                        product: stripeProductId,
                        currency: pricing.currency,
                        unit_amount: pricing.price,
                        recurring: { interval: pricing.interval },
                    });
                    stripeProduct = await stripeLiaisonAccount
                        .products
                        .update(stripeProductId, { default_price: stripePrice.id });
                }
                const isLabelDifferent = label !== stripeProduct.name;
                const isActiveDifferent = active !== stripeProduct.active;
                if (isLabelDifferent || isActiveDifferent)
                    stripeProduct = await stripeLiaisonAccount
                        .products
                        .update(stripeProductId, { active, name: label });
                await roleManager.updateRole({
                    label,
                    roleId: tierRow.roleId,
                });
                const newTier = buildFinalTierObject(tierRow, stripePrice, stripeProduct);
                return newTier;
            },
        };
    };

    function makeStorePolicies(options) {
        const { stripeLiaison, anonPolicy } = options;
        async function connected(meta, headers) {
            const auth = await anonPolicy(meta, headers);
            const { connectId, connectDetails } = await fetchStripeConnectDetails(auth);
            const connectStatus = determineConnectStatus(connectDetails);
            if (connectStatus !== StripeConnectStatus.Ready)
                throw new ApiError(400, "stripe account is not connected, and this action requires it");
            const { stripeAccountId } = connectDetails;
            const stripeLiaisonAccount = stripeLiaison.account(stripeAccountId);
            const storeDatabase = getConnectedStoreDatabase(auth.storeDatabaseUnconnected, connectId);
            return {
                ...auth,
                connectId,
                stripeAccountId,
                stripeLiaisonAccount,
                storeDatabase,
            };
        }
        async function customer(meta, headers) {
            const auth = await connected(meta, headers);
            if (!auth.access.user)
                throw new ApiError(400, "user must be logged in");
            const userId = Id.fromString(auth.access.user.userId);
            let customerRow = await auth
                .storeDatabase
                .tables
                .customers
                .readOne(find({ userId }));
            if (!customerRow) {
                const { id: stripeCustomerId } = await auth
                    .stripeLiaisonAccount
                    .customers
                    .create({});
                customerRow = {
                    userId,
                    stripeCustomerId,
                };
                await auth
                    .storeDatabase
                    .tables
                    .customers
                    .create(customerRow);
            }
            const { stripeCustomerId } = customerRow;
            return {
                ...auth,
                stripeCustomerId,
            };
        }
        async function merchant(meta, headers) {
            const auth = await connected(meta, headers);
            auth.checker.requirePrivilege("manage store");
            const { connectDetails } = await fetchStripeConnectDetails(auth);
            const connectStatus = determineConnectStatus(connectDetails);
            if (connectStatus !== StripeConnectStatus.Ready)
                throw new ApiError(400, "stripe connect status not ready");
            const helpers = helpersForManagingSubscriptions({
                ...options,
                ...auth,
            });
            return { ...auth, helpers };
        }
        return {
            guest: anonPolicy,
            connected,
            customer,
            merchant,
        };
    }

    function derivePaymentMethod(method) {
        const { card } = method !== null && method !== void 0 ? method : {};
        return card
            ? {
                cardClues: {
                    brand: card.brand,
                    country: card.country,
                    expireMonth: card.exp_month,
                    expireYear: card.exp_year,
                    last4: card.last4,
                },
            }
            : undefined;
    }

    function encodeQuerystring(result) {
        const searchParams = new URLSearchParams({ ...result });
        return searchParams.toString();
    }

    var makeStripePopupSpec;
    (function (makeStripePopupSpec) {
        function connect({ popupReturnUrl, generateId }) {
            const popupId = generateId().string;
            return {
                popupId,
                return_url: `${popupReturnUrl}?${encodeQuerystring({
                popupId,
                status: "return",
            })}`,
                refresh_url: `${popupReturnUrl}?${encodeQuerystring({
                popupId,
                status: "refresh",
            })}`,
            };
        }
        makeStripePopupSpec.connect = connect;
        function login({ generateId }) {
            return { popupId: generateId().string };
        }
        makeStripePopupSpec.login = login;
        function openCustomerPortal({ generateId, popupReturnUrl }) {
            const popupId = generateId().string;
            return {
                popupId,
                return_url: `${popupReturnUrl}?${encodeQuerystring({
                popupId,
                status: "return",
            })}`
            };
        }
        makeStripePopupSpec.openCustomerPortal = openCustomerPortal;
        function checkout({ popupReturnUrl, generateId }) {
            const popupId = generateId().string;
            return {
                popupId,
                success_url: `${popupReturnUrl}?${encodeQuerystring({
                popupId,
                status: "success",
            })}`,
                cancel_url: `${popupReturnUrl}?${encodeQuerystring({
                popupId,
                status: "cancel",
            })}`,
            };
        }
        makeStripePopupSpec.checkout = checkout;
    })(makeStripePopupSpec || (makeStripePopupSpec = {}));

    async function getStripeDefaultPaymentMethod({ stripeLiaisonAccount, stripeCustomerId }) {
        const stripeCustomer = (await stripeLiaisonAccount
            .customers
            .retrieve(stripeCustomerId));
        const defaultPaymentMethodId = getStripeId(stripeCustomer
            .invoice_settings
            .default_payment_method);
        return defaultPaymentMethodId
            && await stripeLiaisonAccount
                .paymentMethods
                .retrieve(defaultPaymentMethodId);
    }

    const makeBillingService = (options) => service()
        .policy(options.storePolicies.customer)
        .expose(auth => ({
        async getDefaultPaymentMethod() {
            return derivePaymentMethod(await getStripeDefaultPaymentMethod(auth));
        },
        async generateCustomerPortalLink() {
            const { popupId, return_url } = makeStripePopupSpec
                .openCustomerPortal(options);
            const session = await auth
                .stripeLiaisonAccount
                .billingPortal
                .create({
                customer: auth.stripeCustomerId,
                return_url
            });
            return {
                popupId,
                customer: session.customer,
                stripeSessionUrl: session.url,
                stripeAccountId: auth.stripeAccountId
            };
        },
    }));

    function prepareRequiredPrivilege() {
        return function requiredPrivilege(checker, key, methods) {
            return objectMap(methods, method => async (...args) => {
                checker.requirePrivilege(key);
                return method(...args);
            });
        };
    }

    const requiredPrivilege = prepareRequiredPrivilege();

    function isUserOwnerOfStripeAccount(access, connectDetails) {
        return access.user.userId === connectDetails.userId;
    }
    async function createConnectPopup({ type, options, stripeLiaison, stripeAccountId, }) {
        const { popupId, ...urls } = makeStripePopupSpec
            .connect(options);
        const { url: stripeAccountSetupLink } = await stripeLiaison
            .accountLinks
            .create({
            type,
            account: stripeAccountId,
            ...urls,
        });
        return {
            popupId,
            stripeAccountId,
            stripeAccountSetupLink,
        };
    }
    async function assertStripeConnectAccount({ access, stripeLiaison, storeDatabaseUnconnected, generateId, }) {
        const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
        if (!connectDetails) {
            const { id: stripeAccountId } = await stripeLiaison
                .accounts
                .create({ type: "standard" });
            await createNewConnectAccountRecordsAndSetActive({
                access,
                stripeAccountId,
                storeDatabaseUnconnected,
                generateId,
            });
        }
        return (await fetchStripeConnectDetails({ storeDatabaseUnconnected })).connectDetails;
    }
    async function activateConnectAccount({ connectId, storeConnectTables }) {
        await storeConnectTables.active.update({
            conditions: false,
            upsert: { connectId },
        });
    }
    async function createNewConnectAccountRecordsAndSetActive({ access, stripeAccountId, storeDatabaseUnconnected, generateId, }) {
        const connectId = generateId();
        const userId = Id.fromString(access.user.userId);
        await storeDatabaseUnconnected.transaction(async ({ tables }) => {
            await tables
                .connect
                .accounts
                .create({
                connectId,
                stripeAccountId,
                charges_enabled: false,
                payouts_enabled: false,
                details_submitted: false,
                email: undefined,
                userId,
                paused: false,
                time: Date.now(),
            });
            await activateConnectAccount({
                connectId,
                storeConnectTables: tables.connect,
            });
        });
        return {
            connectId,
            stripeAccountId,
        };
    }

    const makeConnectService = (options) => service()
        .policy(options.storePolicies.guest)
        .expose(({ access, stripeLiaison, storeDatabaseUnconnected, checker }) => ({
        async loadConnectStatus() {
            const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
            return determineConnectStatus(connectDetails);
        },
        ...requiredPrivilege(checker, "manage store", {
            async pause() {
                const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
                const { stripeAccountId } = connectDetails;
                const connectStatus = determineConnectStatus(connectDetails);
                if (connectStatus !== StripeConnectStatus.Ready)
                    throw new ApiError(400, "cannot pause non-ready stripe account");
                else
                    await storeDatabaseUnconnected
                        .tables
                        .connect
                        .accounts
                        .update({
                        ...find({ stripeAccountId }),
                        write: { paused: true },
                    });
            },
            async resume() {
                const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
                const { stripeAccountId } = connectDetails;
                const connectStatus = determineConnectStatus(connectDetails);
                if (connectStatus !== StripeConnectStatus.Paused)
                    throw new ApiError(400, "cannot resume non-paused stripe account");
                else
                    await storeDatabaseUnconnected
                        .tables
                        .connect
                        .accounts
                        .update({
                        ...find({ stripeAccountId }),
                        write: { paused: false },
                    });
            },
        }),
        ...requiredPrivilege(checker, "control stripe account", {
            async loadConnectDetails() {
                const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
                return {
                    connectDetails,
                    connectStatus: determineConnectStatus(connectDetails),
                };
            },
            async generatePopupForStripeAccountOnboarding() {
                const connectDetails = await assertStripeConnectAccount({
                    access,
                    stripeLiaison,
                    storeDatabaseUnconnected,
                    generateId: options.generateId,
                });
                const { stripeAccountId } = connectDetails;
                if (!isUserOwnerOfStripeAccount(access, connectDetails))
                    throw new ApiError(400, "only the owner of the stripe account can onboard it");
                return createConnectPopup({
                    options,
                    stripeLiaison,
                    stripeAccountId,
                    type: "account_onboarding",
                });
            },
            async generateStripeLoginLink() {
                const { connectDetails } = await fetchStripeConnectDetails({ storeDatabaseUnconnected });
                const stripeAccountId = connectDetails === null || connectDetails === void 0 ? void 0 : connectDetails.stripeAccountId;
                return !stripeAccountId
                    ? undefined
                    : {
                        stripeLoginLink: `https://dashboard.stripe.com/b/${stripeAccountId}`,
                        popupId: (makeStripePopupSpec
                            .login(options)
                            .popupId),
                    };
            },
        }),
    }));

    async function queryStripeAboutSubscriptionPlans({ auth, tierRows }) {
        const { stripeLiaisonAccount } = auth;
        const stripeProducts = (await Promise.all(tierRows
            .map(async (row) => (await stripeLiaisonAccount
            .products
            .retrieve(row.stripeProductId))))).filter(p => !!p);
        const stripePrices = (await Promise.all(stripeProducts.map(async (product) => {
            const stripePriceId = getStripeId(product.default_price);
            return stripePriceId
                ? await stripeLiaisonAccount.prices
                    .retrieve(stripePriceId)
                : undefined;
        }))).filter(p => !!p);
        return { stripeProducts, stripePrices };
    }

    async function queryDatabaseAboutSubscriptionPlans(auth) {
        const storeTables = auth.storeDatabase.tables;
        const planRows = await storeTables
            .subscriptions
            .plans
            .read({ conditions: false });
        const planIds = planRows.map(row => row.planId);
        const tierRows = planIds.length
            ? await storeTables
                .subscriptions
                .tiers
                .read(findAll(planIds, planId => ({ planId })))
            : [];
        return { planRows, tierRows };
    }

    async function deleteTiersAndRolesForMissingStripeProducts({ auth, tierRows, stripeProducts }) {
        const { storeDatabase, roleManager } = auth;
        const storeTables = storeDatabase.tables;
        const stripeProductIds = stripeProducts.map(product => getStripeId(product.id));
        const idsForMissingTiers = tierRows
            .filter(row => !stripeProductIds.includes(row.stripeProductId))
            .map(row => ({ roleId: row.roleId, tierId: row.tierId }));
        if (idsForMissingTiers.length) {
            await storeTables
                .subscriptions
                .tiers
                .delete(findAll(idsForMissingTiers, ({ tierId }) => ({ tierId })));
            await Promise.all(idsForMissingTiers.map(async ({ roleId }) => {
                await roleManager.deleteRoleAndAllRelatedRecords(roleId);
            }));
        }
    }

    function isTierBelongingToPlan(planRow, tierRow) {
        return planRow.planId.equals(tierRow.planId);
    }

    function isTierAttachedToExistingStripeProduct(tierRow, stripeProductIds) {
        return stripeProductIds.includes(tierRow.stripeProductId);
    }

    function compileTiers(tierRows, planRow, stripeProducts, stripePrices) {
        const stripeProductIds = (stripeProducts
            .map(product => getStripeId(product.id)));
        function findPriceForTier(tierRow) {
            return stripePrices
                .find(price => getStripeId(price === null || price === void 0 ? void 0 : price.product) === tierRow.stripeProductId);
        }
        function findProductForTier(tierRow) {
            return stripeProducts
                .find(product => getStripeId(product.id) === tierRow.stripeProductId);
        }
        return tierRows
            .filter(tierRow => isTierBelongingToPlan(planRow, tierRow))
            .filter(tierRow => isTierAttachedToExistingStripeProduct(tierRow, stripeProductIds))
            .map(tierRow => buildFinalTierObject(tierRow, findPriceForTier(tierRow), findProductForTier(tierRow)));
    }

    function sortPlansByAscendingTime(a, b) {
        return a.time - b.time;
    }

    function sortTiersByAscendingPrice(a, b) {
        return a.pricing[0].price - b.pricing[0].price;
    }

    async function compileDataTogetherIntoSubscriptionPlansForFrontend({ planRows, tierRows, stripePrices, stripeProducts, }) {
        return planRows
            .map(planRow => {
            var _a;
            return ({
                archived: (_a = planRow.archived) !== null && _a !== void 0 ? _a : false,
                label: planRow.label,
                planId: planRow.planId.string,
                time: planRow.time,
                tiers: compileTiers(tierRows, planRow, stripeProducts, stripePrices).sort(sortTiersByAscendingPrice)
            });
        }).sort(sortPlansByAscendingTime);
    }

    const makeSubscriptionListingService = (options) => service()
        .policy(options.storePolicies.connected)
        .expose(auth => ({
        async listPlans() {
            const { planRows, tierRows } = await queryDatabaseAboutSubscriptionPlans(auth);
            const { stripeProducts, stripePrices } = await queryStripeAboutSubscriptionPlans({
                auth,
                planRows,
                tierRows,
            });
            await deleteTiersAndRolesForMissingStripeProducts({
                auth,
                tierRows,
                stripeProducts,
            });
            return compileDataTogetherIntoSubscriptionPlansForFrontend({
                planRows,
                tierRows,
                stripeProducts,
                stripePrices,
            });
        },
    }));

    function determineSubscriptionStatus(subscription) {
        if (!subscription)
            return SubscriptionStatus.Unsubscribed;
        const { status, cancel_at_period_end } = subscription;
        return cancel_at_period_end
            ? SubscriptionStatus.Cancelled
            : status === "active"
                ? SubscriptionStatus.Active
                : SubscriptionStatus.Unpaid;
    }

    function buildSubscriptionDetails(subscription, price, tierRow) {
        return {
            status: determineSubscriptionStatus(subscription),
            planId: tierRow === null || tierRow === void 0 ? void 0 : tierRow.planId.string,
            tierId: tierRow === null || tierRow === void 0 ? void 0 : tierRow.tierId.string,
            pricing: derivePricingFromStripePrice(price),
        };
    }

    async function cancelStripeSubscription(auth, stripeSubscriptionId) {
        await auth.stripeLiaisonAccount
            .subscriptions.update(stripeSubscriptionId, {
            cancel_at_period_end: true,
        });
    }

    async function uncancelStripeSubscription(auth, stripeSubscriptionId) {
        await auth.stripeLiaisonAccount
            .subscriptions.update(stripeSubscriptionId, {
            cancel_at_period_end: false,
        });
    }

    async function createStripeSubscriptionViaExistingPaymentMethod(auth, stripePriceId, stripePaymentMethod) {
        return auth.stripeLiaisonAccount.subscriptions.create({
            customer: auth.stripeCustomerId,
            default_payment_method: stripePaymentMethod.id,
            items: [{
                    price: stripePriceId,
                    quantity: 1,
                }],
        });
    }

    async function getTiersForStripePrices({ priceIds, storeDatabase, stripeLiaisonAccount, }) {
        if (priceIds.length === 0)
            throw new Error("prices not found in subscription from stripe");
        const prices = await Promise.all(priceIds.map(async (priceId) => (stripeLiaisonAccount
            .prices
            .retrieve(priceId))));
        const productIds = prices.map(p => getStripeId(p.product));
        return storeDatabase
            .tables
            .subscriptions
            .tiers
            .read(findAll(productIds, id => ({ stripeProductId: id })));
    }

    async function fetchRoleIdsRelatedToSubscribedStripePriceIds({ storeDatabase, stripePriceIds, stripeLiaisonAccount, }) {
        const subscribedTiers = await getTiersForStripePrices({
            priceIds: stripePriceIds,
            storeDatabase,
            stripeLiaisonAccount,
        });
        const { planId } = subscribedTiers[0];
        const allTiersBelongingToPlan = await storeDatabase
            .tables
            .subscriptions
            .tiers
            .read(find({ planId }));
        function keepTierIfUserIsNotSubscribed(tier) {
            return !subscribedTiers.some(row => row.tierId.string === tier.tierId.string);
        }
        const unsubscribedTiers = allTiersBelongingToPlan
            .filter(keepTierIfUserIsNotSubscribed);
        return {
            subscribedRoleIds: subscribedTiers.map(tier => tier.roleId),
            unsubscribedRoleIds: unsubscribedTiers.map(tier => tier.roleId),
        };
    }

    async function fulfillSubscriptionRoles({ userId, priceIds, storeDatabase, stripeLiaisonAccount, roleManager, timerange, }) {
        const { subscribedRoleIds, unsubscribedRoleIds, } = await fetchRoleIdsRelatedToSubscribedStripePriceIds({
            storeDatabase,
            stripeLiaisonAccount,
            stripePriceIds: priceIds,
        });
        await roleManager.revokeUserRoles({
            userId,
            roleIds: unsubscribedRoleIds,
        });
        await roleManager.grantUserRoles({
            ...timerange,
            userId,
            roleIds: subscribedRoleIds,
        });
    }

    function secondsToMilliseconds(seconds) {
        return seconds * 1000;
    }
    function timerangeFromStripePeriod({ start, end }) {
        return {
            timeframeStart: secondsToMilliseconds(start),
            timeframeEnd: secondsToMilliseconds(end),
        };
    }

    const stripeClientReferenceId = {
        build({ appId, userId }) {
            return `${appId} ${userId}`;
        },
        parse(client_reference_id) {
            const [appId, userId] = client_reference_id.split(" ");
            return { appId, userId };
        }
    };

    async function getInvoiceDetails({ event, stripeLiaison, storeDatabaseRaw }) {
        const invoice = event.data.object;
        const stripeCustomerId = getStripeId(invoice.customer);
        const stripeLiaisonAccount = stripeLiaison.account(event.account);
        const { storeDatabase, userId, appId } = await getStripeCustomerDetails(storeDatabaseRaw, stripeCustomerId);
        return {
            appId,
            userId,
            invoice,
            storeDatabase,
            stripeCustomerId,
            stripeLiaisonAccount,
        };
    }
    async function getSubscriptionDetails({ event, stripeLiaison, storeDatabaseRaw }) {
        const subscription = event.data.object;
        const stripeCustomerId = getStripeId(subscription.customer);
        const stripeLiaisonAccount = stripeLiaison.account(event.account);
        const { storeDatabase, userId, appId } = await getStripeCustomerDetails(storeDatabaseRaw, stripeCustomerId);
        return {
            appId,
            userId,
            subscription,
            storeDatabase,
            stripeCustomerId,
            stripeLiaisonAccount,
        };
    }
    function getDatabaseForApp(storeDatabaseRaw, appId) {
        return UnconstrainedTable.constrainDatabaseForApp({
            appId,
            database: storeDatabaseRaw,
        });
    }
    async function getConnectAccountDetails({ stripeAccountId, storeDatabaseRaw, }) {
        const connectAccount = await storeDatabaseRaw
            .tables
            .connect
            .accounts
            .unconstrained
            .readOne(find({ stripeAccountId }));
        if (connectAccount) {
            const appId = connectAccount[appConstraintKey];
            const storeDatabase = getDatabaseForApp(storeDatabaseRaw, appId);
            return { connectAccount, appId, storeDatabase };
        }
        else
            return undefined;
    }
    async function getStripeCustomerDetails(storeDatabaseRaw, stripeCustomerId) {
        const row = await storeDatabaseRaw.tables.customers.unconstrained
            .readOne(find({ stripeCustomerId }));
        if (!row)
            throw new Error(`stripe customer id not found in billing "${stripeCustomerId}"`);
        const appId = row[appConstraintKey];
        const storeDatabase = getDatabaseForApp(storeDatabaseRaw, appId);
        const { userId } = row;
        return {
            appId,
            userId,
            storeDatabase,
        };
    }
    function getPriceIdsFromSubscription(subscription) {
        return subscription.items.data.map(item => getStripeId(item.price));
    }
    function getPriceIdsFromInvoice(invoice) {
        const recurringItems = invoice.lines.data
            .filter(line => line.price.type === "recurring");
        const setOfPriceIds = new Set();
        for (const { price } of recurringItems)
            setOfPriceIds.add(price.id);
        return [...setOfPriceIds];
    }

    async function createSubscriptionViaCheckoutSession(auth, stripePriceId, { success_url, cancel_url }) {
        return auth.stripeLiaisonAccount.checkout.sessions.create({
            customer: auth.stripeCustomerId,
            mode: "subscription",
            line_items: [{
                    price: stripePriceId,
                    quantity: 1,
                }],
            client_reference_id: stripeClientReferenceId.build({
                appId: auth.access.appId,
                userId: auth.access.user.userId,
            }),
            success_url,
            cancel_url,
        });
    }

    async function getRowsForTierId({ tierId: tierIdString, auth: { storeDatabase }, }) {
        const tierId = Id.fromString(tierIdString);
        const tierRow = await storeDatabase
            .tables
            .subscriptions
            .tiers
            .readOne(find({ tierId }));
        if (!tierRow)
            throw new Error(`subscription tier not found "${tierId}"`);
        const planRow = await storeDatabase
            .tables
            .subscriptions
            .plans
            .readOne(find({ planId: tierRow.planId }));
        if (!planRow)
            throw new Error(`subscription not found "${tierRow.planId.toString()}"`);
        return { tierRow, planRow };
    }

    async function getTierRowByQueryingStripePriceId({ stripePriceId, storeDatabase, stripeLiaisonAccount, }) {
        const stripePrice = await stripeLiaisonAccount
            .prices
            .retrieve(stripePriceId);
        const stripeProductId = getStripeId(stripePrice.product);
        const tierRow = await storeDatabase
            .tables
            .subscriptions
            .tiers
            .readOne(find({ stripeProductId }));
        return tierRow;
    }

    async function findStripeSubscriptionRelatedToTier(auth, tierId) {
        const { storeDatabase, stripeLiaisonAccount, stripeCustomerId } = auth;
        const { tierRow } = await getRowsForTierId({ tierId, auth });
        const stripeSubscriptions = await stripeLiaisonAccount
            .subscriptions
            .list({ customer: stripeCustomerId });
        if (stripeSubscriptions) {
            for (const subscription of stripeSubscriptions.data) {
                const stripePriceId = getStripeId(subscription.items.data[0].price);
                const subscribedTierRow = await getTierRowByQueryingStripePriceId({
                    stripePriceId,
                    storeDatabase,
                    stripeLiaisonAccount,
                });
                if (tierRow.planId.string === subscribedTierRow.planId.string)
                    return subscription;
            }
        }
    }

    async function updateExistingSubscriptionWithNewTier({ stripePriceId, auth, stripeSubscription, }) {
        const { stripeLiaisonAccount } = auth;
        const previousItemId = stripeSubscription.items.data[0].id;
        const newItems = [
            {
                id: previousItemId,
                price: stripePriceId,
                quantity: 1,
            }
        ];
        return stripeLiaisonAccount.subscriptions.update(stripeSubscription.id, {
            items: newItems,
            cancel_at_period_end: false,
            proration_behavior: "create_prorations",
        });
    }

    async function prepareToBuyStripeSubscription(options, auth, stripePriceId) {
        const userId = Id.fromString(auth.access.user.userId);
        const actions = {
            async updateAndFulfillSubscription(subscription) {
                const updatedSubscription = await updateExistingSubscriptionWithNewTier({
                    auth,
                    stripePriceId,
                    stripeSubscription: subscription,
                });
                if (updatedSubscription.status === "active")
                    await fulfillSubscriptionRoles({
                        userId,
                        storeDatabase: auth.storeDatabase,
                        stripeLiaisonAccount: auth.stripeLiaisonAccount,
                        roleManager: auth.roleManager,
                        priceIds: getPriceIdsFromSubscription(updatedSubscription),
                        timerange: timerangeFromStripePeriod({
                            start: updatedSubscription.current_period_start,
                            end: updatedSubscription.current_period_end,
                        })
                    });
                return {};
            },
            async createNewSubscriptionUsingExistingPaymentMethod(paymentMethod) {
                const newSubscription = await createStripeSubscriptionViaExistingPaymentMethod(auth, stripePriceId, paymentMethod);
                if (newSubscription.status === "active")
                    await fulfillSubscriptionRoles({
                        userId,
                        storeDatabase: auth.storeDatabase,
                        stripeLiaisonAccount: auth.stripeLiaisonAccount,
                        roleManager: auth.roleManager,
                        priceIds: getPriceIdsFromSubscription(newSubscription),
                        timerange: timerangeFromStripePeriod({
                            start: newSubscription.current_period_start,
                            end: newSubscription.current_period_end,
                        })
                    });
                return {};
            },
            async createCheckoutPopupToBuyNewSubscription() {
                const { popupId, ...urls } = makeStripePopupSpec.checkout(options);
                const session = await createSubscriptionViaCheckoutSession(auth, stripePriceId, urls);
                return {
                    checkoutDetails: {
                        popupId,
                        stripeAccountId: auth.stripeAccountId,
                        stripeSessionUrl: session.url,
                        stripeSessionId: session.id,
                    },
                };
            },
        };
        const { tierId } = await getTierRowByQueryingStripePriceId({
            ...auth,
            stripePriceId,
        });
        return {
            actions,
            ...await concurrent({
                defaultPaymentMethod: getStripeDefaultPaymentMethod(auth),
                subscription: findStripeSubscriptionRelatedToTier(auth, tierId.string),
            }),
        };
    }

    function determinePurchaseScenario({ hasDefaultPaymentMethod, hasExistingSubscription }) {
        if (hasExistingSubscription)
            return PurchaseScenario.Update;
        else {
            if (hasDefaultPaymentMethod)
                return PurchaseScenario.UsePaymentMethod;
            else
                return PurchaseScenario.CheckoutPopup;
        }
    }

    async function verifyPlanHasExistingStripeSubscription(auth, tierId) {
        const stripeSubscription = await findStripeSubscriptionRelatedToTier(auth, tierId);
        if (!stripeSubscription)
            throw new Error("user must already have a subscription");
        else
            return stripeSubscription;
    }

    async function fetchStripeSubscriptionsForCustomer(auth) {
        var _a;
        const stripeSubscriptions = (await auth.stripeLiaisonAccount
            .subscriptions
            .list({ customer: auth.stripeCustomerId }));
        return (_a = stripeSubscriptions === null || stripeSubscriptions === void 0 ? void 0 : stripeSubscriptions.data) !== null && _a !== void 0 ? _a : [];
    }

    async function queryStripePriceRelatedToSubscription(stripeLiaisonAccount, subscription) {
        const [stripePriceId] = subscription
            .items
            .data
            .map(item => getStripeId(item.price));
        const price = await stripeLiaisonAccount
            .prices
            .retrieve(stripePriceId);
        return price;
    }

    async function queryTierRowRelatedToStripePrice(storeDatabase, price) {
        return storeDatabase
            .tables
            .subscriptions
            .tiers
            .readOne(find({
            stripeProductId: getStripeId(price.product)
        }));
    }

    const makeSubscriptionShoppingService = (options) => service()
        .policy(options.storePolicies.customer)
        .expose(auth => ({
        async fetchDetailsAboutMySubscriptions() {
            const subscriptions = await fetchStripeSubscriptionsForCustomer(auth);
            return Promise.all(subscriptions.map(async (subscription) => {
                const price = await queryStripePriceRelatedToSubscription(auth.stripeLiaisonAccount, subscription);
                const tierRow = await queryTierRowRelatedToStripePrice(auth.storeDatabase, price);
                return buildSubscriptionDetails(subscription, price, tierRow);
            }));
        },
        async buy(stripePriceId) {
            const { subscription, defaultPaymentMethod, actions, } = await prepareToBuyStripeSubscription(options, auth, stripePriceId);
            stripePriceId = runValidation(stripePriceId, validator$1(string()));
            const scenario = determinePurchaseScenario({
                hasDefaultPaymentMethod: !!defaultPaymentMethod,
                hasExistingSubscription: !!subscription,
            });
            switch (scenario) {
                case PurchaseScenario.Update:
                    return actions.updateAndFulfillSubscription(subscription);
                case PurchaseScenario.UsePaymentMethod:
                    return actions.createNewSubscriptionUsingExistingPaymentMethod(defaultPaymentMethod);
                case PurchaseScenario.CheckoutPopup:
                    return actions.createCheckoutPopupToBuyNewSubscription();
                default:
                    throw new Error("unknown purchase scenario");
            }
        },
        async cancel(tierId) {
            tierId = runValidation(tierId, validateId);
            const stripeSubscription = await verifyPlanHasExistingStripeSubscription(auth, tierId);
            await cancelStripeSubscription(auth, stripeSubscription.id);
        },
        async uncancel(tierId) {
            tierId = runValidation(tierId, validateId);
            const stripeSubscription = await verifyPlanHasExistingStripeSubscription(auth, tierId);
            await uncancelStripeSubscription(auth, stripeSubscription.id);
        },
    }));

    const validatePriceNumber = validator$1(number(), min(0.01));
    const validateLabel = validator$1(string(), minLength(1), maxLength(32));
    const validateCurrency = validator$1(string(), branch(is("usd")));
    const validateInterval = validator$1(string(), branch(is("month"), is("year")));
    const validateSubscriptionPricingDraft = schema({
        price: validatePriceNumber,
        currency: validateCurrency,
        interval: validateInterval,
    });
    const validateBoolean = validator$1(boolean());
    const validatePricing = schema({
        currency: validateCurrency,
        interval: validateInterval,
        price: validatePriceNumber,
    });
    const validateNewTierDraft = schema({
        label: validateLabel,
        pricing: validatePricing,
    });
    const validateNewPlanDraft = schema({
        planLabel: validateLabel,
        tier: validateNewTierDraft,
    });
    const validateEditPlanDraft = schema({
        planId: validateId,
        label: validateLabel,
        archived: validateBoolean,
    });
    const validateEditTierDraft = schema({
        tierId: validateId,
        label: validateLabel,
        active: validateBoolean,
        pricing: validatePricing,
    });

    const makeSubscriptionPlanningService = (options) => service()
        .policy(options.storePolicies.merchant)
        .expose(({ helpers }) => ({
        async addPlan(inputs) {
            const { planLabel, tier } = runValidation(inputs, validateNewPlanDraft);
            const { planId, tierId, tierRoleId, time, stripePriceId } = await helpers.createPlanAndTier({
                planLabel,
                tier,
            });
            return {
                planId: planId.toString(),
                label: planLabel,
                time,
                archived: false,
                tiers: [
                    {
                        tierId: tierId.toString(),
                        label: tier.label,
                        roleId: tierRoleId.string,
                        pricing: [{
                                ...tier.pricing,
                                stripePriceId,
                            }],
                        time,
                        active: true,
                    }
                ],
            };
        },
        async addTier(inputs) {
            const planId = runValidation(inputs.planId, validateId);
            const label = runValidation(inputs.label, validateLabel);
            const pricing = runValidation(inputs.pricing, validateSubscriptionPricingDraft);
            const { tierId, roleId, time, stripePriceId } = await helpers.createTierForPlan({
                label,
                planId,
                pricing,
            });
            const tier = {
                tierId: tierId.toString(),
                roleId: roleId.toString(),
                active: true,
                label,
                pricing: [{ ...pricing, stripePriceId }],
                time,
            };
            return tier;
        },
        async editPlan(inputs) {
            const planId = runValidation(inputs.planId, validateId);
            const label = runValidation(inputs.label, validateLabel);
            const archived = runValidation(inputs.archived, validateBoolean);
            await helpers.updatePlan({ planId, label, archived });
        },
        async editTier(inputs) {
            const label = runValidation(inputs.label, validateLabel);
            const tierId = runValidation(inputs.tierId, validateId);
            const active = runValidation(inputs.active, validateBoolean);
            const pricing = runValidation(inputs.pricing, validateSubscriptionPricingDraft);
            return helpers.updateTier({
                label,
                tierId,
                active,
                pricing,
            });
        },
    }));

    function makeStoreApi(options) {
        const serviceOptions = {
            ...options,
            storePolicies: makeStorePolicies(options),
        };
        return api({
            connect: makeConnectService(serviceOptions),
            billing: makeBillingService(serviceOptions),
            subscriptions: {
                listing: makeSubscriptionListingService(serviceOptions),
                planning: makeSubscriptionPlanningService(serviceOptions),
                shopping: makeSubscriptionShoppingService(serviceOptions),
            },
        });
    }

    function makeRoleManager({ database, generateId }) {
        return {
            async grantUserRoles({ userId, roleIds, timeframeEnd, timeframeStart, }) {
                await database.transaction(({ tables }) => Promise.all(roleIds.map(roleId => tables.userHasRole.update({
                    ...find({ userId, roleId }),
                    upsert: {
                        userId,
                        hard: true,
                        public: true,
                        time: Date.now(),
                        roleId,
                        timeframeStart,
                        timeframeEnd,
                    },
                }))));
            },
            async revokeUserRoles({ userId, roleIds }) {
                if (roleIds.length > 0) {
                    await database.tables.userHasRole.delete({
                        conditions: and({ equal: { userId } }, or(...roleIds.map(roleId => ({ equal: { roleId } }))))
                    });
                }
            },
            async createPrivateSystemRole({ label }) {
                const roleId = generateId();
                await database.tables.role.create({
                    label,
                    roleId,
                    hard: true,
                    public: true,
                    assignable: false,
                    time: Date.now(),
                });
                return { roleId };
            },
            async readRole(roleId) {
                return await database.tables.role.readOne(find({ roleId: roleId }));
            },
            async updateRole({ label, roleId }) {
                await database.tables.role.update({
                    ...find({ roleId: roleId }),
                    write: { label },
                });
            },
            async deleteRoleAndAllRelatedRecords(roleId) {
                const conditional = find({ roleId: roleId });
                await database.transaction(async ({ tables }) => Promise.all([
                    tables.role.delete(conditional),
                    tables.userHasRole.delete(conditional),
                ]));
            },
        };
    }
    function buildFunctionToPrepareRoleManager({ rando, permissionsDatabaseRaw, }) {
        return (appId) => makeRoleManager({
            generateId: () => rando.randomId(),
            database: UnconstrainedTable.constrainDatabaseForApp({
                appId,
                database: permissionsDatabaseRaw,
            })
        });
    }

    async function assimilateApi({ config, rando, databaseRaw, dacastSdk, stripeLiaison, sendLoginEmail, signToken, verifyToken, }) {
        const generateNickname = standardNicknameGenerator({ rando });
        const authPolicies = prepareAuthPolicies({
            config,
            databaseRaw,
            verifyToken,
        });
        return api({
            auth: authApi({
                rando,
                config,
                authPolicies,
                signToken,
                verifyToken,
                sendLoginEmail,
                generateNickname,
            }),
            administrative: makeAdministrativeApi({
                config,
                authPolicies,
            }),
            questions: questionsApi({
                rando,
                config,
                authPolicies,
            }),
            example: exampleApi({
                rando,
                config,
                authPolicies,
            }),
            videos: videosApi({
                config,
                dacastSdk,
                authPolicies,
            }),
            notes: notesApi({
                config,
                authPolicies,
            }),
            store: makeStoreApi({
                async anonPolicy(meta, headers) {
                    const auth = await authPolicies.anonPolicy(meta, headers);
                    const { database } = auth;
                    delete auth.database;
                    return {
                        ...auth,
                        stripeLiaison,
                        roleManager: makeRoleManager({
                            generateId: () => rando.randomId(),
                            database: subsection(database, tables => ({
                                role: tables.auth.permissions.role,
                                userHasRole: tables.auth.permissions.userHasRole,
                            })),
                        }),
                        storeDatabaseUnconnected: subsection(database, tables => tables.store),
                    };
                },
                stripeLiaison,
                generateId: rando.randomId,
                popupReturnUrl: config.webRoot + config.store.popupReturnUrl,
            }),
        });
    }

    function loginEmailRecaller(sendLoginEmail) {
        let latestLoginEmail;
        return {
            sendLoginEmail: async (details) => {
                latestLoginEmail = details;
                await sendLoginEmail(details);
            },
            recallLatestLoginEmail: () => latestLoginEmail,
        };
    }

    const mockSendEmail = async (email) => console.log(`

====== EMAIL ======
from: ${email.fromLabel}
to: ${email.to}
subject: ${email.subject}
time: ${new Date().toLocaleString()}

${email.text}

===================

`);

    function makeEmailEnabler(actuallySendEmail) {
        let enabled = true;
        const sendEmail = async (details) => {
            if (enabled)
                return actuallySendEmail(details);
        };
        return {
            sendEmail,
            enableEmails() { enabled = true; },
            disableEmails() { enabled = false; },
        };
    }

    function makeLoginLink({ home, loginToken }) {
        const url = new URL(home);
        url.hash = `#login=${loginToken}`;
        return url;
    }

    function escapeHtml(text) {
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function noop(strings, ...values) {
        return Array.from(strings)
            .reduce((previous, current, index) => { var _a; return previous + current + ((_a = values[index]) !== null && _a !== void 0 ? _a : ""); }, "");
    }

    function prepareSendLoginEmail({ sendEmail }) {
        return async function sendLoginEmail({ to, appHome, appLabel, lifespan, legalLink, loginToken, platformLink, }) {
            const loginLink = makeLoginLink({ loginToken, home: appHome });
            const minutesLeft = Math.round((lifespan / minute)).toFixed(0);
            const safeLabel = escapeHtml(appLabel);
            const platformHost = new URL(platformLink).host;
            return sendEmail({
                to,
                fromLabel: appLabel,
                subject: `Login link`,
                html: (noop `
<h1>Login link for ${safeLabel}</h1>
<p style="font-size: 1.2em; padding-left: 0.5rem;">
	<a href="${loginLink.toString()}">Â» Login to ${safeLabel} Â«</a>
</p>
<div style="opacity: 0.7; font-size: 0.8em; margin-top: 2rem;">
	<p>Expires in ${minutesLeft} minutes.</p>
	<p>If you didn't request this login link, just ignore it.</p>
	<p>You can contact support by replying to this email.</p>
	<ul style="padding-left: 0.5rem;">
		<li>Logins powered by <a href="${platformLink}">${platformHost}</a></li>
		<li><a href="${legalLink}">Policies and terms of service</a></li>
	</ul>
	<p style="opacity: 0.3; font-size: 0.4em;">
		${Date.now()}
	</p>
</div>
`),
                text: (`
Login link for ${appLabel}

  Â» ${loginLink.toString()}


Expires in ${minutesLeft} minutes

If you didn't request this login link, just ignore it.

You can contact support by replying to this email.

  * Logins powered by ${platformLink}

  * Policies and terms of service ${legalLink}

${Date.now()}
`),
            });
        };
    }

    function assimilateEmails({ config, configureMailgun, }) {
        let sendEmail;
        if (config.email === "mock-console") {
            sendEmail = mockSendEmail;
        }
        else {
            sendEmail = configureMailgun(config.email).sendEmail;
        }
        const enabler = makeEmailEnabler(sendEmail);
        sendEmail = enabler.sendEmail;
        const { disableEmails, enableEmails } = enabler;
        const { sendLoginEmail, recallLatestLoginEmail } = loginEmailRecaller(prepareSendLoginEmail({ sendEmail }));
        return {
            sendEmail,
            enableEmails,
            disableEmails,
            sendLoginEmail,
            recallLatestLoginEmail,
        };
    }

    function assimilateCrypto({ config, configureTokenFunctions, }) {
        return config.crypto.keys === "mock-mode"
            ? {
                signToken: mockSignToken(),
                verifyToken: mockVerifyToken(),
            }
            : configureTokenFunctions(config.crypto.keys);
    }

    function stripeWebhooks(options) {
        const { logger, prepareRoleManager } = options;
        const webhooks = {
            async "account.updated"(event) {
                const account = event.data.object;
                const stripeAccountId = account.id;
                const known = await getConnectAccountDetails({
                    ...options,
                    stripeAccountId,
                });
                if (known) {
                    const { storeDatabase, connectAccount: { connectId } } = known;
                    await storeDatabase
                        .tables
                        .connect
                        .accounts
                        .update({
                        ...find({ connectId }),
                        write: {
                            email: account.email,
                            charges_enabled: account.charges_enabled,
                            payouts_enabled: account.payouts_enabled,
                            details_submitted: account.details_submitted,
                        },
                    });
                }
            },
            async "customer.subscription.updated"(event) {
                const { appId, subscription, userId, storeDatabase, stripeLiaisonAccount, } = await getSubscriptionDetails({ ...options, event });
                const roleManager = prepareRoleManager(appId);
                const priceIds = getPriceIdsFromSubscription(subscription);
                await fulfillSubscriptionRoles({
                    userId,
                    priceIds,
                    storeDatabase,
                    stripeLiaisonAccount,
                    roleManager,
                    timerange: timerangeFromStripePeriod({
                        start: subscription.current_period_start,
                        end: subscription.current_period_end,
                    }),
                });
            },
            async "invoice.paid"(event) {
                const { invoice, appId, userId, storeDatabase, stripeLiaisonAccount } = await getInvoiceDetails({ ...options, event });
                const invoiceIsForSubscription = !!invoice.subscription;
                const roleManager = prepareRoleManager(appId);
                if (invoiceIsForSubscription)
                    await fulfillSubscriptionRoles({
                        userId,
                        storeDatabase,
                        stripeLiaisonAccount,
                        roleManager,
                        priceIds: getPriceIdsFromInvoice(invoice),
                        timerange: timerangeFromStripePeriod(invoice.lines.data[0].period),
                    });
                else
                    logger.error(`unknown 'invoice.paid' hook (not for a subscription)`);
            },
        };
        const webhooksWithLogging = objectMap$1(webhooks, (webhookFunction, functionName) => (async (event) => {
            logger.info(`stripe-webhook ${functionName}:`, event.data.object);
            return webhookFunction(event);
        }));
        return webhooksWithLogging;
    }

    function stripeResponse(resource) {
        return {
            headers: {},
            lastResponse: undefined,
            ...resource,
        };
    }

    function prepareStandardRestResource({ generateId }) {
        return function makeStandardRestResource() {
            const throwAnError = () => {
                throw new Error("not implemented");
            };
            return function ({ table, handleCreate = throwAnError, handleUpdate = throwAnError, }) {
                return {
                    async create(params) {
                        const { resource, afterResourceIsAddedToTable } = await handleCreate(params);
                        const finalResource = {
                            id: generateId(),
                            ...resource,
                        };
                        await table.create(finalResource);
                        if (afterResourceIsAddedToTable)
                            await afterResourceIsAddedToTable();
                        return stripeResponse(finalResource);
                    },
                    async update(id, params) {
                        await table.update({
                            ...find({ id }),
                            write: ignoreUndefined(await handleUpdate(id, params)),
                        });
                        const resource = await table.readOne(find({ id }));
                        return stripeResponse(resource);
                    },
                    async retrieve(id) {
                        const resource = await table.readOne(find({ id }));
                        return stripeResponse(resource);
                    },
                    async del(id) {
                        await table.delete(find({ id }));
                        return stripeResponse({});
                    },
                };
            };
        };
    }
    function ignoreUndefined(input) {
        const output = {};
        for (const [key, value] of Object.entries(input)) {
            if (value !== undefined)
                output[key] = value;
        }
        return output;
    }

    function mockSubscriptionMechanics({ tables, generateId, }) {
        async function interpretCreateItemsParam(createItems) {
            const created = Date.now();
            return {
                object: "list",
                url: "",
                has_more: false,
                data: await Promise.all(createItems.map(async (item) => ({
                    id: generateId(),
                    created,
                    price: item.price,
                    quantity: item.quantity,
                }))),
            };
        }
        async function interpretUpdateItemsParam(updateItems) {
            const created = Date.now();
            return {
                object: "list",
                url: "",
                has_more: false,
                data: await Promise.all(updateItems.map(async (item) => ({
                    id: generateId(),
                    created,
                    price: item.price,
                    quantity: item.quantity,
                }))),
            };
        }
        async function interpretCreateParams(createSubscription) {
            const MILLISECONDS_IN_A_MONTH = 2592000000;
            return {
                id: generateId(),
                customer: createSubscription.customer,
                created: Date.now(),
                default_payment_method: createSubscription.default_payment_method,
                status: "active",
                items: await interpretCreateItemsParam(createSubscription.items),
                current_period_end: Math.floor((Date.now() + MILLISECONDS_IN_A_MONTH) / 1000),
                current_period_start: Math.floor(Date.now() / 1000),
            };
        }
        async function generateInvoiceForSubscriptionItems({ subscriptionId, items, default_payment_method, customer, current_period_end, current_period_start }) {
            let amount = 0;
            const lineData = await Promise.all(items.data.map(async (item) => {
                const price = await tables.prices.readOne(find({ id: getStripeId(item.price) }));
                amount += price.unit_amount * item.quantity;
                return {
                    quantity: item.quantity,
                    price: {
                        type: "recurring",
                        id: price.id,
                    },
                    period: {
                        end: current_period_end,
                        start: current_period_start,
                    }
                };
            }));
            const paymentMethod = default_payment_method;
            const paymentIntent = {
                id: generateId(),
                amount,
                currency: "usd",
                customer: customer,
                payment_method: paymentMethod,
            };
            const invoice = {
                id: generateId(),
                customer: customer,
                subscription: subscriptionId,
                lines: { data: lineData },
                payment_intent: paymentIntent.id,
            };
            await tables.paymentIntents.create(paymentIntent);
            await tables.invoices.create(invoice);
            return { invoice, paymentIntent };
        }
        return {
            interpretUpdateItemsParam,
            interpretCreateParams,
            generateInvoiceForSubscriptionItems,
        };
    }

    function makeFakestripePopupUrls(base) {
        return {
            connect(params) {
                return `${base}/mocksite/fakestripe/connect?${encodeQuerystring(params)}`;
            },
            login() {
                return `${base}/mocksite/fakestripe/login`;
            },
            customerPortal() {
                return `${base}/mocksite/fakestripe/store-customer-portal`;
            },
            checkout(params) {
                return `${base}/mocksite/fakestripe/checkout?${encodeQuerystring(params)}`;
            },
        };
    }

    function mockStripeLiaison({ rando, rootUrl, recentDetails, metaDataTables, tables: rawTables, dispatchWebhook, }) {
        const generateId = () => rando.randomId().string;
        const makeStandardRestResource = prepareStandardRestResource({ generateId });
        const fakestripePopups = makeFakestripePopupUrls(rootUrl);
        return {
            accounts: {
                async create(params) {
                    const account = {
                        id: generateId().toString(),
                        type: params.type,
                        email: params.email,
                    };
                    await rawTables.accounts.create(account);
                    return stripeResponse(account);
                },
                async retrieve(id) {
                    const account = await rawTables.accounts.readOne(find({ id }));
                    return stripeResponse(account);
                },
                async createLoginLink(id) {
                    const loginLink = {
                        created: Date.now(),
                        url: fakestripePopups.login(),
                    };
                    return stripeResponse(loginLink);
                },
            },
            accountLinks: {
                async create(params) {
                    const accountLink = {
                        url: fakestripePopups.connect({
                            return_url: params.return_url,
                            refresh_url: params.refresh_url,
                        }),
                    };
                    return stripeResponse(accountLink);
                },
            },
            account(stripeAccountId) {
                const tables = constrainTables({
                    tables: rawTables,
                    constraint: { "_connectedAccount": stripeAccountId },
                });
                const subscriptionMechanics = mockSubscriptionMechanics({
                    tables,
                    generateId,
                });
                return {
                    billingPortal: {
                        async create(params) {
                            return stripeResponse({
                                url: fakestripePopups.customerPortal(),
                                customer: params.customer
                            });
                        }
                    },
                    customers: {
                        ...makeStandardRestResource()({
                            table: tables.customers,
                            handleCreate: async (params) => {
                                var _a;
                                return ({
                                    resource: {
                                        email: params.email,
                                        invoice_settings: (_a = params.invoice_settings) !== null && _a !== void 0 ? _a : { default_payment_method: undefined },
                                    }
                                });
                            },
                            handleUpdate: async (id, params) => ({
                                email: params.email,
                                invoice_settings: params.invoice_settings,
                            }),
                        }),
                        async listPaymentMethods(customer, params) {
                            const paymentMethods = await tables.paymentMethods.read(find({ customer, type: params.type }));
                            return stripeResponse({
                                object: "list",
                                data: paymentMethods,
                            });
                        },
                    },
                    products: makeStandardRestResource()({
                        table: tables.products,
                        handleCreate: async (params) => ({
                            resource: {
                                name: params.name,
                                description: params.description,
                                active: true,
                            }
                        }),
                        handleUpdate: async (id, params) => ({
                            name: params.name,
                            active: params.active,
                            description: params.description,
                            default_price: params.default_price,
                        }),
                    }),
                    prices: (() => {
                        const resource = makeStandardRestResource()({
                            table: tables.prices,
                            handleCreate: async (params) => ({
                                resource: {
                                    active: params.active === undefined ? true : params.active,
                                    product: params.product,
                                    currency: params.currency,
                                    unit_amount: params.unit_amount,
                                    recurring: params.recurring
                                        ? { usage_type: "licensed", ...params.recurring }
                                        : undefined,
                                    type: params.recurring ? "recurring" : "one_time",
                                }
                            }),
                            handleUpdate: async (id, params) => ({
                                active: params.active,
                                recurring: params.recurring
                                    ? { usage_type: "licensed", ...params.recurring }
                                    : undefined,
                            }),
                        });
                        return {
                            ...resource,
                            async list(params) {
                                let prices = await tables.prices.read({ conditions: false });
                                if (params.active !== undefined)
                                    prices = prices.filter(p => p.active === params.active);
                                if (params.product !== undefined)
                                    prices = prices.filter(p => p.product === params.product);
                                return stripeResponse({
                                    object: "list",
                                    data: prices,
                                });
                            },
                        };
                    })(),
                    checkout: {
                        sessions: makeStandardRestResource()({
                            table: tables.checkoutSessions,
                            handleCreate: async (params) => ({
                                resource: {
                                    mode: params.mode,
                                    url: params.mode === "setup"
                                        ? undefined
                                        : fakestripePopups.checkout({
                                            cancel_url: params.cancel_url,
                                            success_url: params.success_url,
                                        }),
                                    customer: params.customer,
                                    client_reference_id: params.client_reference_id,
                                    line_items: params.mode === "setup"
                                        ? undefined
                                        : {
                                            object: "list",
                                            has_more: false,
                                            url: undefined,
                                            data: params.line_items.map(item => ({
                                                id: rando.randomId().string,
                                                object: "item",
                                                quantity: item.quantity,
                                                price: item.price,
                                            })),
                                        },
                                }
                            }),
                            handleUpdate: async (id, params) => ({}),
                        }),
                    },
                    paymentMethods: (() => {
                        const resource = makeStandardRestResource()({
                            table: tables.paymentMethods,
                            handleCreate: async (params) => ({
                                resource: {
                                    type: params.type,
                                    customer: params.customer,
                                    card: params.card,
                                }
                            }),
                            handleUpdate: async (id, params) => ({
                                card: params.card,
                            }),
                        });
                        return {
                            ...resource,
                            delete: undefined,
                            async detach(id) {
                                const paymentMethod = resource.retrieve(id);
                                await resource.del(id);
                                return stripeResponse(paymentMethod);
                            }
                        };
                    })(),
                    setupIntents: makeStandardRestResource()({
                        table: tables.setupIntents,
                        handleCreate: async (params) => ({
                            resource: {
                                customer: params.customer,
                                payment_method: params.payment_method,
                                usage: params.usage,
                            }
                        }),
                        handleUpdate: async (id, params) => ({
                            payment_method: params.payment_method,
                        }),
                    }),
                    paymentIntents: makeStandardRestResource()({
                        table: tables.setupIntents,
                        handleCreate: async (params) => ({
                            resource: {
                                customer: params.customer,
                                payment_method: params.payment_method,
                                amount: params.amount,
                                currency: params.currency,
                            }
                        }),
                        handleUpdate: async (id, params) => ({
                            customer: params.customer,
                            payment_method: params.payment_method,
                            amount: params.amount,
                            currency: params.currency,
                        }),
                    }),
                    subscriptionItems: makeStandardRestResource(),
                    subscriptions: (() => {
                        const resource = makeStandardRestResource()({
                            table: tables.subscriptions,
                            handleCreate: async (params) => {
                                const subscription = await subscriptionMechanics
                                    .interpretCreateParams(params);
                                const { invoice, paymentIntent } = await subscriptionMechanics
                                    .generateInvoiceForSubscriptionItems({
                                    customer: subscription.customer,
                                    default_payment_method: subscription
                                        .default_payment_method,
                                    subscriptionId: subscription.id,
                                    items: subscription.items,
                                    current_period_end: subscription.current_period_end,
                                    current_period_start: subscription.current_period_start
                                });
                                const paymentMethodId = getStripeId(paymentIntent.payment_method);
                                const paymentMethodMetaData = await metaDataTables.
                                    paymentMethodMetaData.readOne(find({ id: paymentMethodId }));
                                recentDetails.subscriptionCreation = {
                                    subscription,
                                    paymentIntent: paymentIntent,
                                };
                                subscription.status = (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)
                                    ? "incomplete"
                                    : "active";
                                return {
                                    resource: subscription,
                                    afterResourceIsAddedToTable: async () => {
                                        if (!(paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)) {
                                            await dispatchWebhook("invoice.paid", stripeAccountId, invoice);
                                        }
                                        // else {
                                        // 	await dispatchWebhook(
                                        // 		"invoice.payment_failed",
                                        // 		stripeAccountId,
                                        // 		invoice,
                                        // 	)}
                                    }
                                };
                            },
                        });
                        return {
                            ...resource,
                            async update(id, params) {
                                const existingSubscription = await resource.retrieve(id);
                                const write = {};
                                const paymentMethodMetaData = await metaDataTables.
                                    paymentMethodMetaData.readOne(find({ id: params.default_payment_method }));
                                if (params.cancel_at_period_end !== undefined) {
                                    write.cancel_at_period_end = params.cancel_at_period_end;
                                }
                                if (params.default_payment_method !== undefined) {
                                    write.default_payment_method = params.default_payment_method;
                                }
                                write.status = (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing)
                                    ? "incomplete"
                                    : "active";
                                if (params.items !== undefined) {
                                    const newItems = params.items;
                                    const items = await subscriptionMechanics
                                        .interpretUpdateItemsParam(newItems);
                                    const { invoice } = await subscriptionMechanics.generateInvoiceForSubscriptionItems({
                                        customer: existingSubscription.customer,
                                        default_payment_method: existingSubscription
                                            .default_payment_method,
                                        subscriptionId: id,
                                        items,
                                        current_period_end: existingSubscription.current_period_end,
                                        current_period_start: existingSubscription.current_period_start
                                    });
                                    if (paymentMethodMetaData === null || paymentMethodMetaData === void 0 ? void 0 : paymentMethodMetaData.isFailing) ;
                                    else {
                                        await dispatchWebhook("invoice.paid", stripeAccountId, invoice);
                                    }
                                    write.items = items;
                                }
                                await tables.subscriptions.update({
                                    ...find({ id }),
                                    write: write,
                                });
                                return resource.retrieve(id);
                            },
                            async list(params) {
                                let equalityQuery = { equal: { customer: params.customer } };
                                let statusQuery = { notEqual: { status: "canceled" } };
                                if (params.price)
                                    equalityQuery.equal.price = params.price;
                                if (params.status)
                                    statusQuery = params.status === "all"
                                        ? { isSet: { status: true } }
                                        : params.status === "ended"
                                            ? [
                                                "and",
                                                { notEqual: { status: "canceled" } },
                                                { notEqual: { status: "incomplete_expired" } },
                                            ]
                                            : { equal: { status: params.status } };
                                const subscriptions = await tables.subscriptions.read({
                                    conditions: [
                                        "and",
                                        equalityQuery,
                                        statusQuery,
                                    ],
                                });
                                return stripeResponse({
                                    object: "list",
                                    data: subscriptions,
                                });
                            },
                        };
                    })(),
                };
            }
        };
    }

    const mockStripeShape = {
        prices: true,
        accounts: true,
        invoices: true,
        products: true,
        customers: true,
        setupIntents: true,
        subscriptions: true,
        paymentMethods: true,
        paymentIntents: true,
        checkoutSessions: true,
    };

    async function mockStripeTables({ tableStorage }) {
        const database = flex({
            shape: mockStripeShape,
            flexStorage: tableStorage,
            makeTableName: makeTableNameWithHyphens,
        });
        return database.tables;
    }

    async function makeMetaDataTables({ tableStorage }) {
        const database = flex({
            shape: {
                paymentMethodMetaData: true
            },
            flexStorage: tableStorage,
            makeTableName: makeTableNameWithHyphens,
        });
        return database.tables;
    }

    function prepareMockStripeOperations({ rando, stripeTables, metaDataTables, stripeLiaison, recentDetails, dispatchWebhook, }) {
        const mockHelpers = {
            async setPaymentMethod({ customer, stripeLiaisonAccount }) {
                await stripeTables.paymentMethods.delete(find({ customer }));
                const paymentMethod = await stripeLiaisonAccount.paymentMethods.create({
                    customer,
                    type: "card",
                    card: {
                        brand: "fakevisa",
                        country: "canada",
                        exp_month: 1,
                        exp_year: 2032,
                        last4: rando.randomSequence(4, [..."0123456789"]),
                    },
                });
                return paymentMethod;
            },
            async createSetupIntent({ customer, paymentMethod, stripeLiaisonAccount }) {
                const setupIntent = await stripeLiaisonAccount.setupIntents.create({
                    customer,
                    payment_method: paymentMethod.id,
                });
                return setupIntent;
            },
            async createSubscription({ customer, paymentMethod, stripeLiaisonAccount, items, }) {
                const subscription = await stripeLiaisonAccount.subscriptions.create({
                    customer,
                    default_payment_method: paymentMethod.id,
                    items,
                });
                return subscription;
            },
        };
        return {
            async linkStripeAccount(stripeAccountId) {
                await dispatchWebhook("account.updated", stripeAccountId, {
                    id: stripeAccountId,
                    email: "fake-stripe-account-email@xiome.io",
                    charges_enabled: true,
                    payouts_enabled: true,
                    details_submitted: true,
                });
            },
            async linkStripeAccountThatIsIncomplete(stripeAccountId) {
                await dispatchWebhook("account.updated", stripeAccountId, {
                    id: stripeAccountId,
                    email: "fake-stripe-account-email@xiome.io",
                    charges_enabled: false,
                    payouts_enabled: false,
                    details_submitted: false,
                });
            },
            async checkoutSubscriptionTier(stripeAccountId, stripeSessionId) {
                const session = await stripeTables
                    .checkoutSessions.readOne(find({ id: stripeSessionId }));
                const stripeLiaisonAccount = stripeLiaison.account(stripeAccountId);
                const customer = session.customer;
                const paymentMethod = await mockHelpers.setPaymentMethod({
                    customer,
                    stripeLiaisonAccount,
                });
                const subscription = await mockHelpers.createSubscription({
                    customer,
                    paymentMethod,
                    stripeLiaisonAccount,
                    items: session.line_items.data.map(item => ({
                        price: getStripeId(item.price),
                        quantity: item.quantity,
                    })),
                });
                session.subscription = subscription.id;
                await stripeTables.checkoutSessions.update({
                    ...find({ id: stripeSessionId }),
                    write: { subscription: subscription.id },
                });
                // await dispatchWebhook("checkout.session.completed", stripeAccountId, {
                // 	customer,
                // 	mode: "subscription",
                // 	subscription,
                // 	client_reference_id: session.client_reference_id,
                // 	payment_intent: recentDetails.subscriptionCreation.paymentIntent,
                // })
            },
            async createNewDefaultPaymentMethod({ stripeAccountId, customer, isFailing, }) {
                const stripeLiaisonAccount = stripeLiaison.account(stripeAccountId);
                const paymentMethod = await mockHelpers
                    .setPaymentMethod({ stripeLiaisonAccount, customer });
                await metaDataTables.paymentMethodMetaData.create({
                    id: paymentMethod.id,
                    isFailing
                });
                await stripeLiaisonAccount.customers.update(customer, {
                    invoice_settings: {
                        default_payment_method: paymentMethod.id,
                    },
                });
                return paymentMethod;
            },
            async removeAllPaymentMethods(customer) {
                await stripeTables.paymentMethods.delete(find({ customer }));
            },
            wipeAll: {
                async customers() {
                    await stripeTables.customers.delete({ conditions: false });
                },
                async products() {
                    await stripeTables.products.delete({ conditions: false });
                },
            },
        };
    }

    function prepareWebhookDispatcherWithAntiCircularity(pointer) {
        let webhookCircularity;
        return (async function dispatchWebhook(type, stripeAccountId, object) {
            if (webhookCircularity)
                throw new Error(`webhook circularity error "${webhookCircularity}" -> "${type}"`);
            webhookCircularity = type;
            const result = await pointer.webhooks[type]({
                type,
                account: stripeAccountId,
                data: { object },
            });
            webhookCircularity = undefined;
            return result;
        });
    }

    async function mockStripeCircuit({ logger, webRoot, rando, tableStorage, storeDatabaseRaw, prepareRoleManager, }) {
        const stripeTables = await mockStripeTables({ tableStorage });
        const metaDataTables = await makeMetaDataTables({ tableStorage });
        const recentDetails = {};
        const pointer = { webhooks: undefined };
        const dispatchWebhook = prepareWebhookDispatcherWithAntiCircularity(pointer);
        const stripeLiaison = mockStripeLiaison({
            rando,
            rootUrl: webRoot,
            recentDetails,
            metaDataTables,
            tables: stripeTables,
            dispatchWebhook,
        });
        pointer.webhooks = stripeWebhooks({
            logger,
            stripeLiaison,
            storeDatabaseRaw,
            prepareRoleManager,
        });
        const mockStripeOperations = prepareMockStripeOperations({
            rando,
            stripeTables,
            metaDataTables,
            stripeLiaison,
            recentDetails,
            dispatchWebhook,
        });
        return {
            stripe: undefined,
            stripeLiaison,
            stripeWebhooks: pointer.webhooks,
            mockStripeOperations,
        };
    }

    async function assimilateStripe({ databaseRaw, mockStorage, config, rando, configureStripe, }) {
        const logger = console;
        const storeDatabaseRaw = subsection(databaseRaw, tables => tables.store);
        const permissionsDatabaseRaw = subsection(databaseRaw, tables => tables.auth.permissions);
        const prepareRoleManager = (buildFunctionToPrepareRoleManager({
            rando,
            permissionsDatabaseRaw,
        }));
        if (config.stripe === "mock-mode") {
            return mockStripeCircuit({
                webRoot: config.webRoot,
                rando,
                logger,
                tableStorage: mockStorage,
                storeDatabaseRaw,
                prepareRoleManager,
            });
        }
        else {
            return configureStripe({
                config,
                storeDatabaseRaw,
                prepareRoleManager,
            });
        }
    }

    function mockDacastClient({ goodApiKey }) {
        let count = 1;
        function fakeContent(type) {
            const id = count++;
            return {
                online: true,
                id: `${type}-${id.toString()}`,
                title: `content ${id}`,
                creation_date: "1999-12-25",
            };
        }
        function fakeEmbedCode(type) {
            return type === "iframe"
                ? `<iframe src="https://iframe.dacast.com/vod/0ffd60be-91b7-22b0-1353-7dba7af43261/e9cc39f7-83ea-19db-2c0e-672beeec1547" width="100%" height="100%" frameborder="0" scrolling="no" allow="autoplay" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>`
                : `<script id="0ffd60be-91b7-22b0-1353-7dba7af43261-vod-e9cc39f7-83ea-19db-2c0e-672beeec1547" width="100%" height="100%" src="https://player.dacast.com/js/player.js?contentId=0ffd60be-91b7-22b0-1353-7dba7af43261-vod-e9cc39f7-83ea-19db-2c0e-672beeec1547"  class="dacast-video"></script>`;
        }
        const data = {
            vods: [0, 0].map(() => fakeContent("vod")),
            channels: [0, 0].map(() => fakeContent("channel")),
            playlists: [0, 0].map(() => fakeContent("playlist")),
        };
        return ({ apiKey }) => {
            function resource(content) {
                function fun(f) {
                    return ((...args) => {
                        if (apiKey !== goodApiKey)
                            throw new Error("mock dacast invalid api key");
                        return f(...args);
                    });
                }
                function paginate(content) {
                    return {
                        totalCount: content.length.toString(),
                        data: content,
                        paging: {
                            last: "",
                            next: "",
                            previous: "",
                            self: "",
                        },
                    };
                }
                return {
                    get: fun(async () => paginate(content)),
                    id: (contentId) => ({
                        get: fun(async () => content.find(c => c.id === contentId)),
                        embed: (embedType) => ({
                            get: fun(async () => ({ code: fakeEmbedCode(embedType) })),
                        }),
                    }),
                };
            }
            return {
                vods: resource(data.vods),
                channels: resource(data.channels),
                playlists: resource(data.playlists),
            };
        };
    }

    function mockVerifyDacastApiKey({ goodApiKey }) {
        return async (apiKey) => apiKey === goodApiKey;
    }

    function mockDacastSdk({ goodApiKey }) {
        const getClient = apiKey => mockDacastClient({ goodApiKey })({ apiKey });
        return {
            getClient,
            verifyApiKey: mockVerifyDacastApiKey({ goodApiKey }),
        };
    }

    function assimilateDacast({ config, configureDacast, }) {
        if (config.dacast === "mock-mode")
            return mockDacastSdk({ goodApiKey });
        else if (config.dacast === true)
            return configureDacast();
        else
            throw new Error("unknown dacast config");
    }

    const databaseShapeUnisolated = {
        apps: {
            registrations: true,
            owners: true,
        },
    };
    const databaseShapeRequiresAppIsolation = {
        auth: {
            users: {
                accounts: true,
                emails: true,
                latestLogins: true,
                profiles: true,
            },
            permissions: {
                privilege: true,
                role: true,
                roleHasPrivilege: true,
                userHasRole: true,
            },
        },
        example: {
            examplePosts: true,
        },
        questions: {
            likes: true,
            reports: true,
            answerPosts: true,
            questionPosts: true,
        },
        store: {
            customers: true,
            connect: {
                accounts: true,
                active: true,
            },
            subscriptions: {
                plans: true,
                tiers: true,
            },
        },
        videos: {
            dacastAccountLinks: true,
            viewDacast: true,
            viewPrivileges: true,
        },
        notes: {
            notes: true,
            questionDetails: true,
        },
    };
    const databaseShape = {
        ...databaseShapeRequiresAppIsolation,
        ...databaseShapeUnisolated,
    };

    function applyDatabaseWrapping(database) {
        return subsection(database, tables => {
            const wrappedTables = UnconstrainedTable.wrapTables(tables);
            const nakedTables = objectMap(databaseShapeUnisolated, (v, key) => database.tables[key]);
            return {
                ...wrappedTables,
                ...nakedTables,
            };
        });
    }

    function mockDatabaseUnwrapped(flexStorage) {
        return flex({
            flexStorage,
            shape: databaseShape,
            makeTableName: makeTableNameWithHyphens,
        });
    }

    async function assimilateDatabase({ config, configureMongo, configureMockStorage, }) {
        const mockStorage = config.database === "mock-storage"
            ? configureMockStorage()
            : memoryFlexStorage();
        let databaseRaw = applyDatabaseWrapping(config.database === "mock-storage"
            ? mockDatabaseUnwrapped(mockStorage)
            : await configureMongo({
                databaseShape,
                config: { ...config, database: config.database },
            }));
        { // bake app tables
            const { appId, home, label, origins } = config.platform.appDetails;
            const appRegistrationsTableWithFallback = fallback({
                table: databaseRaw.tables.apps.registrations,
                fallbackRows: [
                    {
                        appId: Id.fromString(appId),
                        home,
                        label,
                        origins: originsToDatabase(origins),
                        archived: false,
                    }
                ],
            });
            databaseRaw = subsection(databaseRaw, tables => {
                return {
                    ...tables,
                    apps: {
                        ...tables.apps,
                        registrations: appRegistrationsTableWithFallback,
                    },
                };
            });
        }
        return {
            databaseRaw,
            mockStorage,
        };
    }

    function makeNotesDepositBox({ rando, database }) {
        async function sendNotes(drafts) {
            const notes = drafts.map(draft => {
                const noteId = rando.randomId();
                return {
                    noteBase: {
                        ...draft,
                        noteId,
                        to: Id.fromString(draft.to),
                        from: draft.from === undefined
                            ? undefined
                            : Id.fromString(draft.from),
                        old: false,
                        time: Date.now(),
                    },
                    noteDetails: draft.details,
                };
            });
            await database.tables.notes.notes.create(...notes.map(n => n.noteBase));
            return notes.map(({ noteBase: { noteId } }) => ({
                noteId: noteId.toString()
            }));
        }
        async function sendNote(draft) {
            const [sent] = await sendNotes([draft]);
            return sent;
        }
        return {
            sendNotes,
            sendNote,
        };
    }

    function centeredPopupFeatures(width, height) {
        const { outerWidth, outerHeight, screenY, screenX } = window.top;
        const top = ((outerHeight / 2) + screenY - (height / 2)) / 2;
        const left = (outerWidth / 2) + screenX - (width / 2);
        return `
		popup,
		width=${width},
		height=${height},
		top=${top},
		left=${left},
		toolbar=no,
		location=no,
		status=no,
		menubar=no,
		scrollbars=yes,
		resizable=yes
	`;
    }

    const popupTrustedOrigins = [
        "https://xiome.io",
        "https://stage.xiome.io",
        "http://localhost:8080",
        "http://localhost:5000",
    ];

    function isSafeOriginForPopupReturn(o) {
        return popupTrustedOrigins.includes(o);
    }

    async function openPopupAndWaitForResult({ url, width = 480, height = 640, popupId, handleSecretMockCommand = async () => { }, }) {
        const popup = window.open(url, "_blank", centeredPopupFeatures(width, height));
        return new Promise(resolve => {
            function finish(result) {
                clearInterval(interval);
                window.removeEventListener("message", handleMessage);
                resolve(result);
            }
            function handleMessage(event) {
                var _a;
                const isFromSafeOrigin = isSafeOriginForPopupReturn(event.origin);
                const isMatchingPopupId = ((_a = event.data) === null || _a === void 0 ? void 0 : _a.popupId) === popupId;
                const isSecretMockCommand = event.data.secretMockCommand === true;
                if (isFromSafeOrigin) {
                    if (isSecretMockCommand)
                        handleSecretMockCommand(event.data).then(() => {
                            popup.postMessage({
                                secretMockCommand: true,
                                commandId: event.data.commandId,
                            }, "*");
                        });
                    else if (isMatchingPopupId) {
                        const { popupId, ...details } = event.data;
                        finish({ popupId, details });
                    }
                    else
                        console.warn(`ignoring message for other popup "${event.data.popupId}":`, event.data);
                }
                else
                    console.warn(`ignoring message from origin "${event.origin}":`, event.data);
            }
            window.addEventListener("message", handleMessage);
            const interval = setInterval(() => {
                if (popup.closed)
                    finish({ popupId });
            }, 100);
        });
    }

    function mockStripePopups({ mockStripeOperations }) {
        return {
            async connect({ popupId, stripeAccountId, stripeAccountSetupLink }) {
                return openPopupAndWaitForResult({
                    popupId,
                    url: stripeAccountSetupLink,
                    handleSecretMockCommand: mockStripeOperations
                        ? async (command) => {
                            if (command.type === "complete")
                                await mockStripeOperations.linkStripeAccount(stripeAccountId);
                            else if (command.type === "incomplete")
                                await mockStripeOperations.linkStripeAccountThatIsIncomplete(stripeAccountId);
                        }
                        : async () => { },
                });
            },
            async login({ popupId, stripeAccountId, stripeLoginLink }) {
                return openPopupAndWaitForResult({
                    popupId,
                    url: stripeLoginLink,
                    handleSecretMockCommand: mockStripeOperations
                        ? async (command) => {
                            if (command.type === "complete")
                                await mockStripeOperations.linkStripeAccount(stripeAccountId);
                            else if (command.type === "incomplete")
                                await mockStripeOperations.linkStripeAccountThatIsIncomplete(stripeAccountId);
                        }
                        : async () => { },
                });
            },
            async checkoutSubscription({ popupId, stripeSessionUrl, stripeSessionId, stripeAccountId }) {
                return openPopupAndWaitForResult({
                    popupId,
                    url: stripeSessionUrl,
                    handleSecretMockCommand: mockStripeOperations
                        ? async (command) => {
                            if (command.type === "success")
                                await mockStripeOperations.checkoutSubscriptionTier(stripeAccountId, stripeSessionId);
                        }
                        : async () => { },
                });
            },
            async openStoreCustomerPortal({ popupId, customer, stripeAccountId, stripeSessionUrl }) {
                return openPopupAndWaitForResult({
                    popupId,
                    url: stripeSessionUrl,
                    handleSecretMockCommand: mockStripeOperations
                        ? async (command) => {
                            if (command.type === "success") {
                                const isFailing = false;
                                await mockStripeOperations.createNewDefaultPaymentMethod({
                                    customer, isFailing, stripeAccountId
                                });
                            }
                            else if (command.type === "failure") {
                                const isFailing = true;
                                await mockStripeOperations.createNewDefaultPaymentMethod({
                                    customer, isFailing, stripeAccountId
                                });
                            }
                            else if (command.type === "detach") {
                                await mockStripeOperations.removeAllPaymentMethods(customer);
                            }
                        }
                        : async () => { },
                });
            },
        };
    }

    function prepareBackend(configurators) {
        return async function configureApi(config) {
            const rando = await getRando();
            const options = { ...configurators, config, rando };
            const emails = assimilateEmails(options);
            const { databaseRaw, mockStorage } = await assimilateDatabase(options);
            const { signToken, verifyToken } = assimilateCrypto(options);
            const { stripeLiaison, mockStripeOperations } = (await assimilateStripe({
                ...options,
                databaseRaw,
                mockStorage,
            }));
            const stripePopups = mockStripePopups({ mockStripeOperations });
            const dacastSdk = assimilateDacast(options);
            const api = await assimilateApi({
                ...options,
                dacastSdk,
                databaseRaw,
                stripeLiaison,
                signToken,
                verifyToken,
                sendLoginEmail: emails.sendLoginEmail,
            });
            return {
                rando,
                api,
                config,
                emails,
                databaseRaw,
                stripeLiaison,
                stripePopups,
                platformAppId: config.platform.appDetails.appId,
                prepareNotesDepositBox: (appId) => makeNotesDepositBox({
                    rando,
                    database: UnconstrainedTable.constrainDatabaseForApp({
                        appId,
                        database: databaseRaw,
                    }),
                }),
                mockBrowser: async ({ appOrigin }) => mockBrowser({
                    api,
                    appOrigin,
                    mockStripeOperations,
                }),
            };
        };
    }

    class ConfigNotSupportedInBrowserError extends Error {
        constructor(message) {
            super(message);
        }
    }
    function nope(message) {
        return function () {
            throw new ConfigNotSupportedInBrowserError(message);
        };
    }
    const backendForBrowser = (storage) => prepareBackend({
        configureStripe: nope("config.stripe not supported in browser"),
        configureMongo: nope("config.database.mongo not supported in browser"),
        configureMailgun: nope("config.email.mailgun not supported in browser"),
        configureTokenFunctions: nope("config.crypto.keys must be 'mock-mode' in browser"),
        configureMockStorage: () => storage,
        configureDacast: nope("config.dacast must be in 'mock-mode' in browser"),
    });

    async function mockConnectApp({ root, appOrigin, origins, storage, appWindowLink, }) {
        const backend = await backendForBrowser(storage)(mockConfig({
            root,
            platformHome: appWindowLink,
            platformOrigins: origins,
        }));
        backend.emails.disableEmails();
        const ownerEmail = "creative@xiome.io";
        const adminEmail = "admin@xiome.io";
        let appId = await storage.read("mock-app");
        if (!appId) {
            appId = await mockRegisterApp({
                backend,
                ownerEmail,
                adminEmail,
                appOrigins: origins,
                platformOrigin: appOrigin,
            });
            await storage.write("mock-app", appId);
        }
        console.log(`mock: app owner email "${ownerEmail}"`);
        backend.emails.enableEmails();
        const { remote, authMediator, setMockLatency } = await mockWiredRemote({
            appId,
            backend,
            storage,
            appOrigin,
        });
        const { stripePopups } = backend;
        const chatConnect = await chatMockClientEntirely(storage);
        // const chatConnect = chatSocketClient("ws://localhost:8001/")
        return { appId, remote, storage, authMediator, backend, stripePopups, setMockLatency, chatConnect };
    }

    async function mockConnectPlatform({ root, platformHome, storage, }) {
        const appOrigin = new URL(platformHome).origin;
        const backend = await backendForBrowser(storage)(mockConfig({
            root,
            platformHome,
            platformOrigins: [appOrigin],
        }));
        const appId = backend.platformAppId;
        const { remote, authMediator, setMockLatency } = await mockWiredRemote({
            appId,
            backend,
            storage,
            appOrigin,
        });
        const { stripePopups } = backend;
        const chatConnect = await chatMockClientEntirely(storage);
        // const chatConnect = chatSocketClient("ws://localhost:8001/")
        return { appId, remote, storage, authMediator, backend, stripePopups, setMockLatency, chatConnect };
    }

    async function mockConnect(config) {
        const options = {
            root: config.root,
            origins: [window.location.origin],
            appOrigin: window.location.origin,
            storage: simpleFlexStorage(window.localStorage),
            platformHome: window.location.href,
            appWindowLink: window.location.href,
        };
        return config.mode === "platform"
            ? await mockConnectPlatform(options)
            : await mockConnectApp(options);
    }

    const nap = (milliseconds = 0) => new Promise(resolve => setTimeout(resolve, milliseconds));

    function hitchie(func, process) {
        return ((...args) => process(func, ...args));
    }

    function applyMockHacks({ connection, frontend }) {
        const { loginService } = connection.remote.auth.users;
        loginService.sendLoginLink = hitchie(loginService.sendLoginLink, async (func, ...args) => {
            await func(...args);
            const details = connection.backend.emails.recallLatestLoginEmail();
            console.log("mock: logging in...");
            await nap(1000);
            await frontend.models.accessModel.login(details.loginToken);
            console.log(`mock: logged in as ${details.to}`);
        });
        // connection.popups.triggerStripeConnectPopup = hitchie(
        // 	connection.popups.triggerStripeConnectPopup,
        // 	async(...args) => {
        // 		console.log("mock: bank popup", args)
        // 	},
        // )
        const notesDepositBox = connection.backend.prepareNotesDepositBox(Id.fromString(frontend.appId));
        window["fakeNote"] = async (draft) => {
            var _a, _b;
            const userId = (_b = (_a = frontend.models.accessModel.getAccess()) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.userId;
            const augmentedDraft = {
                from: undefined,
                details: {},
                text: "this is a message note "
                    + connection.backend.rando.randomId().toString().slice(0, 8),
                title: "this is a message title "
                    + connection.backend.rando.randomId().toString().slice(0, 8),
                type: "message",
                to: userId,
                ...draft,
            };
            if (!augmentedDraft.to)
                console.warn("who do you want to send this note to?\n('to' user id was not provided)");
            else {
                const { noteId } = await notesDepositBox.sendNote(augmentedDraft);
                console.log(`note sent! ${noteId}`);
            }
        };
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$1=window,e$3=t$1.ShadowRoot&&(void 0===t$1.ShadyCSS||t$1.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$4=new WeakMap;let o$4 = class o{constructor(t,e,n){if(this._$cssResult$=!0,n!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$3&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=n$4.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&n$4.set(s,t));}return t}toString(){return this.cssText}};const r$2=t=>new o$4("string"==typeof t?t:t+"",void 0,s$3),i$3=(t,...e)=>{const n=1===t.length?t[0]:e.reduce(((e,s,n)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[n+1]),t[0]);return new o$4(n,t,s$3)},S$1=(s,n)=>{e$3?s.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((e=>{const n=document.createElement("style"),o=t$1.litNonce;void 0!==o&&n.setAttribute("nonce",o),n.textContent=e.cssText,s.appendChild(n);}));},c$1=e$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$2(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var s$2;const e$2=window,r$1=e$2.trustedTypes,h$1=r$1?r$1.emptyScript:"",o$3=e$2.reactiveElementPolyfillSupport,n$3={toAttribute(t,i){switch(i){case Boolean:t=t?h$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},a$1=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:n$3,reflect:!1,hasChanged:a$1};let d$1 = class d extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this.u();}static addInitializer(t){var i;this.finalize(),(null!==(i=this.h)&&void 0!==i?i:this.h=[]).push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Ep(s,i);void 0!==e&&(this._$Ev.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),void 0!==t.h&&(this.h=[...t.h]),this.elementProperties=new Map(t.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(c$1(i));}else void 0!==i&&s.push(c$1(i));return s}static _$Ep(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}u(){var t;this._$E_=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Eg(),this.requestUpdate(),null===(t=this.constructor.h)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$ES)&&void 0!==i?i:this._$ES=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$ES)||void 0===i||i.splice(this._$ES.indexOf(t)>>>0,1);}_$Eg(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Ei.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return S$1(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$EO(t,i,s=l$2){var e;const r=this.constructor._$Ep(t,s);if(void 0!==r&&!0===s.reflect){const h=(void 0!==(null===(e=s.converter)||void 0===e?void 0:e.toAttribute)?s.converter:n$3).toAttribute(i,s.type);this._$El=t,null==h?this.removeAttribute(r):this.setAttribute(r,h),this._$El=null;}}_$AK(t,i){var s;const e=this.constructor,r=e._$Ev.get(t);if(void 0!==r&&this._$El!==r){const t=e.getPropertyOptions(r),h="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==(null===(s=t.converter)||void 0===s?void 0:s.fromAttribute)?t.converter:n$3;this._$El=r,this[r]=h.fromAttribute(i,t.type),this._$El=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||a$1)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$El!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$E_=this._$Ej());}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach(((t,i)=>this[i]=t)),this._$Ei=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$Ek();}catch(t){throw i=!1,this._$Ek(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$ES)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$EO(i,this[i],t))),this._$EC=void 0),this._$Ek();}updated(t){}firstUpdated(t){}};d$1.finalized=!0,d$1.elementProperties=new Map,d$1.elementStyles=[],d$1.shadowRootOptions={mode:"open"},null==o$3||o$3({ReactiveElement:d$1}),(null!==(s$2=e$2.reactiveElementVersions)&&void 0!==s$2?s$2:e$2.reactiveElementVersions=[]).push("1.6.1");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var t;const i$2=window,s$1=i$2.trustedTypes,e$1=s$1?s$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,o$2="$lit$",n$2=`lit$${(Math.random()+"").slice(9)}$`,l$1="?"+n$2,h=`<${l$1}>`,r=document,d=()=>r.createComment(""),u=t=>null===t||"object"!=typeof t&&"function"!=typeof t,c=Array.isArray,v=t=>c(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),a="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_=/-->/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=w(1),b=w(2),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1),P=(t,i)=>{const s=t.length-1,l=[];let r,d=2===i?"<svg>":"",u=f;for(let i=0;i<s;i++){const s=t[i];let e,c,v=-1,a=0;for(;a<s.length&&(u.lastIndex=a,c=u.exec(s),null!==c);)a=u.lastIndex,u===f?"!--"===c[1]?u=_:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(r=RegExp("</"+c[2],"g")),u=p):void 0!==c[3]&&(u=p):u===p?">"===c[0]?(u=null!=r?r:f,v=-1):void 0===c[1]?v=-2:(v=u.lastIndex-c[2].length,e=c[1],u=void 0===c[3]?p:'"'===c[3]?$:g):u===$||u===g?u=p:u===_||u===m?u=f:(u=p,r=void 0);const w=u===p&&t[i+1].startsWith("/>")?" ":"";d+=u===f?s+h:v>=0?(l.push(e),s.slice(0,v)+o$2+s.slice(v)+n$2+w):s+n$2+(-2===v?(l.push(void 0),i):w);}const c=d+(t[s]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==e$1?e$1.createHTML(c):c,l]};class V{constructor({strings:t,_$litType$:i},e){let h;this.parts=[];let r=0,u=0;const c=t.length-1,v=this.parts,[a,f]=P(t,i);if(this.el=V.createElement(a,e),C.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(h=C.nextNode())&&v.length<c;){if(1===h.nodeType){if(h.hasAttributes()){const t=[];for(const i of h.getAttributeNames())if(i.endsWith(o$2)||i.startsWith(n$2)){const s=f[u++];if(t.push(i),void 0!==s){const t=h.getAttribute(s.toLowerCase()+o$2).split(n$2),i=/([.?@])?(.*)/.exec(s);v.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?k:"?"===i[1]?I:"@"===i[1]?L:R});}else v.push({type:6,index:r});}for(const i of t)h.removeAttribute(i);}if(y.test(h.tagName)){const t=h.textContent.split(n$2),i=t.length-1;if(i>0){h.textContent=s$1?s$1.emptyScript:"";for(let s=0;s<i;s++)h.append(t[s],d()),C.nextNode(),v.push({type:2,index:++r});h.append(t[i],d());}}}else if(8===h.nodeType)if(h.data===l$1)v.push({type:2,index:r});else {let t=-1;for(;-1!==(t=h.data.indexOf(n$2,t+1));)v.push({type:7,index:r}),t+=n$2.length-1;}r++;}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){var o,n,l,h;if(i===T)return i;let r=void 0!==e?null===(o=s._$Co)||void 0===o?void 0:o[e]:s._$Cl;const d=u(i)?void 0:i._$litDirective$;return (null==r?void 0:r.constructor)!==d&&(null===(n=null==r?void 0:r._$AO)||void 0===n||n.call(r,!1),void 0===d?r=void 0:(r=new d(t),r._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Co)&&void 0!==l?l:h._$Co=[])[e]=r:s._$Cl=r),void 0!==r&&(i=N(t,r._$AS(t,i.values),r,e)),i}class S{constructor(t,i){this.u=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}v(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:r).importNode(s,!0);C.currentNode=o;let n=C.nextNode(),l=0,h=0,d=e[0];for(;void 0!==d;){if(l===d.index){let i;2===d.type?i=new M(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new z(n,this,t)),this.u.push(i),d=e[++h];}l!==(null==d?void 0:d.index)&&(n=C.nextNode(),l++);}return o}p(t){let i=0;for(const s of this.u)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{constructor(t,i,s,e){var o;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cm=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cm}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===(null==t?void 0:t.nodeType)&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),u(t)?t===A||null==t||""===t?(this._$AH!==A&&this._$AR(),this._$AH=A):t!==this._$AH&&t!==T&&this.g(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):v(t)?this.k(t):this.g(t);}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t));}g(t){this._$AH!==A&&u(this._$AH)?this._$AA.nextSibling.data=t:this.T(r.createTextNode(t)),this._$AH=t;}$(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=V.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.p(s);else {const t=new S(o,this),i=t.v(this.options);t.p(s),this.T(i),this._$AH=t;}}_$AC(t){let i=E.get(t.strings);return void 0===i&&E.set(t.strings,i=new V(t)),i}k(t){c(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new M(this.S(d()),this.S(d()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cm=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class R{constructor(t,i,s,e,o){this.type=1,this._$AH=A,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=A;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=N(this,t,i,0),n=!u(t)||t!==this._$AH&&t!==T,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=N(this,e[s+l],i,l),h===T&&(h=this._$AH[l]),n||(n=!u(h)||h!==this._$AH[l]),h===A?t=A:t!==A&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.j(t);}j(t){t===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class k extends R{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===A?void 0:t;}}const H=s$1?s$1.emptyScript:"";class I extends R{constructor(){super(...arguments),this.type=4;}j(t){t&&t!==A?this.element.setAttribute(this.name,H):this.element.removeAttribute(this.name);}}class L extends R{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=N(this,t,i,0))&&void 0!==s?s:A)===T)return;const e=this._$AH,o=t===A&&e!==A||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==A&&(e===A||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const j=i$2.litHtmlPolyfillSupport;null==j||j(V,M),(null!==(t=i$2.litHtmlVersions)&&void 0!==t?t:i$2.litHtmlVersions=[]).push("2.7.0");const B=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new M(i.insertBefore(d(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var l,o$1;class s extends d$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=B(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!1);}render(){return T}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n$1=globalThis.litElementPolyfillSupport;null==n$1||n$1({LitElement:s});(null!==(o$1=globalThis.litElementVersions)&&void 0!==o$1?o$1:globalThis.litElementVersions=[]).push("3.3.0");

    function mixinInitiallyHidden(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                if (this.hasAttribute("initially-hidden"))
                    this.removeAttribute("initially-hidden");
            }
        };
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const i$1=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$1(e,n)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n);}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n);}};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function i(i,n){return o({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]};}return t}})}

    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

    function arrayize(item) {
        return [item].flat();
    }
    const notUndefined = (x) => x !== undefined;
    function combineStyles(parentStyles, newStyles) {
        var _a;
        const styles = [
            ...((_a = arrayize(parentStyles)) !== null && _a !== void 0 ? _a : []),
            ...arrayize(newStyles),
        ];
        return styles
            .flat()
            .filter(notUndefined);
    }
    function mixinStyles(...newStyles) {
        return function (Base) {
            var _a;
            return _a = class extends Base {
                },
                _a.styles = combineStyles(Base.styles, newStyles),
                _a;
        };
    }

    const themeComponents = (theme, components) => {
        return objectMap(components, Component => mixinStyles(theme)(Component));
    };

    /**
     * Convert a camel-case name into a dashed name
     * - for example
     *       dashify("BigManStyle")
     *       //> "big-man-style"
     */
    function dashify(camel) {
        return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
    }

    function registerComponents(components) {
        for (const [name, component] of Object.entries(components))
            customElements.define(dashify(name), component);
    }

    function mixinFocusable(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                this.setAttribute("focusable", "");
            }
        };
    }

    var __classPrivateFieldGet$m = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$b = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function mixinSnapstateSubscriptions(...subscribes) {
        return function (Base) {
            var _unsubscribes, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _unsubscribes.set(this, []);
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        const update = () => { this.requestUpdate(); };
                        __classPrivateFieldSet$b(this, _unsubscribes, subscribes.map(subscribe => subscribe(update)), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        for (const unsubscribe of __classPrivateFieldGet$m(this, _unsubscribes, "f"))
                            unsubscribe();
                        __classPrivateFieldSet$b(this, _unsubscribes, [], "f");
                    }
                },
                _unsubscribes = new WeakMap(),
                _a;
        };
    }

    function mixinShare(providedShare) {
        return function (Base) {
            return class extends Base {
                get share() {
                    return providedShare;
                }
            };
        };
    }
    function mixinRequireShare(name) {
        return function (Base) {
            return class extends Base {
                get share() {
                    throw new Error(`share required by component${name ? " " + name : ""}`);
                }
            };
        };
    }

    var __classPrivateFieldSet$a = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$l = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    function mixinTicker(period) {
        return function (Base) {
            var _interval, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _interval.set(this, void 0);
                    }
                    tick() { }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$a(this, _interval, setInterval(() => {
                            this.tick();
                            this.requestUpdate();
                        }, period), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        clearInterval(__classPrivateFieldGet$l(this, _interval, "f"));
                    }
                },
                _interval = new WeakMap(),
                _a;
        };
    }

    var __classPrivateFieldGet$k = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$9 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _Component_subscriptions, _Component_unsubscribe;
    class Component extends mixinInitiallyHidden(s) {
        constructor() {
            super(...arguments);
            _Component_subscriptions.set(this, []);
            _Component_unsubscribe.set(this, () => { });
        }
        init() { }
        firstUpdated(changes) {
            super.firstUpdated(changes);
            this.init();
        }
        addSubscription(subscribe) {
            __classPrivateFieldGet$k(this, _Component_subscriptions, "f").push(subscribe);
            if (this.isConnected) {
                const unsubscribe = subscribe();
                const existingUnsubscribe = __classPrivateFieldGet$k(this, _Component_unsubscribe, "f");
                __classPrivateFieldSet$9(this, _Component_unsubscribe, () => {
                    unsubscribe();
                    existingUnsubscribe();
                }, "f");
            }
        }
        subscribe() {
            const unsubscribes = __classPrivateFieldGet$k(this, _Component_subscriptions, "f").map(s => s());
            return () => unsubscribes.forEach(u => u());
        }
        connectedCallback() {
            super.connectedCallback();
            __classPrivateFieldSet$9(this, _Component_unsubscribe, this.subscribe(), "f");
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            __classPrivateFieldGet$k(this, _Component_unsubscribe, "f").call(this);
            __classPrivateFieldSet$9(this, _Component_unsubscribe, () => { }, "f");
        }
        render() {
            throw new Error("component render method not implemented");
        }
    }
    _Component_subscriptions = new WeakMap(), _Component_unsubscribe = new WeakMap();

    var theme = i$3 `

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

:focus {
	outline: var(--focus-outline, 2px solid cyan);
}

:host-context(:focus) {
	outline: 0 !important;
}

`;

    var styles$u = i$3 `

:host {
	display: inline-block;
	position: relative;
	width: 6em;
}

:host::before {
	opacity: 0;
	content: "copied!";
	display: block;
	position: absolute;
	top: -0.5em;
	right: -0.5em;
	background: #0a0c;
	padding: 0 0.5em;
	border-radius: 1em;
	pointer-events: none;
	z-index: 1;
}

:host(:not([copied]))::before {
	transition: opacity 500ms ease;
}

:host([copied])::before {
	opacity: 1;
}

button {
	font: inherit;
	color: inherit;
	background: transparent;
	width: 100%;
}

.container {
	position: relative;
	display: flex;
	flex-direction: row;
	user-select: none;
	cursor: pointer;
	border: none;
}

.content {
	display: flex;
	justify-content: row;
}

.label::after {
	content: ":";
	margin-right: 0.2em;
}

.id {
	opacity: 0.75;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.copy svg {
	width: 1em;
	height: 1em;
}

.copy {
	opacity: 0.4;
	transition: opacity 100ms linear;
}

.container:hover .copy {
	opacity: 0.9;
}

.container:active .copy {
	opacity: 1;
}

`;

    var clipboardIcon = b `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clipboard"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>`;

    var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioId = class XioId extends Component {
        constructor() {
            super(...arguments);
            this.copied = false;
        }
        async copy() {
            try {
                await navigator.clipboard.writeText(this.id);
                const activeElement = document.activeElement;
                if (activeElement)
                    activeElement.blur();
                if (this.copyTimeout) {
                    clearTimeout(this.copyTimeout);
                }
                this.copied = true;
                this.copyTimeout = setTimeout(() => {
                    this.copied = false;
                    this.copyTimeout = undefined;
                }, 1000);
            }
            catch (error) {
                console.error("failed to copy");
            }
        }
        render() {
            return x `
			<button class=container @click=${this.copy}>
				<div class=id>${this.id}</div>
				<div class=copy>
					${clipboardIcon}
				</div>
			</button>
		`;
        }
    };
    __decorate$v([
        e()
    ], XioId.prototype, "id", void 0);
    __decorate$v([
        e({ type: Boolean, reflect: true })
    ], XioId.prototype, "copied", void 0);
    XioId = __decorate$v([
        mixinFocusable,
        mixinStyles(styles$u)
    ], XioId);

    var styles$t = i$3 `

slot {
	vertical-align: middle;
}

svg, span {
	display: inline-block;
	vertical-align: middle;
}

svg {
	width: var(--op-size, 1.2em);
	height: var(--op-size, 1.2em);
}

slot[name=loading] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

slot[name=error] * {
	color: var(--loading-error-color, red);
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    var warningSvg = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M10 7a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4A.5.5 0 0 1 10 7z" fill="currentColor"/><path d="M10 14.5a.75.75 0 1 0 0-1.5a.75.75 0 0 0 0 1.5z" fill="currentColor"/><path d="M8.686 2.852a1.5 1.5 0 0 1 2.628 0l6.56 11.925A1.5 1.5 0 0 1 16.558 17H3.44a1.5 1.5 0 0 1-1.314-2.223L8.686 2.852zm1.752.482a.5.5 0 0 0-.876 0L3.003 15.26a.5.5 0 0 0 .438.741H16.56a.5.5 0 0 0 .438-.74L10.438 3.333z" fill="currentColor"/></g></svg>`;

    var spinnerIcon = b `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-loader"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>`;

    var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioOp = class XioOp extends Component {
        constructor() {
            super(...arguments);
            this.mode = "none";
            this._op = ops.none();
            this.errorIcon = warningSvg;
            this.loadingIcon = spinnerIcon;
            this["loading-message"] = "";
            this["error-message"] = "error";
            this["hide-error-text"] = false;
        }
        get op() {
            return this._op;
        }
        set op(op) {
            const old = this._op;
            this._op = op;
            this.mode = ops.mode(op);
            this.requestUpdate("op", old);
        }
        firstUpdated() {
            if (this["start-loading"]) {
                this.op = ops.loading();
            }
        }
        render() {
            return ops.select(this.op, {
                none: () => x `
				<slot name=none></slot>
			`,
                loading: () => x `
				<slot name=loading>
					${this.loadingIcon}
					${this["loading-message"]
                ? x `<span>${this["loading-message"]}</span>`
                : null}
				</slot>
			`,
                error: reason => x `
				<slot name=error>
					${this.errorIcon}
					${this["hide-error-text"]
                ? null
                : x `<span>${reason !== null && reason !== void 0 ? reason : this["error-message"]}</span>`}
					
				</slot>
			`,
                ready: () => x `
				<slot></slot>
			`,
            });
        }
    };
    __decorate$u([
        e({ type: String, reflect: true })
    ], XioOp.prototype, "mode", void 0);
    __decorate$u([
        e({ type: Object })
    ], XioOp.prototype, "op", null);
    __decorate$u([
        e()
    ], XioOp.prototype, "errorIcon", void 0);
    __decorate$u([
        e()
    ], XioOp.prototype, "loadingIcon", void 0);
    __decorate$u([
        e({ type: String })
    ], XioOp.prototype, "loading-message", void 0);
    __decorate$u([
        e({ type: String })
    ], XioOp.prototype, "error-message", void 0);
    __decorate$u([
        e({ type: Boolean })
    ], XioOp.prototype, "hide-error-text", void 0);
    __decorate$u([
        e({ type: Boolean })
    ], XioOp.prototype, "start-loading", void 0);
    XioOp = __decorate$u([
        mixinStyles(styles$t)
    ], XioOp);

    function getAssignedElements(slot) {
        return Array.from(slot.assignedNodes())
            .filter(node => node instanceof HTMLElement);
    }

    var xioMenuItemCss = i$3 `

:host {
	display: block;
	width: 2em;
	height: 2em;
}

:host([theme="concrete"]) [part="button"] {
	display: block;
	font-size: inherit;
	color: inherit;
	position: relative;
	padding: 0;
	border: none;
	background: transparent;
	width: 100%;
	height: 100%;
}

:host([theme="concrete"]) [part="buttoncontent"] {
	display: flex;
	width: 100%;
	height: 100%;
	justify-content: center;
	align-items: center;
}

:host([theme="concrete"]) [part="buttoncontent"] {
	transform: scale(1);
	transition: transform 100ms ease;
}

:host([theme="concrete"]) [part="buttoncontent"]:active {
	transform: scale(1.1);
}

[part="panel"] {
	display: none;
}

:host([open]) [part="panel"] {
	display: block;
}

:host([theme="concrete"]) [part="panel"] {
	position: absolute;
	left: var(--menu-lanesize, 1rem);
	right: var(--menu-lanesize, 1rem);
	width: var(--menu-panel-width, 640px);
	max-width: calc(100% - calc(var(--menu-lanesize, 1rem) * 2));
	margin-top: var(--menu-padding, 0.15rem);
	margin-left: auto;
	padding: var(--menu-panel-padding, 1rem);
	background: var(--menu-panel-background, white);
	border-radius: var(--menu-panel-border-radius, 0);
	box-shadow: var(--menu-panel-box-shadow, none);
	backdrop-filter: var(--menu-panel-backdrop-filter, none);
	--webkit-backdrop-filter: var(--menu-panel-backdrop-filter, none);
}

:host([theme="concrete"][sticky]) [part="panel"] {
	top: 100%;
}

:host([theme="concrete"][lefty]) [part="panel"] {
	margin-left: unset;
	margin-right: auto;
}

`;

    var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$j = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$8 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XioMenuItem_hasPanel, _XioMenuItem_handleButtonClick;
    class MenuPanelChangeEvent extends CustomEvent {
        constructor(detail) {
            super("menuPanelChange", { detail, bubbles: true });
        }
    }
    let XioMenuItem = class XioMenuItem extends Component {
        constructor() {
            super(...arguments);
            _XioMenuItem_hasPanel.set(this, false);
            this.theme = "";
            this.lefty = false;
            this.open = false;
            _XioMenuItem_handleButtonClick.set(this, () => {
                if (__classPrivateFieldGet$j(this, _XioMenuItem_hasPanel, "f")) {
                    this.toggle();
                    this.shadowRoot.querySelector("button").focus();
                }
            });
        }
        toggle(open = !this.open) {
            this.open = open;
            const event = new MenuPanelChangeEvent({ open });
            this.dispatchEvent(event);
            if (this.onMenuPanelChange)
                this.onMenuPanelChange(event);
        }
        updated(changedProperties) {
            const panelSlot = this.shadowRoot.querySelector(`slot[name="panel"]`);
            const panelIsProvided = !!getAssignedElements(panelSlot).length;
            if (__classPrivateFieldGet$j(this, _XioMenuItem_hasPanel, "f") !== panelIsProvided) {
                __classPrivateFieldSet$8(this, _XioMenuItem_hasPanel, panelIsProvided, "f");
                this.requestUpdate();
            }
        }
        render() {
            return x `
			<button
				part=button
				tabindex=${__classPrivateFieldGet$j(this, _XioMenuItem_hasPanel, "f") ? 0 : -1}
				@click=${__classPrivateFieldGet$j(this, _XioMenuItem_handleButtonClick, "f")}>
					<slot part=buttoncontent></slot>
			</button>
			<slot name=panel part=panel></slot>
		`;
        }
    };
    _XioMenuItem_hasPanel = new WeakMap();
    _XioMenuItem_handleButtonClick = new WeakMap();
    __decorate$t([
        e({ type: String, reflect: true })
    ], XioMenuItem.prototype, "theme", void 0);
    __decorate$t([
        e({ type: Boolean, reflect: true })
    ], XioMenuItem.prototype, "lefty", void 0);
    __decorate$t([
        e({ type: Boolean, reflect: true })
    ], XioMenuItem.prototype, "open", void 0);
    XioMenuItem = __decorate$t([
        mixinStyles(xioMenuItemCss)
    ], XioMenuItem);

    var xioMenuCss = i$3 `

.system {
	position: static;
	margin: var(--menu-margin, auto);
}

:host([theme="concrete"]) .system {
	display: flex;
	align-items: flex-end;
	justify-content: flex-end;
}

:host([theme="concrete"][sticky]) .system {
	pointer-events: none;
	position: absolute;
	width: 100%;
	right: 0;
}

:host([theme="concrete"][sticky]) .system > * {
	pointer-events: all;
}

:host([theme="concrete"][lefty]) .system {
	right: auto;
	left: 0;
	align-items: flex-start;
	justify-content: flex-start;
}

:host([theme="concrete"]) [part="blanket"] {
	z-index: 99;
	display: none;
	position: fixed;
	background: var(--menu-blanket-background, rgba(0,0,0, 0.5));
	backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
	--webkit-backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}

:host([theme="concrete"][active]) [part="blanket"] {
	display: block;
}

:host([theme="concrete"]) [part="list"] {
	z-index: 100;
	display: flex;
	align-items: flex-end;
	justify-content: flex-end;
	padding: var(--menu-padding, 0.15rem);
	background: var(--menu-background, rgba(240, 240, 240, 0.5));
	border-radius: var(--menu-border-radius, 0);
}

:host([theme="concrete"][sticky]) [part="list"] {
	margin-right: var(--menu-lanesize, 1rem);
}

:host([theme="concrete"][sticky][lefty]) [part="list"] {
	margin-right: unset;
	margin-left: var(--menu-lanesize, 1rem);
}

:host([theme="concrete"]) [part="list"] slot::slotted(menu-item) {
	display: block;
	flex: 0 0 auto;
}

`;

    var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$i = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$7 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XioMenu_instances, _XioMenu_snap, _XioMenu_untrack, _XioMenu_scrollEvents, _XioMenu_scrollListener, _XioMenu_handleBlanketClick, _XioMenu_enforceOnePanelOpen, _XioMenu_handleMenuPanelChange;
    let XioMenu = class XioMenu extends Component {
        constructor() {
            super(...arguments);
            _XioMenu_instances.add(this);
            this.theme = "concrete";
            this.active = false;
            this.sticky = false;
            this.lefty = false;
            _XioMenu_snap.set(this, snapstate({
                activeIndex: undefined,
                scrollTop: 0,
            }));
            _XioMenu_untrack.set(this, () => { });
            _XioMenu_scrollEvents.set(this, ["scroll", "resize"]);
            _XioMenu_scrollListener.set(this, () => {
                var _a, _b;
                if (!this.active)
                    __classPrivateFieldGet$i(this, _XioMenu_snap, "f").state.scrollTop = this.sticky
                        ? (_b = (_a = window.scrollY) !== null && _a !== void 0 ? _a : window.pageYOffset) !== null && _b !== void 0 ? _b : 0
                        : 0;
            });
            _XioMenu_handleBlanketClick.set(this, () => {
                const items = this.getMenuItems();
                for (const item of items)
                    item.toggle(false);
            });
            _XioMenu_handleMenuPanelChange.set(this, ({ target, detail: { open } }) => {
                const menuItems = this.getMenuItems();
                if (open)
                    __classPrivateFieldGet$i(this, _XioMenu_instances, "m", _XioMenu_enforceOnePanelOpen).call(this, target, menuItems);
                this.active = !!menuItems.find(item => item.open);
                __classPrivateFieldGet$i(this, _XioMenu_scrollListener, "f").call(this);
            });
        }
        createRenderRoot() {
            const shadowRoot = super.createRenderRoot();
            shadowRoot.addEventListener("slotchange", () => this.requestUpdate());
            return shadowRoot;
        }
        connectedCallback() {
            super.connectedCallback();
            __classPrivateFieldSet$7(this, _XioMenu_untrack, __classPrivateFieldGet$i(this, _XioMenu_snap, "f").track(() => this.render(), () => this.requestUpdate()), "f");
            __classPrivateFieldGet$i(this, _XioMenu_scrollListener, "f").call(this);
            for (const event of __classPrivateFieldGet$i(this, _XioMenu_scrollEvents, "f"))
                window.addEventListener(event, __classPrivateFieldGet$i(this, _XioMenu_scrollListener, "f"));
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            __classPrivateFieldGet$i(this, _XioMenu_untrack, "f").call(this);
            __classPrivateFieldSet$7(this, _XioMenu_untrack, () => { }, "f");
            for (const event of __classPrivateFieldGet$i(this, _XioMenu_scrollEvents, "f"))
                window.removeEventListener(event, __classPrivateFieldGet$i(this, _XioMenu_scrollListener, "f"));
        }
        getMenuItems() {
            const slot = this.shadowRoot.querySelector("slot");
            return getAssignedElements(slot)
                .filter(element => element instanceof XioMenuItem);
        }
        updated() {
            for (const item of this.getMenuItems())
                item.theme = this.theme;
        }
        render() {
            const { scrollTop, activeIndex } = __classPrivateFieldGet$i(this, _XioMenu_snap, "f").state;
            return x `
			<div class=system data-active-index=${activeIndex} style="${`top: ${scrollTop}px`}">
				<div part=blanket @click=${__classPrivateFieldGet$i(this, _XioMenu_handleBlanketClick, "f")}></div>
				<div part=list @menuPanelChange=${__classPrivateFieldGet$i(this, _XioMenu_handleMenuPanelChange, "f")}>
					<slot></slot>
				</div>
			</div>
		`;
        }
    };
    _XioMenu_snap = new WeakMap();
    _XioMenu_untrack = new WeakMap();
    _XioMenu_scrollEvents = new WeakMap();
    _XioMenu_scrollListener = new WeakMap();
    _XioMenu_handleBlanketClick = new WeakMap();
    _XioMenu_handleMenuPanelChange = new WeakMap();
    _XioMenu_instances = new WeakSet();
    _XioMenu_enforceOnePanelOpen = function _XioMenu_enforceOnePanelOpen(target, menuItems) {
        const otherMenuItems = menuItems.filter(item => item !== target);
        for (const item of otherMenuItems)
            item.open = false;
    };
    __decorate$s([
        e({ type: String, reflect: true })
    ], XioMenu.prototype, "theme", void 0);
    __decorate$s([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "active", void 0);
    __decorate$s([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "sticky", void 0);
    __decorate$s([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "lefty", void 0);
    XioMenu = __decorate$s([
        mixinStyles(xioMenuCss)
    ], XioMenu);

    var styles$s = i$3 `

:host {
	display: inline-block;
	width: var(--avatar-size, 2em);
	height: var(--avatar-size, 2em);
	border-radius: var(--avatar-border-radius, 0.3em);
	overflow: hidden;
	user-select: none;
}

.avatar {
	display: block;
	width: 100%;
	height: 100%;
	color: var(--xio-avatar-color, #444);
	background: var(--xio-avatar-background, #888);
}

.avatar[data-logged-in] {
	color: #fff;
}

svg, img {
	pointer-events: none;
	display: block;
	width: 100%;
	height: 100%;
	object-fit: cover;
}

`;

    var svgSilhouette = b `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill="currentColor" fill-rule="evenodd" d="M12 14.002a.998.998 0 0 1-.998.998H1.001A1 1 0 0 1 0 13.999V13c0-2.633 4-4 4-4s.229-.409 0-1c-.841-.62-.944-1.59-1-4 .173-2.413 1.867-3 3-3s2.827.586 3 3c-.056 2.41-.159 3.38-1 4-.229.59 0 1 0 1s4 1.367 4 4v1.002z"/></svg>`;

    function cap(x, min, max) {
        return x < min
            ? min
            : x > max
                ? max
                : x;
    }
    function hsl(xHue, xSaturation, xLightness) {
        const hue = xHue % 360;
        const saturation = cap(xSaturation, 0, 100);
        const lightness = cap(xLightness, 0, 100);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    function getNiceColors(value) {
        const base = Math.ceil(value * 360);
        const split_a = (base - 30) % 360;
        const split_b = (base + 30) % 360;
        return {
            color1: hsl(base, 100, 90),
            color2: hsl(split_a, 50, 60),
            color3: hsl(split_b, 50, 40),
        };
    }

    var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioAvatar = class XioAvatar extends Component {
        renderBlankAvatar(spec) {
            return x `
			<div class=avatar>
				${svgSilhouette}
			</div>
		`;
        }
        renderSimpleAvatar({ value }) {
            const { color1, color2, color3 } = getNiceColors(value);
            const style = `color: ${color1}; background: linear-gradient(to bottom right, ${color2}, ${color3});`;
            return x `
			<div class=avatar style=${style}>
				${svgSilhouette}
			</div>
		`;
        }
        renderImageAvatar({ link }) {
            return x `
			<div class=avatar>
				<img src="${link}" alt=""/>
			</div>
		`;
        }
        render() {
            const { spec = { type: "blank" } } = this;
            switch (spec.type) {
                case "blank":
                    return this.renderBlankAvatar(spec);
                case "simple":
                    return this.renderSimpleAvatar(spec);
                case "image":
                    return this.renderImageAvatar(spec);
                default:
                    return x `avatar missing`;
            }
        }
    };
    __decorate$r([
        e({ type: Object })
    ], XioAvatar.prototype, "spec", void 0);
    XioAvatar = __decorate$r([
        mixinStyles(styles$s)
    ], XioAvatar);

    var styles$r = i$3 `

:host {
	display: inline-block;
	width: max-content;
	height: max-content;
	--_padding: var(--xio-button-padding, 0.2em 0.5em);
	--_background: var(--xio-button-background, transparent);
	--_border: var(--xio-button-border, 1px solid);
	--_border-radius: var(--xio-button-border-radius, 0);
	--_opacity: var(--xio-button-opacity, 0.7);
	--_hover-opacity: var(--xio-button-hover-opacity, 1);
	--_hover-color: var(--xio-button-hover-color, inherit);
	--_hover-background: var(--xio-button-hover-background, var(--_background));
	--_disabled-opacity: var(--xio-button-disabled-opacity, 0.2);
	--_disabled-border-style: var(--xio-button-disabled-border-style, dashed);
}

button {
	width: 100%;
	height: 100%;
	cursor: pointer;
	font: inherit;
	color: inherit;
	padding: var(--_padding);
	font-weight: bold;
	background: var(--_background);
	border: var(--_border);
	border-radius: var(--_border-radius);
	opacity: var(--_opacity);
}

button:not([disabled]):hover,
button:not([disabled]):focus {
	opacity: var(--_hover-opacity);
	color: var(--_hover-color);
	background: var(--_hover-background);
}

button[disabled] {
	cursor: default;
	opacity: var(--_disabled-opacity);
	border-style: var(--_disabled-border-style);
}

`;

    class PressEvent extends CustomEvent {
        constructor(button) {
            super("press", { detail: button });
        }
    }

    var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioButton = class XioButton extends Component {
        constructor() {
            super(...arguments);
            this["disabled"] = false;
            this.handleClick = () => {
                const event = new PressEvent(this);
                if (this.onpress)
                    this.onpress(event);
                if (!this.disabled)
                    this.dispatchEvent(event);
                event.stopPropagation();
            };
        }
        focus() {
            this.shadowRoot.querySelector("button").focus();
        }
        render() {
            return x `
			<button
				part=button
				@click=${this.handleClick}
				?disabled=${this.disabled}>
					<slot part=button-slot></slot>
			</button>
		`;
        }
    };
    __decorate$q([
        e({ type: Boolean, reflect: true })
    ], XioButton.prototype, "disabled", void 0);
    __decorate$q([
        e({ type: Function })
    ], XioButton.prototype, "onpress", void 0);
    XioButton = __decorate$q([
        mixinFocusable,
        mixinStyles(styles$r)
    ], XioButton);

    var styles$q = i$3 `

.example {
	color: #f90;
}

`;

    var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioExample = class XioExample extends Component {
        render() {
            return x `
			<div class=example>
				<p>xio-example</p>
				<slot></slot>
			</div>
		`;
        }
    };
    XioExample = __decorate$p([
        mixinStyles(styles$q)
    ], XioExample);

    var styles$p = i$3 `

* {box-sizing: border-box;}

:host {
	display: inline-block;
	vertical-align: middle;
	color: white;
}

:host([disabled]) {
	opacity: 0.25;
}

button {
	display: inline-block;
	border: unset;
	color: unset;
	background: unset;
}

button {
	position: relative;
	width: 1.5em;
	height: 1.5em;
	background: #3338;
	box-shadow: inset 1px 2px 3px #000a;
	border-radius: 0.5em;
	border: 1px solid #fff4;
}

button[data-mode="ready"] {
	cursor: pointer;
}

button[data-mode="ready"]:hover,
button[data-mode="ready"]:focus {
	background: #5558;
	border: 1px solid #fff8;
}

button > span {
	display: inline-block;
}

button svg {
	width: 100%;
	height: 100%;
}

button .error {
	display: inline-block;
	position: absolute;
	top: 80%;
	left: 0;
	width: max-content;
	max-width: 16em;
	color: red;
	background: #200a;
	text-shadow: 1px 2px 3px #0008;
	text-align: left;
	padding: 0.2em 0.5em;
	border-radius: 0.5em;
	pointer-events: none;
}

button[data-mode="loading"] svg,
button[data-mode="error"] svg {
	padding: 10%;
}

button[data-mode="error"] svg {
	color: red;
	animation: fade 1s ease infinite alternate;
}

button[data-mode="loading"] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    class CheckEvent extends CustomEvent {
        constructor(checkbox) {
            super("press", { detail: checkbox });
        }
    }

    var checkSvg = b `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

    var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioCheckbox = class XioCheckbox extends Component {
        constructor() {
            super(...arguments);
            this.loading = ops.none();
            this["initially-checked"] = false;
            this["error-message"] = "error";
            this.disabled = false;
            this.handleClick = () => {
                if (!this.disabled) {
                    this.toggle();
                    const activeElement = document.activeElement;
                    if (activeElement)
                        activeElement.blur();
                }
            };
        }
        init() {
            this.loading = ops.ready(this["initially-checked"]);
        }
        get checked() {
            return ops.value(this.loading);
        }
        set checked(value) {
            this.loading = ops.ready(value);
        }
        async toggle(previousChecked = ops.value(this.loading), dispatchEvent = true) {
            const checked = !previousChecked;
            const isNotDisabled = !this.disabled;
            const isLoadingDone = ops.isReady(this.loading);
            return (isNotDisabled && isLoadingDone)
                ? ops.operation({
                    setOp: op => this.loading = op,
                    errorReason: this["error-message"],
                    promise: (async () => {
                        var _a;
                        await ((_a = this.save) !== null && _a !== void 0 ? _a : (async () => { }))(checked);
                        if (dispatchEvent) {
                            const event = new CheckEvent(this);
                            if (this.oncheck)
                                this.oncheck(event);
                            this.dispatchEvent(event);
                            event.stopPropagation();
                        }
                        return checked;
                    })(),
                })
                : checked;
        }
        render() {
            return x `
			<button
				data-mode="${ops.mode(this.loading)}"
				?data-checked=${ops.value(this.loading)}
				@click=${this.handleClick}>
					${ops.select(this.loading, {
            none: () => null,
            loading: () => spinnerIcon,
            error: reason => x `${warningSvg}<div class=error>${reason}</div>`,
            ready: checked => checked
                ? checkSvg
                : null,
        })}
			</button>
		`;
        }
    };
    __decorate$o([
        e()
    ], XioCheckbox.prototype, "loading", void 0);
    __decorate$o([
        e({ type: Boolean })
    ], XioCheckbox.prototype, "initially-checked", void 0);
    __decorate$o([
        e({ type: String })
    ], XioCheckbox.prototype, "error-message", void 0);
    __decorate$o([
        e({ type: Boolean, reflect: true })
    ], XioCheckbox.prototype, "disabled", void 0);
    __decorate$o([
        e({ type: Function })
    ], XioCheckbox.prototype, "oncheck", void 0);
    __decorate$o([
        e({ type: Function })
    ], XioCheckbox.prototype, "save", void 0);
    XioCheckbox = __decorate$o([
        mixinFocusable,
        mixinStyles(styles$p)
    ], XioCheckbox);

    var styles$o = i$3 `

/* * { outline: 1px solid #f002; } */

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
	--height: var(--xio-text-input-height, 5rem);
	--pad: var(--xio-text-input-pad, 0.2em);
	--font: var(--xio-text-input-font, inherit);
	--color: var(--xio-text-input-color, inherit);
	--label-font: var(--xio-text-input-label-font, inherit);
	--label-color: var(--xio-text-input-label-color, inherit);
	--problems-font: var(--xio-text-input-problems-font, inherit);
	--problems-color: var(--xio-text-input-problems-color);
	--background: var(--xio-text-input-background, transparent);
	--valid-color: var(--xio-text-input-valid-color, #00ff8c);
	--invalid-color: var(--xio-text-input-invalid-color, #ff6100);
	--border: var(--xio-text-input-border, 1px solid);
	--border-radius: var(--xio-text-input-border-radius, 0.3em);
}

:host([disabled]) [part="inputbox"] {
	opacity: 0.4;
}

:host([hidden]) {
	display: none;
}

label {
	font: var(--label-font);
	color: var(--label-color);
}

slot {
	display: block;
	padding: 0 var(--pad);
}

.flexy {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.flexy > * {
	flex: 0 0 auto;
}

:host([textarea]) .flexy {
	flex-direction: column;
}

[part="inputbox"] {
	display: block;
	/* max-width: var(--width); */
	position: relative;
	flex: 1 1 auto;
}

:host([textarea]) [part="inputbox"] {
	flex: 1 1 auto;
	/* max-width: unset; */
}

[part="inputbox"] svg {
	position: absolute;
	display: block;
	top: var(--pad);
	right: var(--pad);
	width: 1.2em;
	height: 1.2em;
	pointer-events: none;
}

.container[data-valid] [part="inputbox"] svg {
	color: var(--valid-color);
}

.container:not([data-valid]) [part="inputbox"] svg {
	color: var(--invalid-color);
}

#textinput {
	min-width: 1em;
	width: 100%;
	font: var(--font);
	padding: var(--pad);
	padding-right: calc(1em + calc(2 * var(--pad)));
	margin: 0;
	color: var(--color);
	background: var(--background);
	border: var(--border);
	border-radius: var(--border-radius);
	text-overflow: ellipsis;
}

textarea {
	min-height: var(--height);
}

[part="problems"] {
	display: flex;
	font: var(--problems-font);
	padding: 0 calc(2 * var(--pad));
	flex-direction: column;
	justify-content: flex-start;
	flex: 1 1 auto;
	/* min-width: 12rem; */
	list-style: none;
	color: var(--problems-color, var(--invalid-color));
}

[part="problems"] > li {
	margin-top: 0.2em;
}

`;

    var svgCircleCheck = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>`;

    function noopParser(text) {
        return text;
    }

    class EnterPressEvent extends CustomEvent {
        constructor() {
            super("enterpress", {
                bubbles: true,
                composed: true,
                detail: undefined,
            });
        }
    }

    class ValueChangeEvent extends CustomEvent {
        constructor(value) {
            super("valuechange", {
                bubbles: true,
                composed: true,
                detail: { value },
            });
        }
    }

    var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioTextInput = class XioTextInput extends Component {
        constructor() {
            super(...arguments);
            this["initial"] = "";
            this["readonly"] = false;
            this["textarea"] = false;
            this["hide-validation"] = false;
            this["show-validation-when-empty"] = false;
            this["disabled"] = false;
            this["placeholder"] = "";
            this["hidden"] = false;
            this.parser = noopParser;
            this.problems = [];
            this.onvaluechange = () => { };
            this.onenterpress = () => { };
            this.draft = "";
            this.lastDraft = "";
            this.vettedLength = 0;
            this.dispatchValueChange = () => {
                const { draft, lastDraft } = this;
                if (draft !== lastDraft) {
                    this.vettedLength = draft.length;
                    this.dispatchEvent(new ValueChangeEvent(this.value));
                }
                this.lastDraft = draft;
            };
            this.dispatchValueChangeDebounced = debounce(250, this.dispatchValueChange);
            this.dispatchEnterPress = () => {
                this.dispatchEvent(new EnterPressEvent());
            };
            this.updateDraft = () => {
                this.draft = this.input.value;
            };
            this.handleInputKeyPress = (event) => {
                if (event.key === "Enter") {
                    const isTextArea = this.textarea;
                    const isPressingShift = event.shiftKey;
                    const fireEnterPress = () => {
                        this.updateDraft();
                        this.dispatchValueChange();
                        this.dispatchEnterPress();
                        event.preventDefault();
                    };
                    if (isTextArea) {
                        if (isPressingShift)
                            fireEnterPress();
                    }
                    else
                        fireEnterPress();
                }
            };
            this.handleInput = () => {
                this.updateDraft();
                this.dispatchValueChangeDebounced();
            };
            this.handleChange = () => {
                this.updateDraft();
                this.dispatchValueChange();
            };
        }
        get input() {
            return this.shadowRoot
                ? this.shadowRoot.querySelector("#textinput")
                : undefined;
        }
        focus() {
            if (this.input)
                this.input.focus();
        }
        get value() {
            var _a;
            const { draft } = this;
            const parsed = ((_a = this.parser) !== null && _a !== void 0 ? _a : noopParser)(draft);
            this.problems = this.validator ? this.validator(parsed) : [];
            return this.problems.length === 0
                ? parsed
                : undefined;
        }
        get text() {
            return this.draft;
        }
        set text(value) {
            const { input } = this;
            if (input) {
                this.input.value = value;
                this.updateDraft();
                this.dispatchValueChange();
            }
            else {
                this.initial = value;
            }
        }
        init() {
            const { initial } = this;
            this.draft = initial;
            this.lastDraft = initial;
            this.text = initial;
            this.addEventListener("valuechange", this.onvaluechange);
            this.addEventListener("enterpress", this.onenterpress);
            this.dispatchValueChange();
        }
        render() {
            const { readonly, disabled, problems, vettedLength, placeholder, textarea, validator, handleInput, handleInputKeyPress, handleChange, } = this;
            const valid = problems.length === 0;
            const showValidation = !this["hide-validation"] && !readonly && validator && (this["show-validation-when-empty"]
                ? true
                : vettedLength !== 0);
            const showProblems = showValidation && !valid;
            const icon = showValidation
                ? valid
                    ? svgCircleCheck
                    : warningSvg
                : null;
            return x `
			<div class=container ?data-valid=${valid}>
				<label for=textinput part=label><slot></slot></label>
				<div class=flexy>
					<div part=inputbox>
						${showValidation ? icon : null}
						${textarea ? x `
							<textarea
								id=textinput
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
							></textarea>
						` : x `
							<input
								id=textinput
								type=text
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
								/>
						`}
					</div>
					<ol part=problems>
						${showProblems
            ? problems.map(problem => x `
								<li>${problem}</li>
							`)
            : null}
					</ol>
				</div>
			</div>
		`;
        }
    };
    __decorate$n([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "initial", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "readonly", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "textarea", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hide-validation", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "show-validation-when-empty", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "disabled", void 0);
    __decorate$n([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "placeholder", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hidden", void 0);
    __decorate$n([
        e({ type: Function })
    ], XioTextInput.prototype, "parser", void 0);
    __decorate$n([
        e({ type: Function })
    ], XioTextInput.prototype, "validator", void 0);
    __decorate$n([
        e({ type: Object })
    ], XioTextInput.prototype, "problems", void 0);
    __decorate$n([
        e({ type: String })
    ], XioTextInput.prototype, "text", null);
    __decorate$n([
        e({ type: String })
    ], XioTextInput.prototype, "draft", void 0);
    XioTextInput = __decorate$n([
        mixinFocusable,
        mixinStyles(styles$o)
    ], XioTextInput);

    function* compile(expressions) {
        function recurse(expression, previousSelector) {
            let css = [];
            const [selector, rules, children] = expression;
            const compoundSelector = previousSelector
                ? handleParentReference(`${previousSelector} ${selector}`)
                : selector;
            const ruleEntries = Object.entries(rules);
            if (ruleEntries.length > 0) {
                const rulesString = ruleEntries
                    .map(([ruleName, ruleValue]) => `\t${ruleName}: ${stripAwayComments(ruleValue)};`)
                    .join("\n");
                css.push(`${stripAwayComments(compoundSelector)} {\n${rulesString}\n}`);
            }
            for (const child of children)
                css = [...css, ...recurse(child, compoundSelector)];
            return css;
        }
        yield "\n";
        for (const expression of expressions)
            yield "\n" + recurse(expression, undefined).join("\n");
        yield "\n";
    }
    function stripAwayComments(text) {
        return text.replaceAll(/(\s*)(\/\/.*)$/gm, "");
    }
    function handleParentReference(groupedSelector) {
        return groupedSelector.replaceAll(/(\s+)*(\^)/gm, "");
    }

    var Token;
    (function (Token) {
        (function (Type) {
            Type[Type["Open"] = 0] = "Open";
            Type[Type["Close"] = 1] = "Close";
            Type[Type["RuleName"] = 2] = "RuleName";
            Type[Type["RuleValue"] = 3] = "RuleValue";
            Type[Type["SlashSlashComment"] = 4] = "SlashSlashComment";
        })(Token.Type || (Token.Type = {}));
    })(Token || (Token = {}));

    class CamelCssError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    //
    // untracable errors
    //
    class CamelCssMissingClosingBraceError extends CamelCssError {
        constructor(missingCloses) {
            const message = missingCloses > 1
                ? `missing ${missingCloses} closing braces "}"`
                : `missing ${missingCloses} closing brace "}"`;
            super(message);
        }
    }
    //
    // traceable errors
    //
    class CamelCssTraceableError extends CamelCssError {
        constructor(trace, message) {
            super(`(${trace.cursor.line}:${trace.cursor.column}) ${message}`);
            this.trace = trace;
        }
    }
    class CamelCssMissingSelectorError extends CamelCssTraceableError {
        constructor(trace) {
            super(trace, `expression is missing selector`);
        }
    }
    class CamelCssExcessClosingBraceError extends CamelCssTraceableError {
        constructor(trace) {
            super(trace, `unwanted closing brace "}"`);
        }
    }
    class CamelCssRuleNamePlacementError extends CamelCssTraceableError {
        constructor(trace, ruleName) {
            super(trace, `invalid place for rule name "${ruleName}"`);
        }
    }
    class CamelCssRuleValuePlacementError extends CamelCssTraceableError {
        constructor(trace, ruleValue) {
            super(trace, `invalid place for rule value "${ruleValue}"`);
        }
    }
    const setupTracedErrors = (trace) => ({
        error: (message) => new CamelCssTraceableError(trace, message),
        missingSelector: () => new CamelCssMissingSelectorError(trace),
        excessClosingBrace: () => new CamelCssExcessClosingBraceError(trace),
        ruleNamePlacement: (ruleName) => new CamelCssRuleNamePlacementError(trace, ruleName),
        ruleValuePlacement: (ruleValue) => new CamelCssRuleValuePlacementError(trace, ruleValue),
    });

    function* parse(tokens) {
        let frame;
        const stack = [];
        for (const token of tokens) {
            const error = setupTracedErrors(token.trace);
            switch (token.type) {
                case Token.Type.Open:
                    {
                        frame = {
                            selector: token.selector.replaceAll(/\s+/gm, " "),
                            ruleName: undefined,
                            rules: {},
                            childFrames: [],
                        };
                        stack.push(frame);
                    }
                    break;
                case Token.Type.RuleName:
                    {
                        if (!frame)
                            throw error.ruleNamePlacement(token.name);
                        frame.ruleName = token.name;
                    }
                    break;
                case Token.Type.RuleValue:
                    {
                        if (!frame || !frame.ruleName)
                            throw error.ruleValuePlacement(token.value);
                        frame.rules[frame.ruleName] = token.value;
                        frame.ruleName = undefined;
                    }
                    break;
                case Token.Type.Close:
                    {
                        const completedFrame = stack.pop();
                        const parentFrame = stack.length > 0
                            ? stack[stack.length - 1]
                            : undefined;
                        frame = parentFrame;
                        if (!completedFrame)
                            throw error.excessClosingBrace();
                        if (!completedFrame.selector)
                            throw error.missingSelector();
                        if (parentFrame)
                            parentFrame.childFrames.push(completedFrame);
                        else {
                            function recursiveFrameToExpression(frame) {
                                return [
                                    frame.selector,
                                    frame.rules,
                                    frame.childFrames.map(recursiveFrameToExpression),
                                ];
                            }
                            yield recursiveFrameToExpression(completedFrame);
                        }
                    }
                    break;
            }
        }
        if (stack.length > 0)
            throw new CamelCssMissingClosingBraceError(stack.length);
    }

    function runTokenRegex({ source, regex, index, setIndex, }) {
        regex.lastIndex = index;
        const match = regex.exec(source.code);
        if (match)
            setIndex(regex.lastIndex);
        return match;
    }

    const leadingWhitespaceRegex = /(\s*)/my;
    function runLeadingWhitespaceRegex({ source, index, setIndex }) {
        leadingWhitespaceRegex.lastIndex = index;
        const match = leadingWhitespaceRegex.exec(source.code);
        if (match)
            setIndex(leadingWhitespaceRegex.lastIndex);
        const [, whitespace = ""] = match ?? [];
        return whitespace;
    }

    function updateCursor(part, cursor, newIndex) {
        const linebreaks = (/\n/g.exec(part) ?? []).length;
        const line = cursor.line + linebreaks;
        let column = 0;
        if (linebreaks > 0) {
            const [, lastLine] = /\n(.*)$/.exec(part) ?? [];
            column = 1 + lastLine.length;
        }
        else
            column = cursor.column + (newIndex - cursor.index);
        return {
            line,
            column,
            index: newIndex,
        };
    }

    function defineMakeTraceFunction({ index, cursor, leadingWhitespace }) {
        return (valueLength) => {
            const subcursor = updateCursor(leadingWhitespace, cursor, cursor.index + leadingWhitespace.length);
            return {
                cursor: subcursor,
                length: valueLength ?? (index - subcursor.index),
            };
        };
    }

    function makeLexer(regex, readToken) {
        return ((source, cursor) => {
            let index = cursor.index;
            const setIndex = (newIndex) => index = newIndex;
            const leadingWhitespace = runLeadingWhitespaceRegex({
                source, index, setIndex,
            });
            const match = runTokenRegex({
                source, regex, index, setIndex,
            });
            return match
                ? {
                    newIndex: index,
                    token: readToken(match, defineMakeTraceFunction({ index, cursor, leadingWhitespace }))
                }
                : undefined;
        });
    }

    const lexers = {
        slashSlashComment: makeLexer(/(\/\/.*)$/my, (match, makeTrace) => {
            const [, value] = match;
            const trimmedValue = value.trim();
            return {
                type: Token.Type.SlashSlashComment,
                trace: makeTrace(trimmedValue.length),
                value: trimmedValue,
            };
        }),
        open: makeLexer(/([^{};]*){/my, (match, makeTrace) => {
            const [, selector] = match;
            const trimmedSelector = selector.trim();
            return {
                type: Token.Type.Open,
                trace: makeTrace(trimmedSelector.length),
                selector: selector.trim(),
            };
        }),
        close: makeLexer(/}/my, (match, makeTrace) => {
            return {
                type: Token.Type.Close,
                trace: makeTrace(1),
            };
        }),
        ruleName: makeLexer(/([\S]+):/my, (match, makeTrace) => {
            const [, name] = match;
            const trimmedName = name.trim();
            return {
                type: Token.Type.RuleName,
                trace: makeTrace(trimmedName.length),
                name: trimmedName,
            };
        }),
        ruleValue: makeLexer(/([^;}]+)(;|(?=}))/my, (match, makeTrace) => {
            const [, value] = match;
            const trimmedValue = value.trim();
            return {
                type: Token.Type.RuleValue,
                trace: makeTrace(trimmedValue.length),
                value: trimmedValue,
            };
        }),
    };

    function* tokenize(code) {
        const source = { code };
        let done = false;
        let cursor = {
            index: 0,
            line: 1,
            column: 1,
        };
        while (!done) {
            let token;
            for (const lexer of Object.values(lexers)) {
                let result = lexer(source, cursor);
                if (result) {
                    token = result.token;
                    cursor = updateCursor(source.code.slice(cursor.index, result.newIndex), cursor, result.newIndex);
                    break;
                }
            }
            if (token)
                yield token;
            else
                done = true;
        }
    }

    function camelCss(input) {
        const tokens = tokenize(input);
        const expressions = parse(tokens);
        return [...compile(expressions)].join("");
    }

    function css(strings, ...values) {
        const input = Array.from(strings).reduce((previous, current, index) => previous + current + (values[index] ?? ""), "");
        const output = camelCss(input);
        return r$2(output);
    }

    const ev = (Event) => ({
        target: (target) => ({
            dispatch(detail, options) {
                target.dispatchEvent(new Event(Event.type, { ...options, detail }));
            },
            listen(listener, options) {
                target.addEventListener(Event.type, listener, options);
                return () => target
                    .removeEventListener(Event.type, listener, options);
            },
        })
    });

    const defaultDispatchOptions = {
        bubbles: true,
        composed: true,
        cancelable: true,
    };

    var _a;
    class MagicEventBase extends CustomEvent {
        constructor(name, options) {
            super(name, { ...defaultDispatchOptions, ...options });
        }
    }
    _a = MagicEventBase;
    MagicEventBase.target = ev(_a).target;

    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    var styles$n = css `

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
	--pad: var(--xio-price-input-pad, 0.2em);
	--font: var(--xio-price-input-font, inherit);
	--color: var(--xio-price-input-color, inherit);
	--font-size: var(--xio-price-input-button-font-size, 1.5rem);
	--svg-height: var(--xio-price-input-height, 1.2em);
	--label-font: var(--xio-price-input-label-font, inherit);
	--label-color: var(--xio-price-input-label-color, inherit);
	--pad-problems: var(--xio-price-input-problems-padding, 1.7em);
	--problems-font: var(--xio-price-input-problems-font, inherit);
	--problems-color: var(--xio-price-input-problems-color);
	--background: var(--xio-price-input-background, transparent);
	--valid-color: var(--xio-price-input-valid-color, #00ff8c);
	--invalid-color: var(--xio-price-input-invalid-color, #ff6100);
	--border: var(--xio-price-input-border, 1px solid);
	--border-radius: var(--xio-price-input-border-radius, 0.3em);
}

.container {
	display: flex;
	flex-direction: column;

	label {
		font: var(--label-font);
		color: var(--label-color);
		slot {
			display: block;
			padding: 0 var(--pad);
		}
	}

	svg {
		width: var(--svg-height);
		height: var(--svg-height);
		pointer-events: none;
	}

	ul {
		font: var(--problems-font);
		list-style-type: none;
		padding-left: var(--pad-problems);
		color: var(--problems-color, var(--invalid-color));
	}
}

.inner__container{
	display: flex;
	align-items: center;
	gap: 0.5rem;

	button {
		display: flex;
		font-size: var(--font-size);
		color: var(--color);
		opacity: 0.4;
		background: var(--background);
		cursor: pointer;
		border: none;
		user-select: none;
		transition: all 0.2s ease-in 0s;
	
		^:is(:hover, :focus) {
			opacity: 1;
			outline: none;
		}
	}

	.decrement:active {
		opacity: 0.6;
		transform: translateY(2px);
	}

	.increment:active {
		opacity: 0.6;
		transform: translateY(-2px);
	}
}

.price__input__parent {
	display: flex;
	align-items: center;
	gap: 0.2rem;
	padding: var(--pad) calc(2 * var(--pad));
	border-radius: var(--border-radius);
	border: var(--border);

	input {
		font: var(--font);
		font-size: 1.5rem;
		text-align: right;
		border: none;
		padding: 0;
		background: var(--background);
		color: var(--color);

		^:is(:focus, :active) {
			outline: 0;
		}
	}

	.symbol, .currency {
		font-size: 1rem;
		opacity: 0.4;
		user-select: none;
		text-transform: uppercase;
	}

	.currency {
		margin-left: 0.5em;
	}

	^[data-valid] svg {
		color: var(--valid-color);
	}

	^:not([data-valid]) svg {
		color: var(--invalid-color);
	}
}

.focussed {
	outline: 2px solid cyan;
}

input::-webkit-inner-spin-button {
	-webkit-appearance: none;
}
`;

    var chevronUpSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-up"><polyline points="18 15 12 9 6 15"></polyline></svg>`;

    var chevronDownSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>`;

    var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$h = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioPriceInput_instances, _XioPriceInput_focusInputParent, _XioPriceInput_unfocusInputParent, _XioPriceInput_resizeInput, _XioPriceInput_validateInput, _XioPriceInput_handleButtonClick, _XioPriceInput_handleInputChange;
    var Operation;
    (function (Operation) {
        Operation[Operation["INCREMENT"] = 0] = "INCREMENT";
        Operation[Operation["DECREMENT"] = 1] = "DECREMENT";
    })(Operation || (Operation = {}));
    let XioPriceInput = class XioPriceInput extends Component {
        constructor() {
            super(...arguments);
            _XioPriceInput_instances.add(this);
            this.min = 1.00;
            this.max = 10.00;
            this.step = "0.5";
            this["initial-value"] = "";
            this.currency = "USD";
            this.symbol = "$";
            this.problems = [];
            this.valid = true;
            this.showValidation = false;
            _XioPriceInput_focusInputParent.set(this, () => {
                this.inputParent.classList.add('focussed');
            });
            _XioPriceInput_unfocusInputParent.set(this, () => {
                this.inputParent.classList.remove('focussed');
            });
            _XioPriceInput_resizeInput.set(this, () => {
                const { input } = this;
                const size = input.value.length > 1 ? input.value.length : 3;
                input.style.width = `${size + 0.4}ch`;
            });
            _XioPriceInput_validateInput.set(this, (value) => {
                this.showValidation = true;
                this.problems = this.validator ? this.validator(Number(value)) : [];
                this.valid = this.problems.length < 1;
            });
            _XioPriceInput_handleInputChange.set(this, (event) => {
                const input = event.target;
                this.inputValue = input.value;
                __classPrivateFieldGet$h(this, _XioPriceInput_validateInput, "f").call(this, this.inputValue);
                __classPrivateFieldGet$h(this, _XioPriceInput_resizeInput, "f").call(this);
                this.dispatchEvent(new ValueChangeEvent(this.inputValue));
            });
        }
        get input() {
            return this.shadowRoot
                ? this.shadowRoot.querySelector('#price')
                : undefined;
        }
        get inputParent() {
            return this.shadowRoot
                ? this.shadowRoot.querySelector('.price__input__parent')
                : undefined;
        }
        get value() {
            return this.valid ? this.inputValue : undefined;
        }
        init() {
            this.inputValue = this["initial-value"];
        }
        render() {
            const { symbol, currency, inputValue, readonly, valid, showValidation, problems } = this;
            const inputWidth = this["initial-value"]
                ? this["initial-value"].length
                : 4;
            const icon = showValidation
                ? valid
                    ? svgCircleCheck
                    : warningSvg
                : null;
            return x `
			<div class="container">
				<label for="price" part="label"><slot></slot></label>
				<div class="inner__container">
					<button
						?disabled=${readonly}
						@click=${() => __classPrivateFieldGet$h(this, _XioPriceInput_instances, "m", _XioPriceInput_handleButtonClick).call(this, Operation.DECREMENT)}
						class="decrement">
						${chevronDownSvg}
					</button>
					<div class="price__input__parent" tabindex="-1" ?data-valid=${valid}>
						<span class="symbol">${symbol}</span>
						<input
							?readonly=${readonly}
							@focus=${__classPrivateFieldGet$h(this, _XioPriceInput_focusInputParent, "f")}
							@blur=${__classPrivateFieldGet$h(this, _XioPriceInput_unfocusInputParent, "f")}
							@input=${__classPrivateFieldGet$h(this, _XioPriceInput_handleInputChange, "f")}
							.value=${inputValue}
							type="number"
							id="price"
							style="width: ${inputWidth}ch"
							placeholder="0.00"
						/>
						${icon}
						<span class="currency">${currency}</span>
					</div>
					<button
						?disabled=${readonly}
						@click=${() => __classPrivateFieldGet$h(this, _XioPriceInput_instances, "m", _XioPriceInput_handleButtonClick).call(this, Operation.INCREMENT)}
						class="increment">
						${chevronUpSvg}
					</button>
				</div>
				<ul part=problems>
					${!valid
            ? problems.map(problem => x `
							<li>${problem}</li>
						`)
            : null}
				</ul>
			</div>
		`;
        }
    };
    _XioPriceInput_focusInputParent = new WeakMap();
    _XioPriceInput_unfocusInputParent = new WeakMap();
    _XioPriceInput_resizeInput = new WeakMap();
    _XioPriceInput_validateInput = new WeakMap();
    _XioPriceInput_handleInputChange = new WeakMap();
    _XioPriceInput_instances = new WeakSet();
    _XioPriceInput_handleButtonClick = function _XioPriceInput_handleButtonClick(type) {
        const { step, inputValue } = this;
        if (type === Operation.INCREMENT)
            this.inputValue = (Number(inputValue) + Number(step)).toFixed(2);
        else if (type === Operation.DECREMENT)
            this.inputValue = (Number(inputValue) - Number(step)).toFixed(2);
        __classPrivateFieldGet$h(this, _XioPriceInput_validateInput, "f").call(this, this.inputValue);
        __classPrivateFieldGet$h(this, _XioPriceInput_resizeInput, "f").call(this);
        this.dispatchEvent(new ValueChangeEvent(this.inputValue));
    };
    __decorate$m([
        e({ type: Number, reflect: true })
    ], XioPriceInput.prototype, "min", void 0);
    __decorate$m([
        e({ type: Number, reflect: true })
    ], XioPriceInput.prototype, "max", void 0);
    __decorate$m([
        e({ type: String, reflect: true })
    ], XioPriceInput.prototype, "step", void 0);
    __decorate$m([
        e({ type: Boolean, reflect: true })
    ], XioPriceInput.prototype, "readonly", void 0);
    __decorate$m([
        e({ type: String })
    ], XioPriceInput.prototype, "initial-value", void 0);
    __decorate$m([
        e({ type: String })
    ], XioPriceInput.prototype, "currency", void 0);
    __decorate$m([
        e({ type: String })
    ], XioPriceInput.prototype, "symbol", void 0);
    __decorate$m([
        e({ type: String })
    ], XioPriceInput.prototype, "inputValue", void 0);
    __decorate$m([
        e({ type: Object })
    ], XioPriceInput.prototype, "problems", void 0);
    __decorate$m([
        e({ type: Boolean })
    ], XioPriceInput.prototype, "valid", void 0);
    __decorate$m([
        e({ type: Boolean })
    ], XioPriceInput.prototype, "showValidation", void 0);
    __decorate$m([
        e({ type: Function })
    ], XioPriceInput.prototype, "validator", void 0);
    XioPriceInput = __decorate$m([
        mixinStyles(styles$n)
    ], XioPriceInput);

    class NightlightChangeEvent extends CustomEvent {
        constructor(detail) {
            super("nightlightChange", {
                detail,
                bubbles: true,
            });
        }
    }

    const nightlightStorageKey = "nightlightSettings";
    function nightlightSettingStorage() {
        return {
            save(settings) {
                if (settings)
                    window.localStorage.setItem(nightlightStorageKey, JSON.stringify(settings));
                else
                    window.localStorage.removeItem(nightlightStorageKey);
            },
            load() {
                const data = window.localStorage.getItem(nightlightStorageKey);
                return data
                    ? JSON.parse(data)
                    : undefined;
            },
        };
    }

    var xioThemerCss = i$3 `

:host {
	display: inline-block;
	width: 2em;
	height: 2em;
}

button {
	display: block;
	font-size: inherit;
	color: inherit;
	background: transparent;
	border: none;
	width: 100%;
	height: 100%;

	Xtransform: scale(1);
	Xtransition: transform 200ms ease;
}

Xbutton:active {
	transform: scale(0.8);
}

slot {
	display: block;
	width: 100%;
	height: 100%;
}

slot svg, slot::slotted(svg) {
	display: block;
	width: 100%;
	height: 100%;
}

`;

    var sunSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`;

    var moonSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`;

    var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$g = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioNightlight_instances, _XioNightlight_storage, _XioNightlight_setNightOnSourceElement, _XioNightlight_dispatchChange;
    const nightlightDataAttributeName = "data-nightlight";
    /*

    nightlight is a toggle button for dark theme.

    in "night" mode, the "data-nightlight" attribute is set on the source element.

        <body data-nightlight>

    if you want to start your website in night mode by default,
    just start your source element with the "data-nightlight" attribute.

    */
    let XioNightlight = class XioNightlight extends Component {
        constructor() {
            super(...arguments);
            _XioNightlight_instances.add(this);
            this["show-destination-state"] = false;
            this["title-to-night"] = "turn down the lights";
            this["title-to-day"] = "turn up the lights";
            this.sourceElement = document.documentElement;
            _XioNightlight_storage.set(this, nightlightSettingStorage());
        }
        firstUpdated() {
            const settings = __classPrivateFieldGet$g(this, _XioNightlight_storage, "f").load();
            if (settings)
                this.night = settings.night;
            window.addEventListener("nightlightChange", event => {
                if (event.target !== this)
                    this.requestUpdate();
            });
        }
        get night() {
            return this.sourceElement.getAttribute(nightlightDataAttributeName) !== null;
        }
        set night(value) {
            __classPrivateFieldGet$g(this, _XioNightlight_storage, "f").save({ night: value });
            const previous = this.night;
            if (value !== previous) {
                __classPrivateFieldGet$g(this, _XioNightlight_instances, "m", _XioNightlight_setNightOnSourceElement).call(this, value);
                this.requestUpdate();
                __classPrivateFieldGet$g(this, _XioNightlight_instances, "m", _XioNightlight_dispatchChange).call(this);
            }
        }
        toggle(night = !this.night) {
            this.night = night;
        }
        render() {
            const { night } = this;
            const showNight = this["show-destination-state"]
                ? !night
                : night;
            return x `
			<button
				part=button
				title="${night ? this["title-to-day"] : this["title-to-night"]}"
				?data-nightlight=${night}
				@click=${() => this.toggle()}>
					${showNight
            ? x `
							<slot name=night>
								${moonSvg}
							</slot>
						`
            : x `
							<slot name=day>
								${sunSvg}
							</slot>
						`}
			</button>
		`;
        }
    };
    _XioNightlight_storage = new WeakMap();
    _XioNightlight_instances = new WeakSet();
    _XioNightlight_setNightOnSourceElement = function _XioNightlight_setNightOnSourceElement(night) {
        if (night)
            this.sourceElement.setAttribute(nightlightDataAttributeName, "");
        else
            this.sourceElement.removeAttribute(nightlightDataAttributeName);
    };
    _XioNightlight_dispatchChange = function _XioNightlight_dispatchChange() {
        const event = new NightlightChangeEvent({ night: this.night });
        this.dispatchEvent(event);
        if (this.onNightlightChange)
            this.onNightlightChange(event);
    };
    XioNightlight.NightlightChangeEvent = NightlightChangeEvent;
    __decorate$l([
        e({ type: Boolean, reflect: true })
    ], XioNightlight.prototype, "show-destination-state", void 0);
    __decorate$l([
        e({ type: String, reflect: true })
    ], XioNightlight.prototype, "title-to-night", void 0);
    __decorate$l([
        e({ type: String, reflect: true })
    ], XioNightlight.prototype, "title-to-day", void 0);
    XioNightlight = __decorate$l([
        mixinStyles(xioThemerCss)
    ], XioNightlight);

    var styles$m = i$3 `

:host {
	display: inline-block;
	--local-avatar-size: var(--avatar-size, 3em);
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

xio-avatar {
	flex: 0 0 auto;
	margin-right: 0.4em;
	--avatar-size: var(--local-avatar-size);
}

.box {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	flex: 1;
	flex-basis: 8em;
}

[part="nameplate"] {
	flex: 1 1 auto;
	margin-right: 1em;
	margin-bottom: 0.5em;
}

[part="details"] {
	margin-bottom: 0.5em;
}

.buttonbar {
	margin-top: 0.5em;
}

.cardplate > * {
	display: block;
}

.tags {
	list-style: none;
	font-size: 0.6em;
	cursor: default;
}

.tags > li {
	display: inline-block;
	margin: 0 0.1em;
	padding: 0 0.25em;
	border: 1px solid;
	border-radius: 1em;
}

[data-tag=staff] {
	color: var(--cobalt-tagcolor-staff, lime);
}

[data-tag=banned] {
	color: var(--cobalt-tagcolor-banned, red);
}

p[data-field=tagline] {
	opacity: 0.7;
	font-size: 0.7em;
	font-style: italic;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7rem;
}

xio-text-input + xio-text-input {
	margin-top: 0.1em;
}

[part="details"] {
	font-size: 0.7em;
	list-style: none;
}

[part="details"] > li {
	margin-top: 0.2em;
}

[part="details"] > li > :first-child {
	font-weight: bold;
}

[part="details"] code {
	font-size: 0.6em;
	padding: 0.2em;
	border-radius: 0.3em;
	word-break: break-all;
	background: #0002;
}

.roles {
	font-size: 0.6em;
	list-style: none;
	padding: 0;
	margin-top: 0.3rem;
}

.roles li {
	display: inline-block;
	border: 1px solid;
	border-radius: 1em;
	padding: 0.1em 0.3em;
	line-height: 0.8em;
}

`;

    const isSet = (a) => (a !== null && a !== undefined);
    function deepEqual(a, b) {
        if (!isSet(a) || !isSet(b))
            return a === b;
        for (const [key, aValue] of Object.entries(a)) {
            if (!b.hasOwnProperty(key))
                return false;
            const bValue = b[key];
            switch (typeof aValue) {
                case "object":
                    if (!deepEqual(aValue, bValue))
                        return false;
                    break;
                case "function":
                    if (!isSet(bValue) || aValue.toString() !== bValue.toString())
                        return false;
                    break;
                default:
                    if (aValue !== bValue)
                        return false;
            }
        }
        for (const [key] of Object.entries(a))
            if (!b.hasOwnProperty(key))
                return false;
        for (const [key] of Object.entries(b))
            if (!a.hasOwnProperty(key))
                return false;
        return true;
    }

    function renderText({ field, initial, text, input }) {
        return input
            ? x `
			<xio-text-input
				data-field="${field}"
				initial="${initial}"
				text="${text}"
				part="xiotextinput"
				exportparts="${`
					label: xiotextinput-label,
					textinput: xiotextinput-textinput,
					problems: xiotextinput-problems,
				`}"
				show-validation-when-empty
				?readonly=${input.readonly}
				?hide-validation=${!input.draftIsChanged}
				.validator=${input.validator}
				@valuechange=${input.onvaluechange}>
					<span>${input.label}</span>
			</xio-text-input>
		`
            : x `
			<p part="textfield" data-field="${field}">${initial}</p>
		`;
    }

    function renderRoles(user) {
        return x `
		<ul class=roles>
			${user.roles.map(role => x `
				<li
					data-role-label="${role.label}"
					data-role-id="${role.roleId}">
						${role.label}
				</li>
			`)}
		</ul>
	`;
    }

    function select$1(selector, context = document) {
        return context.querySelector(selector);
    }

    function formatDate(milliseconds) {
        const d = new Date(milliseconds);
        const twoDigit = (n) => n.toString().padStart(2, "0");
        const year = twoDigit(d.getFullYear());
        const month = twoDigit(d.getMonth() + 1);
        const day = twoDigit(d.getDate());
        const hours24 = d.getHours();
        let hours = d.getHours();
        hours %= 12;
        hours = hours ? hours : 12;
        const minutes = twoDigit(d.getMinutes());
        const ampm = hours24 >= 12 ? "pm" : "am";
        const timezoneOffsetMinutes = -d.getTimezoneOffset();
        const timezoneOffset = (timezoneOffsetMinutes / 60).toFixed(timezoneOffsetMinutes % 60 === 0
            ? 0
            : 1);
        const timezoneUtc = timezoneOffsetMinutes === 0
            ? "UTC"
            : `UTC${timezoneOffsetMinutes < 0 ? "" : "+"}${timezoneOffset}`;
        const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const timezone = `${timezoneName} ${timezoneUtc}`;
        const date = `${year}-${month}-${day}`;
        const time = `${hours}:${minutes} ${ampm}`;
        const zone = `${timezone}`;
        const full = `${date} ${time} (${zone})`;
        return {
            date,
            time,
            zone,
            full,
        };
    }

    function renderDetails(user) {
        return x `
		<ul part=details>
			<li>
				<span>joined:</span>
				<span>${formatDate(user.stats.joined).date}</span>
			</li>
			<li>
				<span>user id:</span>
				<span><xio-id id="${user.userId}"></xio-id></span>
			</li>
		</ul>
	`;
    }

    function makeProfileDraft(profile) {
        return {
            tagline: profile.tagline,
            nickname: profile.nickname,
        };
    }

    function whenOpReady(op, render) {
        return ops.isReady(op)
            ? render(ops.value(op))
            : null;
    }

    function renderOp(op, render, more = null, { loadingMessage = "", errorMessage = "", hideErrorText = false } = {}) {
        return x `
		<xio-op
			.op=${op}
			loading-message="${loadingMessage}"
			error-message="${errorMessage}"
			?hide-error-text=${hideErrorText}>
				${whenOpReady(op, render)}
				${more}
		</xio-op>
	`;
    }

    var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$f = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioProfileCard_state;
    let XioProfileCard = class XioProfileCard extends Component {
        constructor() {
            super(...arguments);
            _XioProfileCard_state.set(this, snapstate({
                busy: ops.ready(undefined),
            }));
            this.profileDraft = undefined;
            this.problems = [];
            this.handleChange = debounce(200, () => {
                if (!this.user)
                    return;
                const { profileDraft, isChanged } = this.generateNewProfileDraftFromInputs();
                this.profileDraft = isChanged ? profileDraft : undefined;
            });
            this.handleSave = async () => {
                const { profileDraft } = this;
                await ops.operation({
                    promise: this.saveProfile(profileDraft)
                        .finally(() => {
                        this.profileDraft = null;
                    }),
                    setOp: op => __classPrivateFieldGet$f(this, _XioProfileCard_state, "f").writable.busy = op,
                });
                this.requestUpdate();
                await this.updateComplete;
                const setToTextField = (field, text) => {
                    const input = this.shadowRoot.querySelector(`xio-text-input[data-field="${field}"]`);
                    input.text = text;
                };
                setToTextField("nickname", profileDraft.nickname);
                setToTextField("tagline", profileDraft.tagline);
            };
        }
        init() {
            this.addSubscription(() => __classPrivateFieldGet$f(this, _XioProfileCard_state, "f").subscribe(() => this.requestUpdate()));
        }
        get draftIsChanged() {
            return !!this.profileDraft;
        }
        get readonly() {
            return !this.saveProfile;
        }
        getTextInputField(name) {
            return select$1(`xio-text-input[data-field="${name}"]`, this.shadowRoot);
        }
        generateNewProfileDraftFromInputs() {
            const { profile } = this.user;
            const profileDraft = makeProfileDraft(profile);
            const nicknameInput = this.getTextInputField("nickname");
            if (!nicknameInput)
                return { profileDraft, isChanged: false };
            const taglineInput = this.getTextInputField("tagline");
            profileDraft.nickname = nicknameInput.value;
            profileDraft.tagline = taglineInput.value;
            this.problems = [...nicknameInput.problems, ...taglineInput.problems];
            const isChanged = !deepEqual(makeProfileDraft(profile), profileDraft);
            return { profileDraft, isChanged };
        }
        render() {
            const { user, draftIsChanged } = this;
            if (!user)
                return null;
            const avatarSpec = user.profile.avatar;
            return renderOp(__classPrivateFieldGet$f(this, _XioProfileCard_state, "f").readable.busy, () => x `
			<div class=container ?data-readonly=${this.readonly}>
				<xio-avatar part=avatar .spec=${avatarSpec}></xio-avatar>
				<div class=box>
					<div part=nameplate>
						${renderText({
            field: "nickname",
            initial: this.profileDraft
                ? this.profileDraft.nickname
                : user.profile.nickname,
            text: user.profile.nickname,
            input: this.readonly
                ? undefined
                : {
                    label: "nickname",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.nickname,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderText({
            field: "tagline",
            initial: this.profileDraft
                ? this.profileDraft.tagline
                : user.profile.tagline,
            text: user.profile.tagline,
            input: this.readonly
                ? undefined
                : {
                    label: "tagline",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.tagline,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderRoles(user)}
						${this.readonly ? null : x `
							<div class=buttonbar>
								<xio-button
									?disabled=${!this.profileDraft || this.problems.length > 0}
									@press=${this.handleSave}>
										<slot name=save-button>save profile</slot>
								</xio-button>
							</div>
						`}
					</div>
					${this["show-details"]
            ? renderDetails(user)
            : null}
				</div>
			</div>
		`);
        }
    };
    _XioProfileCard_state = new WeakMap();
    __decorate$k([
        e({ type: Boolean })
    ], XioProfileCard.prototype, "show-details", void 0);
    __decorate$k([
        e({ type: Object })
    ], XioProfileCard.prototype, "user", void 0);
    __decorate$k([
        e({ type: Object })
    ], XioProfileCard.prototype, "saveProfile", void 0);
    __decorate$k([
        e({ type: Object })
    ], XioProfileCard.prototype, "profileDraft", void 0);
    XioProfileCard = __decorate$k([
        mixinStyles(styles$m)
    ], XioProfileCard);

    var styles$l = css `

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
}

.card {
	display: flex;
	width: fit-content;
	margin: 0 auto;
}

.display {
	font-size: 1.2rem;
	display: flex;

	strong {
		font-size: 2em;
		line-height: 1;
	}

	.superscript {
		font-size: 1em;
		margin-top: 0.1em;
	}

	.symbol {
		opacity: 0.4;
		font-size: 1em;
		align-self: center;
		margin-right: 0.2em;
		user-select: none;
	}

	.currency {
		opacity: 0.4;
		font-size: 1em;
		margin-top: 0.1em;
		margin-left: 0.3em;
		user-select: none;
		text-transform: uppercase;
	}

	.vertical {
		font-size: 0.7em;
		text-orientation: upright;
		writing-mode: vertical-rl;
		text-align: center;
		letter-spacing: -0.2em;
	}
}
`;

    var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$e = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioPriceDisplay_instances, _XioPriceDisplay_leftPadCents, _XioPriceDisplay_getPriceDetails, _XioPriceDisplay_renderWhenSuperscriptIsDisabled, _XioPriceDisplay_renderWhenSupercriptIsEnabled;
    let XioPriceDisplay = class XioPriceDisplay extends Component {
        constructor() {
            super(...arguments);
            _XioPriceDisplay_instances.add(this);
            this.symbol = "$";
            this.currency = "USD";
            this.value = "9.50";
            _XioPriceDisplay_renderWhenSuperscriptIsDisabled.set(this, () => {
                const { cents, dollars } = __classPrivateFieldGet$e(this, _XioPriceDisplay_instances, "m", _XioPriceDisplay_getPriceDetails).call(this);
                return x `
			<strong>
				${`${dollars}.${cents}`}
			</strong>
		`;
            });
            _XioPriceDisplay_renderWhenSupercriptIsEnabled.set(this, () => {
                const { cents, dollars } = __classPrivateFieldGet$e(this, _XioPriceDisplay_instances, "m", _XioPriceDisplay_getPriceDetails).call(this);
                return x `
			<strong>${dollars}</strong>
			<span class="superscript">${cents}</span>
		`;
            });
        }
        render() {
            const enableSuperscript = this["unit-superscript"];
            const enableVerticalCurrency = this["vertical-currency"];
            const { symbol, currency } = this;
            return x `
			<div class="card">
				<div class="display">
					<span class="symbol">${symbol}</span>
					${enableSuperscript
            ? __classPrivateFieldGet$e(this, _XioPriceDisplay_renderWhenSupercriptIsEnabled, "f").call(this)
            : __classPrivateFieldGet$e(this, _XioPriceDisplay_renderWhenSuperscriptIsDisabled, "f").call(this)}
					<span class=${`currency ${enableVerticalCurrency ? 'vertical' : ''}`}>
						${currency}
					</span>
				</div>
			</div>
		`;
        }
    };
    _XioPriceDisplay_renderWhenSuperscriptIsDisabled = new WeakMap();
    _XioPriceDisplay_renderWhenSupercriptIsEnabled = new WeakMap();
    _XioPriceDisplay_instances = new WeakSet();
    _XioPriceDisplay_leftPadCents = function _XioPriceDisplay_leftPadCents(cents) {
        return cents.length > 1 ? cents : `0${cents}`;
    };
    _XioPriceDisplay_getPriceDetails = function _XioPriceDisplay_getPriceDetails() {
        const { value } = this;
        const numerical = parseFloat(value);
        const dollars = Math.floor(numerical);
        const cents = Math.round((numerical % 1.0) * 100);
        const strings = {
            dollars: dollars.toString(),
            cents: __classPrivateFieldGet$e(this, _XioPriceDisplay_instances, "m", _XioPriceDisplay_leftPadCents).call(this, cents.toString()),
        };
        return strings;
    };
    __decorate$j([
        e({ type: String, reflect: true })
    ], XioPriceDisplay.prototype, "symbol", void 0);
    __decorate$j([
        e({ type: String, reflect: true })
    ], XioPriceDisplay.prototype, "currency", void 0);
    __decorate$j([
        e({ type: Boolean, reflect: true })
    ], XioPriceDisplay.prototype, "unit-superscript", void 0);
    __decorate$j([
        e({ type: Boolean, reflect: true })
    ], XioPriceDisplay.prototype, "vertical-currency", void 0);
    __decorate$j([
        e({ type: String })
    ], XioPriceDisplay.prototype, "value", void 0);
    XioPriceDisplay = __decorate$j([
        mixinStyles(styles$l)
    ], XioPriceDisplay);

    function integrateXioComponents() {
        return {
            XioId,
            XioOp,
            XioMenu,
            XioAvatar,
            XioButton,
            XioExample,
            XioCheckbox,
            XioMenuItem,
            XioTextInput,
            XioPriceInput,
            XioNightlight,
            XioProfileCard,
            XioPriceDisplay
        };
    }

    var adminManagerCss = i$3 `

.adminmanager .adminassigner {
	display: flex;
	flex-direction: row;
	margin: 0.5em 0;
}

.adminmanager .adminassigner > * {
	display: block;
}

.adminmanager .adminassigner > xio-text-input {
	flex: 1 1 auto;
}

.adminmanager .adminassigner > xio-text-input {
	width: 100%;
	max-width: 100%;
}

.adminmanager .adminassigner > xio-text-input::part(problems) {
	min-width: unset;
}

.adminmanager .adminassigner > xio-button {
	margin-top: 1.1em;
	margin-left: 0.3em;
}

.adminmanager .adminlist ul {
	list-style: none;
	padding: 0 1em;
	border: 1px solid #fff1;
}

.adminmanager .adminlist li {
	display: flex;
	flex-direction: row;
	align-content: center;
	padding: 0.3em 0;
	font-size: 0.8em;
}

.adminmanager .adminlist li + li {
	border-top: 1px solid #fff1;
}

.adminmanager .adminlist li > * {
	display: block;
}

.adminmanager .adminlist li > span {
	flex: 1 1 auto;
	display: flex;
	align-items: center;
	word-break: break-all;
}

.adminmanager .adminlist li > xio-button {
	color: #fff3;
}

`;

    var styles$k = i$3 `

:host {
	display: block;
}

.app-list {
	margin-top: 2em;
	margin-bottom: 2em;
}

.app-list > xio-op {
	display: block;
	border: 1px solid #f00;
	margin-top: 0.5em;
	border: 1px solid #fff1;
	border-radius: 0.2em;
}

.app-list > xio-op[mode="loading"] {
	padding: 4em 2em;
}

.app > * + * {
	margin-top: 0.3em;
}

.app + .app {
	margin-top: 1.5em;
}

.app > * {
	padding: 0.4em 1rem;
}

.app-header {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	justify-content: flex-end;
	padding: 0;
	background: #0001;
}

.app-header .title {
	max-width: 100%;
	flex: 1 0 auto;
	padding: 0.3em 1em;
}

.app-header .title h3 {
	font-size: 1.5em;
	font-weight: bold;
}

.app-header .title h3::before {
	content: "ðŸŒ";
	color: white;
}

.app-header .stats {
	display: flex;
	flex-direction: row;
	justify-content: center;
	flex-wrap: wrap;
	padding: 0.2em;
}

.app-header .stats [data-stat] {
	display: flex;
	flex-direction: column;
	justify-content: flex-end;
	max-width: 6em;
	text-align: center;
}

.app-header .stats [data-stat] > span {
	padding: 0.1em 0.6em;
}

.app-header .stats [data-stat] > span:nth-child(1) {
	justify-self: flex-start;
}

.app-header .stats [data-stat] > span:nth-child(2) {
	opacity: 0.3;
	font-size: 0.6em;
}

.twoside {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.twoside > div {
	max-width: 100%;
	flex: 1 0 16em;
	padding-bottom: 1em;
}

.twoside > div:nth-child(1) {
	padding-right: 1rem;
}

.editside > .buttons {
	display: flex;
	justify-content: center;
	align-items: center;
}

.app-form > * + * {
	margin-top: 0.3em;
}

.app-form xio-button {
	margin-top: 0.6em;
}

.app-options {
	border: 1px solid #fff1;
	padding: 1em;
}

.app-options > * + * {
	margin-top: 3em;
}

code {
	display: inline-block;
	font-size: 0.8em;
	padding: 0.2em;
	border-radius: 0.3em;
	background: #0002;
	overflow-wrap: anywhere;
	word-break: break-all;
}

code.id {
	opacity: 0.7;
	font-size: 0.5em;
}

.codeblock {
	display: block;
}

.htmlcode { color: #fff6; }
.htmlcode [data-syntax=tag] { color: deepskyblue; }
.htmlcode [data-syntax=attr] { color: skyblue; }
.htmlcode [data-syntax=data] { color: #aaffa0; }
.htmlcode [data-syntax=indent] {
	display: block;
	margin-left: 1em;
}

.app-code > * {
	margin-top: 1em;
}

.app-code code {
	display: block;
	font-size: 0.6em;
	padding: 1em;
	margin: 0.5em 0;
}

.delete-app-button {
	display: block;
	text-align: right;
	--xio-button-hover-color: red;
}

${adminManagerCss}

.app-list {
	margin-bottom: 5rem;
}

.app-registration {
	max-width: 40em;
	margin-bottom: 5em;
}

`;

    function renderXiomeConfig(appId) {
        const h = (syntax, s) => x `<span data-syntax=${syntax}>${s}</span>`;
        const tag = (s) => h("tag", s);
        const attr = (s) => h("attr", s);
        const data = (s) => h("data", s);
        const glue = (s) => h("glue", s);
        const quote = glue(`"`);
        const bundle_link = "https://xiome.io/xiome.bundle.min.js";
        return x `
		${glue(`<`)}${tag(`script`)} ${attr(`async`)} ${attr(`defer`)} ${attr(`src`)}${glue(`=`)}${quote}${data(bundle_link)}${quote}${glue(`>`)}${glue(`</`)}${tag(`script`)}${glue(`>`)}
		<br/>
		${glue(`<`)}${tag(`xiome-config`)} ${attr(`app`)}${glue(`=`)}${quote}${data(appId)}${quote}${glue(`>`)}${glue(`</`)}${tag(`xiome-config`)}${glue(`>`)}
	`;
    }

    const parseOrigins = (text) => text
        .split("\n")
        .map(line => line.trim().toLowerCase())
        .filter(line => line.length > 0);

    function validateAppFormDraft(formDraft) {
        const problems = [
            ...appDraftValidators.label(formDraft.label),
            ...appDraftValidators.home(formDraft.home),
            ...appDraftValidators.additionalOrigins(formDraft.additionalOrigins),
        ];
        return problems;
    }

    function getEmptyAppFormDraft() {
        return {
            home: "",
            label: "",
            additionalOrigins: [],
        };
    }

    function makeAppForm({ clearOnSubmit, submitButtonText, showAdditionalOrigins, initialValues = getEmptyAppFormDraft(), query, submit, requestUpdate, }) {
        const state = {
            problems: [],
            formDisabled: false,
            draft: initialValues,
            get valid() {
                return !this.formDisabled
                    && this.draft
                    && this.problems.length === 0;
            },
        };
        function getFormElements() {
            return {
                home: query(`.app-form [data-form="home"]`),
                label: query(`.app-form [data-form="label"]`),
                additionalOrigins: query(`.app-form [data-form="additional-origins"]`),
            };
        }
        function setFormValues(draft) {
            const elements = getFormElements();
            elements.home.text = draft.home;
            elements.label.text = draft.label;
            elements.additionalOrigins.text = draft.additionalOrigins.join("\n");
        }
        const refreshAndValidateForm = () => {
            const { home, label, additionalOrigins } = getFormElements();
            state.draft = {
                home: home.value,
                label: label.value,
                additionalOrigins: additionalOrigins.value,
            };
            state.problems = validateAppFormDraft(state.draft);
            requestUpdate();
        };
        function handleFormChange() {
            state.problems = [];
            if (!state.formDisabled)
                refreshAndValidateForm();
        }
        async function handleSubmitClick() {
            refreshAndValidateForm();
            state.formDisabled = true;
            requestUpdate();
            try {
                await submit(state.draft);
                if (clearOnSubmit) {
                    initialValues = getEmptyAppFormDraft();
                    setFormValues(initialValues);
                }
                else {
                    initialValues = state.draft;
                }
            }
            finally {
                state.formDisabled = false;
                requestUpdate();
            }
        }
        function render({ partNamespace }) {
            const { formDisabled, draft, problems } = state;
            const changes = !deepEqual(initialValues, draft);
            const submitButtonDisabled = !changes
                || formDisabled
                || problems.length > 0;
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: ${partNamespace}-appform-xiotextinput-label,
			textinput: ${partNamespace}-appform-xiotextinput-textinput,
			problems: ${partNamespace}-appform-xiotextinput-problems,
		`;
            const renderTextInput = ({ hide, textarea, label, dataForm, initialText, showValidationWhenEmpty, parser, validator, }) => x `
			<xio-text-input
				?textarea=${textarea}
				part="${partNamespace}-appform-xiotextinput"
				exportparts="${exportPartsTextInput}"
				data-form="${dataForm}"
				initial="${initialText}"
				?hidden=${hide}
				?disabled=${formDisabled}
				?hide-validation=${!changes}
				?show-validation-when-empty=${showValidationWhenEmpty}
				.parser=${parser}
				.validator=${validator}
				@valuechange=${handleFormChange}>
					<span part=xio-text-input-label>
						${label}
					</span>
			</xio-text-input>
		`;
            return x `
			<div class=app-form>
				<slot name=create-app-heading></slot>

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "label",
            label: "community name",
            initialText: initialValues.label,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.label,
        })}

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "home",
            label: `website homepage, like "https://chasemoskal.com/"`,
            initialText: initialValues.home,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.home,
        })}

				${renderTextInput({
            hide: !showAdditionalOrigins,
            textarea: true,
            dataForm: "additional-origins",
            label: "(optional) additional domain names",
            initialText: initialValues.additionalOrigins.join("\n"),
            showValidationWhenEmpty: true,
            parser: parseOrigins,
            validator: appDraftValidators.additionalOrigins,
        })}

				<xio-button
					class="create-app-button"
					?disabled=${submitButtonDisabled}
					@press=${handleSubmitClick}>
						${submitButtonText}
				</xio-button>
			</div>
		`;
        }
        return { render };
    }

    function adminManagerControls({ app, state, actions, appEditService, }) {
        const { appId } = app;
        const load = (firstStep = Promise.resolve(undefined)) => (ops.operation({
            promise: firstStep
                .then(() => appEditService.listAdmins({ appId })),
            setOp: admins => actions.setAdmins(admins)
        }));
        async function listAdmins() {
            await load();
        }
        async function assignAdmin() {
            const { email } = state.assignerDraft;
            actions.setAssignerDraft({ email: undefined });
            await load(appEditService.assignAdmin({ appId, email }));
        }
        async function revokeAdmin(userId) {
            await load(appEditService.revokeAdmin({ appId, userId }));
        }
        return { listAdmins, assignAdmin, revokeAdmin };
    }

    function adminManagerStateAndActions() {
        const state = snapstate({
            admins: ops.none(),
            assignerDraft: {
                email: undefined,
            },
        });
        const actions = {
            setAdmins(op) {
                state.writable.admins = op;
            },
            setAssignerDraft(draft) {
                state.writable.assignerDraft = draft;
            },
        };
        return {
            subscribe: state.subscribe,
            state: state.readable,
            actions,
        };
    }

    function makeAdminManager({ app, appEditService, query }) {
        const { state, actions, subscribe } = adminManagerStateAndActions();
        const controls = adminManagerControls({
            app,
            state,
            actions,
            appEditService,
        });
        function handleEmailChange(event) {
            var _a;
            const email = (_a = event.detail.value) !== null && _a !== void 0 ? _a : undefined;
            actions.setAssignerDraft({ email });
        }
        function handleAssignButtonPress() {
            const textInput = query(".adminassigner xio-text-input");
            controls.assignAdmin();
            textInput.text = "";
        }
        function renderAdminAssigner() {
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: adminmanager-xiotextinput-label,
			textinput: adminmanager-xiotextinput-textinput,
			problems: adminmanager-xiotextinput-problems,
		`;
            return x `
			<div class=adminassigner>
				<xio-text-input
					part=adminmanager-xiotextinput
					exportparts="${exportPartsTextInput}"
					.validator=${emailValidator}
					@valuechange=${handleEmailChange}>
						email
				</xio-text-input>
				<xio-button
					?disabled=${!state.assignerDraft.email}
					@press=${handleAssignButtonPress}>
						grant
				</xio-button>
			</div>
		`;
        }
        function renderAdminList() {
            return x `
			<div class=adminlist>
				${renderOp(state.admins, admins => x `
					<ul>
						${admins.map(({ email, userId }) => x `
							<li>
								<span>${email}</span>
								<xio-button @press=${() => controls.revokeAdmin(userId)}>
									revoke
								</xio-button>
							</li>
						`)}
					</ul>
				`)}
			</div>
		`;
        }
        function render() {
            return x `
			${renderAdminAssigner()}
			${renderAdminList()}
		`;
        }
        return { render, controls, subscribe };
    }

    function dedupe(arr) {
        return [...new Set(arr)];
    }

    function formDraftToAppDraft(formDraft) {
        return {
            home: formDraft.home,
            label: formDraft.label,
            origins: dedupe([
                new URL(formDraft.home).origin,
                ...formDraft.additionalOrigins,
            ])
        };
    }

    // TODO obsolete
    // usage of these functions should be replaced by the better assertive-map.ts
    function strongRecordKeeper() {
        return function (makeRecord) {
            const map = new Map();
            return function getRecord(key) {
                let record;
                if (map.has(key))
                    record = map.get(key);
                else {
                    record = makeRecord(key);
                    map.set(key, record);
                }
                return record;
            };
        };
    }

    function originsMinusHome(home, origins) {
        return origins
            .filter(o => o.toLowerCase() !== new URL(home.toLowerCase()).origin)
            .map(o => o.toLowerCase());
    }

    function appDisplayToFormDraft(display) {
        return {
            home: display.home,
            label: display.label,
            additionalOrigins: originsMinusHome(display.home, display.origins),
        };
    }

    var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeAppManager = class XiomeAppManager extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.appRegistrationForm = makeAppForm({
                clearOnSubmit: true,
                showAdditionalOrigins: false,
                submitButtonText: "create community",
                requestUpdate: () => this.requestUpdate(),
                query: selector => (this.shadowRoot
                    .querySelector(".app-registration")
                    .querySelector(selector)),
                submit: async (formDraft) => {
                    const appDraft = formDraftToAppDraft(formDraft);
                    await this.share.appsModel.registerApp(appDraft);
                },
            });
            this.getAppState = strongRecordKeeper()(appId => {
                const app = this.share.appsModel.getApp(appId);
                const state = snapstate({
                    editMode: false,
                });
                const actions = {
                    toggleEditMode() {
                        state.writable.editMode = !state.writable.editMode;
                    },
                };
                state.subscribe(() => this.requestUpdate());
                return {
                    toggleEditMode: actions.toggleEditMode,
                    get editMode() { return state.readable.editMode; },
                    appForm: makeAppForm({
                        clearOnSubmit: false,
                        showAdditionalOrigins: true,
                        submitButtonText: "save changes",
                        initialValues: appDisplayToFormDraft(app),
                        requestUpdate: () => { this.requestUpdate(); },
                        query: selector => (this.shadowRoot
                            .querySelector(`.app[data-app-id="${app.appId}"] .app-options`)
                            .querySelector(selector)),
                        submit: async (formDraft) => {
                            const appDraft = formDraftToAppDraft(formDraft);
                            await this.share.appsModel.updateApp(app.appId, appDraft);
                        },
                    }),
                    adminManager: (() => {
                        const manager = makeAdminManager({
                            app,
                            appEditService: this.share.appsModel.appEditService,
                            query: selector => this.shadowRoot
                                .querySelector(`.app[data-app-id="${app.appId}"] .adminmanager`)
                                .querySelector(selector)
                        });
                        manager.subscribe(() => this.requestUpdate());
                        manager.controls.listAdmins();
                        return manager;
                    })(),
                };
            });
            this.deleteApp = async (app) => {
                const userIsSure = await this.share.modals.confirm({
                    title: "are you certain?",
                    body: `you really want to delete your community "${app.label}"?`,
                    yes: { label: "delete whole community", vibe: "negative" },
                    no: { label: "nevermind", vibe: "neutral" },
                    focusNthElement: 2,
                });
                if (userIsSure)
                    await this.share.appsModel.deleteApp(app.appId);
            };
        }
        init() {
            this.share.appsModel.loadApps();
        }
        renderAppRegistration() {
            return x `
			<div class=app-registration>
				<slot name="register-app-heading"></slot>
				${this.appRegistrationForm.render({ partNamespace: "appregistration" })}
			</div>
		`;
        }
        renderNoApps() {
            return x `
			<slot name=no-apps></slot>
			${this.renderAppRegistration()}
		`;
        }
        renderAppList(records) {
            return x `
			<slot></slot>
			<div class=app-list>
				${Object.entries(records)
            .map(([appId, record]) => renderOp(record, app => this.renderApp(app)))}
			</div>
			${this.renderAppRegistration()}
		`;
        }
        renderAppBankLinking(app) {
            return null;
            // return html`
            // 	<div>
            // 		<h4>bank link to receive payouts</h4>
            // 		<xiome-bank-connect .appId=${app.appId}></xiome-bank-connect>
            // 	</div>
            // `
        }
        renderAppCode(appId) {
            return x `
			<div class=app-code>
				<h4>connect your website</h4>
				<p>copy-paste this html into your website's &lt;head&gt; section:</p>
				<code class=htmlcode>
					${renderXiomeConfig(appId)}
				</code>
				<p>then head over to the <a part=link href="./components">components page</a></p>
			</div>
		`;
        }
        renderApp(app) {
            const appState = this.getAppState(app.appId);
            return x `
			<div class=app data-app-id=${app.appId}>

				<div class=app-header part=app-header>
					<div class=title>
						<h3>
							<a part=link target=_blank href="${app.home}">
								${app.label}
							</a>
						</h3>
					</div>
					<div class=stats>
						<div data-stat=users>
							<span>${app.stats.users.toLocaleString()}</span>
							<span>users</span>
						</div>
						<div data-stat=monthly-active>
							<span>${app.stats.usersActiveMonthly.toLocaleString()}</span>
							<span>monthly active</span>
						</div>
						<div data-stat=active-last-day>
							<span>${app.stats.usersActiveDaily.toLocaleString()}</span>
							<span>daily active</span>
						</div>
					</div>
				</div>

				<div class=twoside>
					${this.renderAppCode(app.appId)}
					<div class=editside>
						<div class=buttons>
							<xio-button @click=${appState.toggleEditMode}>edit community</xio-button>
						</div>
						<div class=app-options ?hidden=${!appState.editMode}>
							<div class=app-details>
								${appState.appForm.render({ partNamespace: "appeditor" })}
							</div>
							<div class=adminmanager>
								<h4>manage admins</h4>
								${appState.adminManager.render()}
							</div>
							${this.renderAppBankLinking(app)}
							<div class=finalbox>
								<xio-button
									class=delete-app-button
									@press=${() => this.deleteApp(app)}>
										delete community
								</xio-button>
							</div>
						</div>
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { appRecords } = this.share.appsModel.state;
            return x `
			${renderOp(appRecords, records => Object.values(records).length
            ? this.renderAppList(records)
            : this.renderNoApps())}
		`;
        }
    };
    XiomeAppManager = __decorate$i([
        mixinStyles(styles$k)
    ], XiomeAppManager);

    var styles$j = i$3 `

:host {
	display: block;
	width: var(--avatar-size, 2em);
	height: var(--avatar-size, 2em);
	--op-size: calc(var(--avatar-size, 2em) * 0.5);
}

xio-op {
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
	height: 100%;
}

:host([logged-in]) .avatar {
	color: #fff;
}

`;

    var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAvatar = class XiomeMyAvatar extends mixinRequireShare()(Component) {
        render() {
            const accessOp = this.share.accessModel.getAccessOp();
            return renderOp(accessOp, access => {
                var _a;
                return x `
				<xio-avatar
					part=avatar
					.spec=${(_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.profile.avatar}
				></xio-avatar>
			`;
            }, null, { hideErrorText: true });
        }
    };
    XiomeMyAvatar = __decorate$h([
        mixinStyles(styles$j)
    ], XiomeMyAvatar);

    var styles$i = i$3 `

xio-profile-card {
	--avatar-size: 7em;
}

`;

    var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAccount = class XiomeMyAccount extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.saveProfile = async (profileDraft) => {
                await this.share.personalModel.saveProfile(profileDraft);
            };
        }
        render() {
            const { accessOp } = this.share.personalModel.readable;
            return renderOp(accessOp, ({ user }) => x `
			<xio-profile-card
				show-details
				.user=${user}
				.saveProfile=${this.saveProfile}
			></xio-profile-card>
			<slot></slot>
		`);
        }
    };
    XiomeMyAccount = __decorate$g([
        mixinStyles(styles$i)
    ], XiomeMyAccount);

    var styles$h = i$3 `

:host {
	display: block;
}

slot {
	display: block;
}

xio-text-input,
xio-button {
	margin-top: 0.2em;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7em;
}

.buttonbar {
	margin-top: 0.5em;
	vertical-align: middle;
}

slot[name="legal"] {
	display: inline-block;
	margin: 0 1em;
}

small {
	display: block;
	opacity: 0.5;
	font-size: 0.7em;
}

`;

    var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeLoginPanel = class XiomeLoginPanel extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this["show-logout"] = false;
            this["status"] = "loading";
            this.sentLoading = ops.none();
            this.emailIsValid = false;
        }
        async sendEmail() {
            const email = this.textInput.value;
            await ops.operation({
                promise: this.share.accessModel.sendLoginLink(email)
                    .then(() => ({ email })),
                setOp: op => this.sentLoading = op,
                errorReason: `failed sending email to "${email}"`,
            });
        }
        resetSentLoading() {
            this.sentLoading = ops.none();
            if (this.textInput)
                this.textInput.text = "";
        }
        logout() {
            this.share.accessModel.logout()
                .then(() => this.sentLoading = ops.none());
        }
        subscribe() {
            return this.share.accessModel.subscribe(() => {
                this.resetSentLoading();
            });
        }
        renderLoggedIn(access) {
            return x `
			<slot>
				<p>Welcome ${access.user.profile.nickname}!</p>
			</slot>
			${this["show-logout"]
            ? x `
					<div part=buttonbar>
						<xio-button class=logout-button @press=${this.logout}>
							Logout
						</xio-button>
					</div>
				`
            : null}
		`;
        }
        handleEmailChange() {
            this.emailIsValid = this.textInput.problems.length === 0;
        }
        renderLegalLink() {
            return x `
			<small>
				<p>
					<a
						part=link
						target=_blank
						href="https://xiome.io/legal">
							policies and terms
					</a>
				</p>
			</small>
		`;
        }
        renderLoggedOut() {
            const { emailIsValid } = this;
            return x `
			<xio-op .op=${this.sentLoading}>
				<div slot=none>
					<slot name=logged-out>
						<p>login with your email address</p>
					</slot>
					<xio-text-input
						.validator=${email()}
						@valuechange=${this.handleEmailChange}
						@enterpress=${this.sendEmail}>
							<span>your email</span>
					</xio-text-input>
					<div class=buttonbar>
						<slot name=legal>
							${this.renderLegalLink()}
						</slot>
						<xio-button
							?disabled=${!emailIsValid}
							@press=${this.sendEmail}>
								send login link
						</xio-button>
					</div>
				</div>
				${ops.isReady(this.sentLoading)
            ? x `
						<p>email sent to ${ops.value(this.sentLoading).email}</p>
						<p>please wait a few minutes for it to arrive</p>
						<xio-button @press=${this.resetSentLoading}>
							restart
						</xio-button>
					`
            : null}
			</xio-op>
		`;
        }
        render() {
            var _a;
            const accessOp = this.share.accessModel.getAccessOp();
            this.status = "loading";
            if (ops.isReady(accessOp)) {
                this.status = ((_a = ops.value(accessOp)) === null || _a === void 0 ? void 0 : _a.user)
                    ? "logged-in"
                    : "logged-out";
            }
            return renderOp(accessOp, access => (access === null || access === void 0 ? void 0 : access.user)
                ? this.renderLoggedIn(access)
                : this.renderLoggedOut());
        }
    };
    __decorate$f([
        e({ type: Boolean, reflect: true })
    ], XiomeLoginPanel.prototype, "show-logout", void 0);
    __decorate$f([
        e({ type: String, reflect: true })
    ], XiomeLoginPanel.prototype, "status", void 0);
    __decorate$f([
        e()
    ], XiomeLoginPanel.prototype, "sentLoading", void 0);
    __decorate$f([
        i("xio-text-input")
    ], XiomeLoginPanel.prototype, "textInput", void 0);
    __decorate$f([
        e({ type: String })
    ], XiomeLoginPanel.prototype, "emailIsValid", void 0);
    XiomeLoginPanel = __decorate$f([
        mixinStyles(styles$h)
    ], XiomeLoginPanel);

    var styles$g = i$3 `

.creator {
	margin: 1em auto;
}

.privilege {
	display: inline-flex;
	flex-direction: row;
	padding: 0.2em 0.5em;
	margin: 0.2em;
	border: 1px solid;
}

.privilege .icon {
	padding-right: 0.5em;
}

.privilege xio-button {
	--xio-button-padding: 0;
	--xio-button-border: none;
}

.privilege[data-hard] {
	opacity: 0.5;
	border: 1px solid dashed;
}

`;

    var wrenchSvg = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g fill="none"><path d="M7 5a4 4 0 0 1 5.445-3.73a.5.5 0 0 1 .173.819L10.708 4L12 5.293l1.91-1.91a.5.5 0 0 1 .82.172a4 4 0 0 1-4.829 5.292L4.897 13.92a1.986 1.986 0 0 1-2.843-2.774l5.051-5.234A4.01 4.01 0 0 1 7 5zm4-3a3 3 0 0 0-2.862 3.903a.5.5 0 0 1-.117.498L2.773 11.84a.986.986 0 0 0 1.41 1.377l5.225-5.293a.5.5 0 0 1 .532-.116a3 3 0 0 0 4.046-3.088l-1.633 1.634a.5.5 0 0 1-.707 0l-2-2a.5.5 0 0 1 0-.707l1.634-1.634A3.045 3.045 0 0 0 11 2z" fill="currentColor"/></g></svg>`;

    var cancelSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill="currentColor" fill-rule="evenodd" d="M7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm0 1.3c1.3 0 2.5.44 3.47 1.17l-8 8A5.755 5.755 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zm0 11.41c-1.3 0-2.5-.44-3.47-1.17l8-8c.73.97 1.17 2.17 1.17 3.47 0 3.14-2.56 5.7-5.7 5.7z"/></svg>`;

    function renderPrivilege({ privilege: { hard, label, privilegeId }, onDeleteClick, }) {
        function renderSystemIcon() {
            return x `
			<div class="icon system">
				${wrenchSvg}
			</div>
		`;
        }
        function renderDeleteButton() {
            return x `
			<xio-button
				title="delete privilege"
				class="icon delete"
				@press=${onDeleteClick}>
					${cancelSvg}
			</xio-button>
		`;
        }
        return x `
		<div
			class=privilege
			?data-hard=${hard}>
				${hard ? renderSystemIcon() : renderDeleteButton()}
				<span class=text>${label}</span>
		</div>
	`;
    }

    const validatePermissionsLabel = validator$1(string(), minLength(1), maxLength(32));

    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$d = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$6 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomePrivileges_instances, _XiomePrivileges_busy, _XiomePrivileges_clearCreatorTextInput, _XiomePrivileges_createPrivilege, _XiomePrivileges_deletePrivilege, _XiomePrivileges_labelDraft, _XiomePrivileges_handleCreatorLabelChange, _XiomePrivileges_renderPrivilegeCreator;
    let XiomePrivileges = class XiomePrivileges extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomePrivileges_instances.add(this);
            _XiomePrivileges_busy.set(this, false);
            _XiomePrivileges_labelDraft.set(this, void 0);
            _XiomePrivileges_handleCreatorLabelChange.set(this, (event) => {
                __classPrivateFieldSet$6(this, _XiomePrivileges_labelDraft, event.detail.value, "f");
                this.requestUpdate();
            });
        }
        get model() {
            return this.share.permissionsModel;
        }
        init() {
            this.model.initialize();
        }
        render() {
            const { readable: { permissionsDisplay } } = this.model;
            const allowed = this.model.getUserCanCustomizePermissions();
            return renderOp(permissionsDisplay, permissions => allowed ? x `
			<div class=privileges>
				${__classPrivateFieldGet$d(this, _XiomePrivileges_instances, "m", _XiomePrivileges_renderPrivilegeCreator).call(this)}
				${permissions.privileges.map(privilege => renderPrivilege({
            privilege,
            onDeleteClick: () => __classPrivateFieldGet$d(this, _XiomePrivileges_instances, "m", _XiomePrivileges_deletePrivilege).call(this, privilege)
        }))}
			</div>
		` : x `
			<p>you are not permitted to customize privileges</p>
		`);
        }
    };
    _XiomePrivileges_busy = new WeakMap();
    _XiomePrivileges_labelDraft = new WeakMap();
    _XiomePrivileges_handleCreatorLabelChange = new WeakMap();
    _XiomePrivileges_instances = new WeakSet();
    _XiomePrivileges_clearCreatorTextInput = function _XiomePrivileges_clearCreatorTextInput() {
        const input = this.shadowRoot.querySelector(".creator xio-text-input");
        input.text = "";
    };
    _XiomePrivileges_createPrivilege = async function _XiomePrivileges_createPrivilege() {
        if (__classPrivateFieldGet$d(this, _XiomePrivileges_busy, "f"))
            throw new Error("privilege creator is busy");
        const label = __classPrivateFieldGet$d(this, _XiomePrivileges_labelDraft, "f");
        __classPrivateFieldGet$d(this, _XiomePrivileges_instances, "m", _XiomePrivileges_clearCreatorTextInput).call(this);
        __classPrivateFieldSet$6(this, _XiomePrivileges_busy, true, "f");
        try {
            await this.model.createPrivilege({ label });
        }
        finally {
            __classPrivateFieldSet$6(this, _XiomePrivileges_busy, false, "f");
        }
    };
    _XiomePrivileges_deletePrivilege = async function _XiomePrivileges_deletePrivilege({ privilegeId, label }) {
        const confirm = await this.share.modals.confirm({
            title: x `delete privilege ${label}?`,
            body: x `are you sure you want to delete this privilege?`,
        });
        if (confirm)
            await this.model.deletePrivilege({ privilegeId });
    };
    _XiomePrivileges_renderPrivilegeCreator = function _XiomePrivileges_renderPrivilegeCreator() {
        const isCreateButtonDisabled = !__classPrivateFieldGet$d(this, _XiomePrivileges_labelDraft, "f");
        return x `
			<div class=creator>
				<xio-text-input
					?disabled=${__classPrivateFieldGet$d(this, _XiomePrivileges_busy, "f")}
					.validator=${validatePermissionsLabel}
					@valuechange=${__classPrivateFieldGet$d(this, _XiomePrivileges_handleCreatorLabelChange, "f")}
					@enterpress=${__classPrivateFieldGet$d(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						privilege label
				</xio-text-input>
				<xio-button
					?disabled=${isCreateButtonDisabled}
					@press=${__classPrivateFieldGet$d(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						create privilege
				</xio-button>
			</div>
		`;
    };
    XiomePrivileges = __decorate$e([
        mixinStyles(styles$g)
    ], XiomePrivileges);

    var styles$f = i$3 `

* {
	ZZoutline: 1px solid #0f02;
}

:host {
	display: block;
	width: 100%;
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 0.5em;
}

.container > * {
	flex: 3 1 10em;
	display: flex;
	flex-direction: column;
}

.roles {
	flex: 1 3 10em;
}

.roles xio-button[data-hard] {
	opacity: 0.6;
}

.container > * > p {
	padding: 0 0.5em;
}

[part=plate] {
	flex: 1 1 auto;
	padding: 0.5em;
	background: #fff2;
}

[part=plate] xio-button {
	display: inline-block;
	margin: 0.2em 0.1em;
	--xio-button-disabled-opacity: 0.6;
}

[part=plate] xio-button[data-hard] {
	opacity: 0.6;
}

[part=plate] xio-button[data-selected]::part(button) {
	border: 1px solid lime;
	background: yellow;
	color: black;
}

[part=plate] xio-button > div {
	display: flex;
	flex-direction: row;
}

[part=plate] xio-button .icon {
	margin-right: 0.2em;
}

[part=plate] xio-button svg {
	width: 0.8em;
	height: 0.8em;
}

.buttonbar {
	text-align: right;
	background: #0002;
}

.buttonbar [data-button=delete] {
	--xio-button-hover-color: red;
	--xio-button-hover-background: transparent;
}

.buttonbar [data-button=new] {
	--xio-button-hover-color: lime;
	--xio-button-hover-background: transparent;
}

`;

    var lockSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-lock"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomePermissions = class XiomePermissions extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.clickRole = (role) => () => {
                this.roleSelected = role;
            };
            this.clickDeleteRole = async () => {
                const { modals, permissionsModel } = this.share;
                const role = this.roleSelected;
                const confirmed = await modals.confirm({
                    title: "Delete role?",
                    body: `Are you sure you want to permanently delete the role "${role.label}"`,
                    yes: { vibe: "negative", label: "Delete role" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await permissionsModel.deleteRole({ roleId: role.roleId });
            };
            this.clickNewRole = async () => {
                const { modals, permissionsModel } = this.share;
                const result = await modals.prompt({
                    title: "Create a new role",
                    input: {
                        label: "Role name",
                        validator: roleLabelValidator,
                    },
                    yes: { vibe: "positive", label: "Create role" }
                });
                if (result)
                    await permissionsModel.createRole({ label: result.value });
            };
            this.clickAvailablePrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.assignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
            this.clickAssignedPrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.unassignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
        }
        init() {
            this.share.permissionsModel.initialize();
        }
        getAssignedPrivileges(permissions) {
            const { roleSelected } = this;
            if (!roleSelected)
                return [];
            const assignedPrivilegeIds = permissions.rolesHavePrivileges
                .filter(({ roleId }) => roleId === roleSelected.roleId)
                .map(({ privilegeId }) => privilegeId);
            return permissions.privileges
                .filter(({ privilegeId }) => assignedPrivilegeIds.includes(privilegeId))
                .map(privilege => {
                const { active, immutable } = permissions.rolesHavePrivileges.find(rp => rp.roleId === roleSelected.roleId &&
                    rp.privilegeId === privilege.privilegeId);
                return { ...privilege, active, immutable };
            });
        }
        renderPrivilege({ privilegeId, label, hard, immutable, onPrivilegeClick, }) {
            return x `
			<xio-button
				title="${privilegeId}"
				?disabled=${immutable}
				?data-hard=${hard}
				?data-soft=${!hard}
				?data-immutable=${immutable}
				@press=${onPrivilegeClick}>
					<div>
						${hard
            ? x `<div class=icon>${wrenchSvg}</div>`
            : null}
						${immutable
            ? x `<div class=icon>${lockSvg}</div>`
            : null}
						${label}
					</div>
			</xio-button>
		`;
        }
        renderPermissions(permissions) {
            const assignedPrivileges = this.getAssignedPrivileges(permissions);
            const activePrivileges = assignedPrivileges.filter(p => p.active);
            const availablePrivileges = this.roleSelected
                ? [
                    ...permissions.privileges
                        .filter(privilege => {
                        const assigned = assignedPrivileges
                            .find(priv => priv.privilegeId === privilege.privilegeId);
                        return !assigned;
                    })
                        .map(privilege => ({ ...privilege, immutable: false })),
                    ...assignedPrivileges
                        .filter(privilege => !privilege.active)
                ]
                : [];
            return x `
			<div class=container>
				<div class=roles>
					<p>roles</p>
					<div part=plate>
						${permissions.roles.map(role => x `
							<xio-button
								title="${role.roleId}"
								?data-selected=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								?data-hard=${role.hard}
								?disabled=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								@click=${this.clickRole(role)}>
								<div>
									${role.hard
            ? x `<div class=icon>${wrenchSvg}</div>`
            : null}
									${role.label}
								</div>
							</xio-button>
						`)}
					</div>
					<div part=plate class=buttonbar>
						${this.roleSelected
            ? x `
								<xio-button
									data-button=delete
									?disabled=${this.roleSelected.hard}
									@press=${this.clickDeleteRole}>
										delete role
								</xio-button>
							`
            : null}
						<xio-button data-button=new @press=${this.clickNewRole}>
							new role
						</xio-button>
					</div>
				</div>

				<div class=assigned>
					<p>
						privileges assigned
						${this.roleSelected
            ? ` to "${this.roleSelected.label}"`
            : null}
					</p>
					<div part=plate>
						${activePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAssignedPrivilege(privilege.privilegeId)
        }))}
					</div>
				</div>

				<div class=available>
					<p>privileges available</p>
					<div part=plate>
						${availablePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAvailablePrivilege(privilege.privilegeId),
        }))}
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { permissionsModel } = this.share;
            const { getUserCanCustomizePermissions, readable } = permissionsModel;
            return getUserCanCustomizePermissions()
                ? renderOp(readable.permissionsDisplay, this.renderPermissions.bind(this))
                : x `
				<p>you are not privileged to customize permissions</p>
			`;
        }
    };
    __decorate$d([
        e()
    ], XiomePermissions.prototype, "roleSelected", void 0);
    XiomePermissions = __decorate$d([
        mixinStyles(styles$f)
    ], XiomePermissions);

    function integrateAuthComponents({ models, modals }) {
        const { accessModel, appsModel, personalModel, permissionsModel } = models;
        return {
            XiomeMyAvatar: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeMyAvatar)),
            XiomeLoginPanel: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeLoginPanel)),
            XiomeAppManager: mixinSnapstateSubscriptions(appsModel.subscribe)(mixinShare({
                modals,
                appsModel,
            })(XiomeAppManager)),
            XiomeMyAccount: mixinSnapstateSubscriptions(personalModel.subscribe)(mixinShare({
                personalModel,
            })(XiomeMyAccount)),
            XiomePermissions: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePermissions)),
            XiomePrivileges: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePrivileges)),
        };
    }

    var usersSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>`;

    var clearIcon = b `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;

    var unmuteIcon = b `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;

    var onOffIcon = b `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-power"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>`;

    function pluralize(length, singular, plural) {
        return length === 1 ?
            singular :
            plural;
    }

    var muteIcon = b `
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-x"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;

    var deleteIcon = b `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;

    function renderChatPost({ post, isModerator, mute, remove, mutedIds, }) {
        const postTime = formatDate(post.time);
        const userIsMuted = mutedIds.includes(post.userId);
        return x `
		<li data-post="${post.postId}">
			<header>
				<span class=nickname>${post.nickname}</span>
				${isModerator
        ? x `
						<span class=moderation>
							<xio-button
								title="mute user"
								@press=${mute}
								?disabled=${userIsMuted}>
									${muteIcon}
							</xio-button>
							<xio-button
								title="delete post"
								@press=${remove}>
									${deleteIcon}
							</xio-button>
						</span>
					`
        : null}
				<xio-id class=userid title="copy user id" id="${post.userId}"></xio-id>
			</header>
			<div>
				<p class=content>
					${post.content}
					<span class=time title="${postTime.date} ${postTime.zone}">
						${postTime.time}
					</span>
				</p>
			</div>
		</li>
	`;
    }

    function renderChatAuthorship({ sendable, onSendClick, onEnterPress, onValidityChange, }) {
        function handleContentChange(event) {
            const value = event.detail.value;
            onValidityChange(value !== undefined);
        }
        return x `
		<div class=authorship>

			<xio-text-input
				textarea
				.validator=${validateChatContent}
				@valuechange=${handleContentChange}
				@enterpress=${onEnterPress}>
			</xio-text-input>

			<xio-button
				?disabled=${!sendable}
				@press=${onSendClick}>
					send message
			</xio-button>
		</div>
	`;
    }

    var chatHistoryCss = i$3 `

.history ol,
.history slot[name="no-messages"] {
	height: var(--xiome-chat-history-height);
	overflow-y: auto;
	scrollbar-color: #0004 #0002;
	scrollbar-width: thin;
}

.history ol::-webkit-scrollbar {
	width: 0.4em;
}

.history ol::-webkit-scrollbar-thumb {
	border-radius: 1em;
	background: #0004;
}

.history ol::-webkit-scrollbar-thumb:hover {
	background: #0008;
}

.history ol::-webkit-scrollbar-thumb:active {
	background: #000a;
}

.history ol::-webkit-scrollbar-track {
	border-radius: 1em;
	background: #0002;
}

slot[name="no-messages"] {
	opacity: 0.5;
	display: flex;
	justify-content: center;
	align-items: center;
	text-align: center;
}

.history li + li {
	margin-top: 0.75em;
}

.history li > header {
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 0.5em;
}

.history li .moderation {
	opacity: 0.5;
}

.history li > header > span {
	display: flex;
	align-items: center;
}

.history li > header > span > xio-button {
	--xio-button-border: none;
	--xio-button-padding: 0 0.3em;
}

.history li .nickname {
	font-size: 1em;
	opacity: var(--xio-chat-nickname-opacity, 0.5);
	color: var(--xio-chat-nickname-color, currentColor);
}

.history li .userid {
	font-size: 1em;
	opacity: var(--xio-chat-userid-opacity, 0.5);
	color: var(--xio-chat-userid-color, currentColor);
}

.history li .content {
	font-size: 1.3em;
	word-break: break-word;
}

.history li .time {
	opacity: 0.3;
	font-size: 1rem;
}

`;

    var xiomeChatCss = i$3 `

:host {
	display: block;
	max-width: 56em;
	--xiome-chat-history-height: 20em;
}

.modheader {
	display: flex;
	flex-wrap: wrap;
	flex-direction: row;
	align-items: end;
	padding: 0 1em;
}

.modheader > span:nth-child(1) {
	opacity: 0.5;
	padding: 0.2em 0;
}

.modheader > span:nth-child(2) {
	margin-left: auto;
}

xio-button {
	--xio-button-disabled-border-style: none;
}

.modheader xio-button {
	--xio-button-border: none;
}

.modheader xio-button::part(button-slot) {
	display: flex;
	align-items: center;
	gap: 0.5em;
}

.history {
	padding: 1em;
	border: 1px solid;
	border-radius: 0.5em 0.5em 0 0;
	border-bottom: 0;
}

.chatbox xiome-login-panel {
	display: block;
	border: 1px solid currentColor;
	border-radius: 0 0 0.5em 0.5em;
}

.chatbox xiome-login-panel[status="logged-out"] {
	padding: 1em;
}

.chatbox slot[name="offline"],
.chatbox slot[name="muted"] {
	display: block;
	padding: 2em 1em;
	text-align: center;
}

.chatbox slot[name="offline"] {
	border: 1px solid currentColor;
	border-radius: 0.5em;
}

.chatfooter {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	margin: 0.1em 0.5em;
}

.chatfooter svg {
	width: 1.3em;
}

.chatfooter .user-count {
	margin: 0 0.5em;
}

.chatfooter .user-counting-details {
	opacity: 0.5;
}

${chatHistoryCss}

.authorship {
	display: flex;
	align-items: stretch;
	Xborder: 1px solid;
}

.authorship xio-text-input {
	border-right: 1px solid;
	--xio-text-input-height: 6em;
	--xio-text-input-label-opacity: 0.5;
	--xio-text-input-border: 0;
	--xio-text-input-pad: 1em;
}

.authorship xio-button {
	height: 6em;
	flex: 1 1 auto;
	--xio-button-border: 0;
	--xio-button-disabled-border-style: none;
}

.authorship xio-button::part(button) {
	width: 100%;
}

.authorship .inputlabel {
	display: block;
	opacity: 0.5;
	padding: 0.2em 0;
	margin-left: 1em;
}

`;

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$c = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$5 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeChat_instances, _XiomeChat_model_get, _XiomeChat_roomStats_get, _XiomeChat_room, _XiomeChat_dispose, _XiomeChat_scrolledToBottom, _XiomeChat_updateScrolledToBottom, _XiomeChat_coordinateScrollingBehavior, _XiomeChat_renderRoomStats, _XiomeChat_renderModerationHeader, _XiomeChat_renderHistory, _XiomeChat_lastSend, _XiomeChat_updateTooSoon, _XiomeChat_subscribeTooSoon, _XiomeChat_postToChat, _XiomeChat_renderParticipation;
    let XiomeChat = class XiomeChat extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeChat_instances.add(this);
            this.room = "default";
            _XiomeChat_room.set(this, void 0);
            _XiomeChat_dispose.set(this, () => { });
            _XiomeChat_scrolledToBottom.set(this, true);
            _XiomeChat_coordinateScrollingBehavior.set(this, () => {
                const ol = this.shadowRoot.querySelector(".history ol");
                if (ol) {
                    if (ol.scrollHeight <= ol.clientHeight)
                        __classPrivateFieldSet$5(this, _XiomeChat_scrolledToBottom, true, "f");
                    else if (__classPrivateFieldGet$c(this, _XiomeChat_scrolledToBottom, "f"))
                        ol.scrollTo(0, ol.scrollHeight - ol.clientHeight);
                }
                else
                    __classPrivateFieldSet$5(this, _XiomeChat_scrolledToBottom, true, "f");
            });
            this.draftValid = false;
            this.tooSoon = false;
            _XiomeChat_lastSend.set(this, Date.now());
            _XiomeChat_updateTooSoon.set(this, () => {
                const since = Date.now() - __classPrivateFieldGet$c(this, _XiomeChat_lastSend, "f");
                this.tooSoon = since < chatPostCoolOff;
            });
            _XiomeChat_postToChat.set(this, (event) => {
                event.preventDefault();
                const { tooSoon } = this;
                if (!tooSoon) {
                    const { value } = this.authorshipInput;
                    const draft = { content: value };
                    __classPrivateFieldSet$5(this, _XiomeChat_lastSend, Date.now(), "f");
                    this.authorshipInput.text = "";
                    __classPrivateFieldGet$c(this, _XiomeChat_updateTooSoon, "f").call(this);
                    __classPrivateFieldGet$c(this, _XiomeChat_room, "f").post(draft);
                }
            });
        }
        subscribe() {
            __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).session(this.room)
                .then(({ room, dispose }) => {
                __classPrivateFieldSet$5(this, _XiomeChat_room, room, "f");
                __classPrivateFieldSet$5(this, _XiomeChat_dispose, dispose, "f");
            })
                .then(() => this.requestUpdate());
            const unsubs = [
                super.subscribe(),
                () => __classPrivateFieldGet$c(this, _XiomeChat_dispose, "f").call(this),
                __classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_subscribeTooSoon).call(this),
                __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).subscribeToChange(__classPrivateFieldGet$c(this, _XiomeChat_coordinateScrollingBehavior, "f")),
            ];
            return () => {
                for (const unsub of unsubs)
                    unsub();
            };
        }
        render() {
            return renderOp(__classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.connectionOp, () => {
                var _a;
                return x `
			<div class=chatbox>
				${__classPrivateFieldGet$c(this, _XiomeChat_room, "f") ?
                x `
						${__classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_renderModerationHeader).call(this)}
						${((_a = __classPrivateFieldGet$c(this, _XiomeChat_room, "f")) === null || _a === void 0 ? void 0 : _a.status) === ChatStatus.Online
                    ? [
                        __classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_renderHistory).call(this),
                        __classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_renderParticipation).call(this),
                        __classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_renderRoomStats).call(this)
                    ]
                    : x `
								<slot name=offline>
									chat is offline
								</slot>
							`}
					` :
                null}
			</div>
		`;
            });
        }
    };
    _XiomeChat_room = new WeakMap();
    _XiomeChat_dispose = new WeakMap();
    _XiomeChat_scrolledToBottom = new WeakMap();
    _XiomeChat_coordinateScrollingBehavior = new WeakMap();
    _XiomeChat_lastSend = new WeakMap();
    _XiomeChat_updateTooSoon = new WeakMap();
    _XiomeChat_postToChat = new WeakMap();
    _XiomeChat_instances = new WeakSet();
    _XiomeChat_model_get = function _XiomeChat_model_get() {
        return this.share.chatModel;
    };
    _XiomeChat_roomStats_get = function _XiomeChat_roomStats_get() {
        var _a;
        const statsForRooms = (_a = __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.cache.roomStats) === null || _a === void 0 ? void 0 : _a.statsForRooms;
        if (statsForRooms) {
            return statsForRooms[this.room];
        }
    };
    _XiomeChat_updateScrolledToBottom = function _XiomeChat_updateScrolledToBottom() {
        const ol = this.shadowRoot.querySelector("ol");
        const { scrollTop, scrollHeight, clientHeight } = ol;
        const scrollTotal = scrollHeight - clientHeight;
        const scrollFromBottom = scrollTotal - scrollTop;
        __classPrivateFieldSet$5(this, _XiomeChat_scrolledToBottom, scrollFromBottom < 50, "f");
    };
    _XiomeChat_renderRoomStats = function _XiomeChat_renderRoomStats() {
        const roomStats = __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_roomStats_get);
        if (roomStats) {
            const { moderators, viewers, participants, totalUsers } = roomStats;
            return __classPrivateFieldGet$c(this, _XiomeChat_room, "f")
                ? x `
					<p class=chatfooter>
						${usersSvg}
						<span class=user-count>
							${totalUsers} ${pluralize(totalUsers, "user", "users")}
						</span>
						<span class=user-counting-details>
							(${moderators} ${pluralize(moderators, "moderator", "moderators")},
							${participants} ${pluralize(participants, "participant", "participants")},
							${viewers} ${pluralize(viewers, "viewer", "viewers")})
						</span>
					</p>
				`
                : null;
        }
    };
    _XiomeChat_renderModerationHeader = function _XiomeChat_renderModerationHeader() {
        const status = __classPrivateFieldGet$c(this, _XiomeChat_room, "f").status;
        const toggleStatus = () => {
            __classPrivateFieldGet$c(this, _XiomeChat_room, "f").setRoomStatus(__classPrivateFieldGet$c(this, _XiomeChat_room, "f").status === ChatStatus.Offline
                ? ChatStatus.Online
                : ChatStatus.Offline);
        };
        const muteCount = __classPrivateFieldGet$c(this, _XiomeChat_room, "f").muted.length;
        return __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats
            ? x `
				<header class=modheader>
					<span>room="${this.room}"</span>
					<span>
						<xio-button
							title="unmute ${muteCount} users"
							?disabled=${muteCount === 0}
							@press=${() => __classPrivateFieldGet$c(this, _XiomeChat_room, "f").unmuteAll()}>
								${unmuteIcon} ${muteCount}
						</xio-button>
						<xio-button
							title="clear chat room"
							@press=${() => __classPrivateFieldGet$c(this, _XiomeChat_room, "f").clear()}>
								${clearIcon}
						</xio-button>
						<xio-button
							title="set chat ${status === ChatStatus.Offline ? "online" : "offline"}"
							@press=${toggleStatus}>
								${onOffIcon}
						</xio-button>
					</span>
				</header>
			`
            : null;
    };
    _XiomeChat_renderHistory = function _XiomeChat_renderHistory() {
        return x `
			<div class=history>
				${__classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.viewAllChats
        ? x `
						${__classPrivateFieldGet$c(this, _XiomeChat_room, "f").posts.length
            ? x `
								<ol @scroll=${__classPrivateFieldGet$c(this, _XiomeChat_instances, "m", _XiomeChat_updateScrolledToBottom)}>
									${__classPrivateFieldGet$c(this, _XiomeChat_room, "f").posts.map(post => renderChatPost({
                post,
                isModerator: __classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats,
                mute: () => __classPrivateFieldGet$c(this, _XiomeChat_room, "f").mute(post.userId),
                remove: () => __classPrivateFieldGet$c(this, _XiomeChat_room, "f").remove([post.postId]),
                mutedIds: __classPrivateFieldGet$c(this, _XiomeChat_room, "f").muted
            }))}
								</ol>
							`
            : x `
								<slot name=no-messages>
									no messages
								</slot>
							`}
					`
        : x `
						<slot name=cannot-view>
							you are not privileged to view the chat
						</slot>
					`}
			</div>
		`;
    };
    _XiomeChat_subscribeTooSoon = function _XiomeChat_subscribeTooSoon() {
        const interval = setInterval(__classPrivateFieldGet$c(this, _XiomeChat_updateTooSoon, "f"), 1000);
        return () => clearInterval(interval);
    };
    _XiomeChat_renderParticipation = function _XiomeChat_renderParticipation() {
        const authorshipArea = () => {
            return __classPrivateFieldGet$c(this, _XiomeChat_room, "f").weAreBanned
                ? x `<slot name=banned>you are banned</slot>`
                : __classPrivateFieldGet$c(this, _XiomeChat_room, "f").weAreMuted
                    ? x `<slot name=muted>you are muted</slot>`
                    : renderChatAuthorship({
                        sendable: !!this.draftValid && !this.tooSoon,
                        onSendClick: __classPrivateFieldGet$c(this, _XiomeChat_postToChat, "f"),
                        onEnterPress: __classPrivateFieldGet$c(this, _XiomeChat_postToChat, "f"),
                        onValidityChange: valid => this.draftValid = valid,
                    });
        };
        return x `
			<xiome-login-panel>
				${whenOpReady(__classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.accessOp, () => x `
					<slot name=logged-out slot=logged-out>
						login to participate in the chat
					</slot>
					<div class=participation>
						${__classPrivateFieldGet$c(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.participateInAllChats
        ? authorshipArea()
        : x `
								<slot name=cannot-participate>
									you do not have privilege to participate in the chat
								</slot>
							`}
					</div>
				`)}
			</xiome-login-panel>
		`;
    };
    __decorate$c([
        e({ type: String })
    ], XiomeChat.prototype, "room", void 0);
    __decorate$c([
        e()
    ], XiomeChat.prototype, "draftValid", void 0);
    __decorate$c([
        i(".authorship xio-text-input")
    ], XiomeChat.prototype, "authorshipInput", void 0);
    __decorate$c([
        e()
    ], XiomeChat.prototype, "tooSoon", void 0);
    XiomeChat = __decorate$c([
        mixinStyles(xiomeChatCss)
    ], XiomeChat);

    function integrateChatComponents({ models, modals }) {
        const { chatModel } = models;
        return {
            XiomeChat: (mixinSnapstateSubscriptions(chatModel.subscribe)(mixinShare({
                modals,
                chatModel,
            })(XiomeChat))),
        };
    }

    var styles$e = i$3 `

:host {
	display: flex;
	flex-direction: column;
	align-items: stretch;
	justify-content: center;
	max-width: 32em;
	border: solid 0.1em;
}

xio-button {
	--xio-button-border: none;
	--_disabled-border-style: none;
}

/* Note tabs new/old */

.tabs {
	display: flex;
	justify-content: space-evenly;
	padding-bottom: 1em;
	margin: 1em 2em;
	border-bottom: solid 0.1em;
}

[data-tab] {
	font-weight: normal;
}

[data-tab][data-active='true'] {
	font-weight: bold;
	border-bottom: solid 0.2em;
}

/* Individual note */

ol > li {
	display: flex;
	flex-direction: column;
	padding: 1em;
	margin: 1em 2em;
	border: solid 0.1em;
	list-style-type: none;
}

ol > li > header {
	display: flex;
	justify-content: space-between;
	align-self: flex-end;
	width: 100%;
}

ol > li > p {
	opacity: 0.6;
}

/* Pagination */

.paginationBar {
	display: flex;
	justify-content: center;
	align-items: center;
	margin: 1em 2em;
}

.paginationBar > span {
	margin: 0em 1em;
}

/* Notifications */

xio-op[mode="loading"], slot {
	display: block;
	text-align: center;
	width: 100%;
	margin-bottom: 1em;
}

/* Button bar */

.buttonbar {
	display: flex;
	justify-content: flex-end;
	padding-top: 1em;
	margin: 0 2em 1em 2em;
	border-top: solid 0.1em;
}

.buttonbar > xio-button {
	--xio-button-border: solid 0.1em;
}
`;

    var chevronLeft = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"></polyline></svg>`;

    var chevronRight = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    var plus = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;

    var crossSvg = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;

    const plural = (x) => x === 1 ? "" : "s";
    function formatDuration(milliseconds) {
        const extract = (x) => {
            const result = Math.floor(milliseconds / x);
            milliseconds %= x;
            return result;
        };
        const days = extract(day);
        const hours = extract(hour);
        const minutes = extract(minute);
        const seconds = extract(second);
        const readable = {
            days: `${days} day${plural(days)}`,
            hours: `${hours} hour${plural(hours)}`,
            minutes: `${minutes} minute${plural(minutes)}`,
            seconds: `${seconds} second${plural(seconds)}`,
        };
        const ago = days > 3
            ? `${readable.days} ago`
            : days > 1
                ? `${readable.days} and ${readable.hours} ago`
                : hours > 3
                    ? `${readable.hours} ago`
                    : hours > 1
                        ? `${readable.hours} and ${readable.minutes} ago`
                        : minutes > 3
                            ? `${readable.minutes} ago`
                            : minutes > 1
                                ? `${readable.minutes} and ${readable.seconds} ago`
                                : `${readable.seconds} ago`;
        return {
            ...readable,
            ago,
        };
    }

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$b = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeNotes_instances, _XiomeNotes_model, _XiomeNotes_cacheDetails, _XiomeNotes_cache, _XiomeNotes_renderTabs, _XiomeNotes_renderNotes, _XiomeNotes_renderPagination, _XiomeNotes_renderButtonbar, _XiomeNotes_renderBasedOnStateOfNotesArray;
    let XiomeNotes = class XiomeNotes extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeNotes_instances.add(this);
            _XiomeNotes_model.set(this, this.share.notesModel);
            _XiomeNotes_cacheDetails.set(this, this.share.notesModel.createNotesCacheDetails());
            _XiomeNotes_cache.set(this, __classPrivateFieldGet$b(this, _XiomeNotes_cacheDetails, "f").cache);
        }
        async init() {
            await __classPrivateFieldGet$b(this, _XiomeNotes_model, "f").initialize();
        }
        subscribe() {
            const unsubs = [
                super.subscribe(),
                __classPrivateFieldGet$b(this, _XiomeNotes_cacheDetails, "f").setup(),
                __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").subscribe(() => this.requestUpdate()),
            ];
            if (__classPrivateFieldGet$b(this, _XiomeNotes_model, "f").isLoggedIn) {
                __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").fetchAppropriateNotes();
            }
            return () => unsubs.forEach(unsub => unsub());
        }
        render() {
            return renderOp(__classPrivateFieldGet$b(this, _XiomeNotes_model, "f").state.accessOp, access => (access === null || access === void 0 ? void 0 : access.user)
                ? x `
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderBasedOnStateOfNotesArray).call(this)}
				`
                : x `
					<slot name="logged-out">
						you must be logged in to see your notifications
					</slot>
				`);
        }
    };
    _XiomeNotes_model = new WeakMap();
    _XiomeNotes_cacheDetails = new WeakMap();
    _XiomeNotes_cache = new WeakMap();
    _XiomeNotes_instances = new WeakSet();
    _XiomeNotes_renderTabs = function _XiomeNotes_renderTabs() {
        const { old } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").cacheState;
        const { switchTabNew, switchTabOld } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f");
        return x `
			<div class=tabs>
				<xio-button
					@press=${switchTabNew}
					data-tab="new"
					data-active=${!old}>
						new
				</xio-button>
				<xio-button
					@press=${switchTabOld}
					data-tab="old"
					data-active=${old}>
						old
				</xio-button>
			</div>
		`;
    };
    _XiomeNotes_renderNotes = function _XiomeNotes_renderNotes() {
        const { old, notesOp } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").cacheState;
        const { markSpecificNoteNew, markSpecificNoteOld } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f");
        const now = Date.now();
        return renderOp(notesOp, notes => x `
			<ol>
				${notes.map(note => x `
					<li>
						<header class="note-header">
							<h2>${note.title}</h2>
							${old ? x `
								<xio-button @press=${() => markSpecificNoteNew(note.noteId)}>
									${plus}
								</xio-button>
							` : x `
								<xio-button @press=${() => markSpecificNoteOld(note.noteId)}>
									${crossSvg}
								</xio-button>
							`}
						</header>
						<p><strong>${note.type}</strong> â€“ <em>${formatDuration(now - note.time).ago}</em></p>
					</li>
				`)}
			</ol>
		`);
    };
    _XiomeNotes_renderPagination = function _XiomeNotes_renderPagination() {
        const { pageNumber } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").cacheState;
        const { nextPage, previousPage, totalPages, isNextPageAvailable, isPreviousPageAvailable, } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f");
        return x `
			${(isNextPageAvailable || isPreviousPageAvailable)
        ? x `
				<div class="paginationBar">
					<xio-button
						?disabled=${!isPreviousPageAvailable}
						@press=${previousPage}>
							${chevronLeft}
					</xio-button>
					<span>
						${pageNumber} / ${totalPages}
					</span>
					<xio-button
						?disabled=${!isNextPageAvailable}
						@press=${nextPage}>
							${chevronRight}
					</xio-button>
				</div>
				`
        : null}
		`;
    };
    _XiomeNotes_renderButtonbar = function _XiomeNotes_renderButtonbar() {
        const { old } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").cacheState;
        const { markAllNotesOld } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f");
        return x `
			<div class=buttonbar>
				${old
        ? null
        : x `
						<xio-button @press=${markAllNotesOld}>
							mark all old
						</xio-button>
					`}
			</div>
		`;
    };
    _XiomeNotes_renderBasedOnStateOfNotesArray = function _XiomeNotes_renderBasedOnStateOfNotesArray() {
        var _a;
        const { old, notesOp } = __classPrivateFieldGet$b(this, _XiomeNotes_cache, "f").cacheState;
        return x `
			${((_a = ops.value(notesOp)) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? x `
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					<slot name="empty">
						you have no ${old ? 'old' : 'new'} notifications
					</slot>
				`
        : x `
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderNotes).call(this)}
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderPagination).call(this)}
					${__classPrivateFieldGet$b(this, _XiomeNotes_instances, "m", _XiomeNotes_renderButtonbar).call(this)}
				`}
		`;
    };
    XiomeNotes = __decorate$b([
        mixinStyles(styles$e)
    ], XiomeNotes);

    var styles$d = i$3 `

:host {
	display: inline-block;
	--xiome-notes-indicator-count-size: 1em;
	--xiome-notes-indicator-color: red;
	--xiome-notes-indicator-bleedout: 0em;
	font-size: var(--xiome-notes-indicator-size, 1em);
	width: var(--xiome-notes-indicator-icon-size, 3em);
	position: relative;
}

:host([no-icon]) .bell {
	display: none;
}

.count {
	display: flex;
	justify-content: center;
	align-items: center;
	vertical-align: top;
	position: absolute;
	height: 1em;
	width: 1em;
	background-color: var(--xiome-notes-indicator-color);
	border-radius: 50%;
	text-align: center;
	right: var(--xiome-notes-indicator-bleedout);
	top: var(--xiome-notes-indicator-bleedout);
	font-weight: bold;
	color: white;
	font-size: var(--xiome-notes-indicator-count-size);
}
`;

    var bell = b `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-bell"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>`;

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeNotesIndicator = class XiomeNotesIndicator extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.noIcon = false;
        }
        render() {
            const bellSpan = x `<span class="bell">${bell}</span>`;
            const { stats } = this.share.notesModel;
            return x `
				${stats.newCount === 0 ? x `${bellSpan}`
            : x `
					<span class="count">${stats.newCount}</span>
					${bellSpan}
				`}
			`;
        }
    };
    __decorate$a([
        e({ attribute: "no-icon" })
    ], XiomeNotesIndicator.prototype, "noIcon", void 0);
    XiomeNotesIndicator = __decorate$a([
        mixinStyles(styles$d)
    ], XiomeNotesIndicator);

    function integrateNotesComponents({ models: { notesModel } }) {
        return {
            XiomeNotes: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotes))),
            XiomeNotesIndicator: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotesIndicator))),
        };
    }

    var styles$c = i$3 `

:host {
	display: block;
}

`;

    function renderView({ view, onDeleteClick, getPrivilegeDisplay }) {
        return x `
		<div class="view">
			<div class="view-details">
				<div>
					<h4>hosting provider</h4>
					<p>${view.reference.provider}</p>
				</div>
				<div>
					<h4>content type</h4>
					<p>${view.reference.type}</p>
				</div>
				<div>
					<h4>content id</h4>
					<xio-id id="${view.reference.id}"></xio-id>
				</div>
			</div>
			<h4>privileges with access</h4>
			<ul>
				${view.privileges.map(getPrivilegeDisplay)
        .map(privilege => privilege
        ? x `<li>${privilege.label}</li>`
        : null)}
			</ul>
			<div class=buttonbar>
			<xio-button @press=${onDeleteClick}>
				unassign from this display
			</xio-button>
			</div>
		</div>
	`;
    }

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeVideoViews = class XiomeVideoViews extends mixinRequireShare()(Component) {
        async init() {
            this.share.contentModel.initializeForModerationData();
        }
        render() {
            const model = this.share.contentModel;
            return model.allowance.canModerateVideos
                ? renderOp(model.state.viewsOp, views => x `
				<slot>
					<h3>all video views</h3>
				</slot>
				${views.length ? x `
					<div class=views>
						${views.map(view => renderView({
                view,
                onDeleteClick: () => model.deleteView(view.label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            }))}
					</div>
				` : x `
					<slot name=no-views>
						<p>no video views are registered</p>
					</slot>
				`}
			`)
                : x `
				<slot name=unprivileged>
					<p>you don't have sufficient privileges to moderate video views</p>
				</slot>
			`;
        }
    };
    XiomeVideoViews = __decorate$9([
        mixinStyles(styles$c)
    ], XiomeVideoViews);

    var clockIcon = b `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;

    var styles$b = i$3 `

:host {
	display: block;
	width: 24em;
	max-width: 100%;
	border: 1px solid;
	border-radius: 5px;
	--xiome-video-hosting-warning-color: red;
}

.dacastbox {
	padding: 1em;
}

xio-text-input::part(problems) {
	width: 100%;
}

.buttonbar {
	display: flex;
	flex-direction: row;
	justify-content: flex-end;
}

.buttonbar > * {
	margin: 0.4em 0.2em;
}

.failed {
	color: var(--xiome-video-hosting-warning-color);
	display: flex;
	align-items: center;
	padding: 0.5em 0;
}

.failed svg {
	margin-right: 0.5em;
}

.linked {
	display: flex;
}

.helpbox ul {
	padding-left: 1.5em;
}

.link-time-info {
	display: inline-flex;
	align-items: center;
	padding: 0.5em 0;
}


.unlink-button {
	display: flex;
	justify-content: flex-end;
}

.link-time-info svg {
	width: 6em;
	height: 3em;
}
`;

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$a = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$4 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeVideoHosting_showHelp, _XiomeVideoHosting_linkFailed, _XiomeVideoHosting_apiKeyDraft, _XiomeVideoHosting_handleInputChange, _XiomeVideoHosting_handleLinkClick, _XiomeVideoHosting_handleUnlinkClick, _XiomeVideoHosting_toggleHelp, _XiomeVideoHosting_renderHelp, _XiomeVideoHosting_renderWhenUnlinked, _XiomeVideoHosting_renderWhenLinked;
    let XiomeVideoHosting = class XiomeVideoHosting extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoHosting_showHelp.set(this, false);
            _XiomeVideoHosting_linkFailed.set(this, false);
            _XiomeVideoHosting_apiKeyDraft.set(this, "");
            _XiomeVideoHosting_handleInputChange.set(this, ({ detail: { value } }) => {
                __classPrivateFieldSet$4(this, _XiomeVideoHosting_apiKeyDraft, value, "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_handleLinkClick.set(this, async () => {
                const apiKey = __classPrivateFieldGet$a(this, _XiomeVideoHosting_apiKeyDraft, "f");
                if (apiKey) {
                    __classPrivateFieldSet$4(this, _XiomeVideoHosting_linkFailed, false, "f");
                    __classPrivateFieldSet$4(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                    const link = await this.share.dacastModel.linkAccount({ apiKey });
                    __classPrivateFieldSet$4(this, _XiomeVideoHosting_linkFailed, !link, "f");
                }
            });
            _XiomeVideoHosting_handleUnlinkClick.set(this, async () => {
                __classPrivateFieldSet$4(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                await this.share.dacastModel.unlinkAccount();
            });
            _XiomeVideoHosting_toggleHelp.set(this, () => {
                __classPrivateFieldSet$4(this, _XiomeVideoHosting_showHelp, !__classPrivateFieldGet$a(this, _XiomeVideoHosting_showHelp, "f"), "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_renderHelp.set(this, () => {
                return x `
			<div class=helpbox>
				<p>how to find your dacast api key:</p>
				<ul>
					<li>create a <a part=link target=_blank href="https://dacast.com/">dacast</a> account</li>
					<li>if you have a trial account, you must email support and ask them to activate your account's "api access"</li>
					<li>generate an api key in your <a part=link target=_blank href="https://app.dacast.com/settings/integrations">dacast integrations settings</a></li>
				</ul>
			</div>
		`;
            });
            _XiomeVideoHosting_renderWhenUnlinked.set(this, () => {
                return x `
			<h2>link your dacast account</h2>
			<xio-text-input
				placeholder="api key"
				.validator=${validateDacastApiKeyAllowingMock}
				@enterpress=${__classPrivateFieldGet$a(this, _XiomeVideoHosting_handleLinkClick, "f")}
				@valuechange=${__classPrivateFieldGet$a(this, _XiomeVideoHosting_handleInputChange, "f")}>
			</xio-text-input>
			${__classPrivateFieldGet$a(this, _XiomeVideoHosting_linkFailed, "f")
                ? x `<div class=failed>${warningSvg} <p>dacast rejected the api link</p></div>`
                : null}
			<div class=buttonbar>
				<xio-button
					class=help-button
					@press=${__classPrivateFieldGet$a(this, _XiomeVideoHosting_toggleHelp, "f")}>
						${__classPrivateFieldGet$a(this, _XiomeVideoHosting_showHelp, "f")
                ? "hide help"
                : "show help"}
				</xio-button>
				<xio-button
					class=link-button
					?disabled=${!__classPrivateFieldGet$a(this, _XiomeVideoHosting_apiKeyDraft, "f")}
					@press=${__classPrivateFieldGet$a(this, _XiomeVideoHosting_handleLinkClick, "f")}>
						link
				</xio-button>
			</div>
			${__classPrivateFieldGet$a(this, _XiomeVideoHosting_showHelp, "f")
                ? __classPrivateFieldGet$a(this, _XiomeVideoHosting_renderHelp, "f").call(this)
                : null}
		`;
            });
            _XiomeVideoHosting_renderWhenLinked.set(this, (linkedAccount) => {
                return x `
			<h2>your dacast account is linked</h2>
			<div class=link-time-info>
				${clockIcon}
				<p>linked on ${formatDate(linkedAccount.time).full}</p>
			</div>
			<div class=unlink-button>
				<xio-button @press=${__classPrivateFieldGet$a(this, _XiomeVideoHosting_handleUnlinkClick, "f")}>unlink</xio-button>
			</div>
		`;
            });
        }
        get state() {
            return this.share.dacastModel.state;
        }
        async init() {
            await this.share.dacastModel.initialize();
        }
        render() {
            return renderOp(this.state.accessOp, access => x `
			<div class=dacastbox>
				${access.permit.privileges.includes(videoPrivileges["moderate videos"])
            ? renderOp(this.state.linkedAccountOp, linkedAccount => linkedAccount
                ? __classPrivateFieldGet$a(this, _XiomeVideoHosting_renderWhenLinked, "f").call(this, linkedAccount)
                : __classPrivateFieldGet$a(this, _XiomeVideoHosting_renderWhenUnlinked, "f").call(this))
            : x `<slot name=forbidden>you don't have permission to edit video hosting settings</slot>`}
			</div>
		`);
        }
    };
    _XiomeVideoHosting_showHelp = new WeakMap();
    _XiomeVideoHosting_linkFailed = new WeakMap();
    _XiomeVideoHosting_apiKeyDraft = new WeakMap();
    _XiomeVideoHosting_handleInputChange = new WeakMap();
    _XiomeVideoHosting_handleLinkClick = new WeakMap();
    _XiomeVideoHosting_handleUnlinkClick = new WeakMap();
    _XiomeVideoHosting_toggleHelp = new WeakMap();
    _XiomeVideoHosting_renderHelp = new WeakMap();
    _XiomeVideoHosting_renderWhenUnlinked = new WeakMap();
    _XiomeVideoHosting_renderWhenLinked = new WeakMap();
    XiomeVideoHosting = __decorate$8([
        mixinStyles(styles$b)
    ], XiomeVideoHosting);

    var styles$a = i$3 `

:host {
	display: block;
	--_select-bg: var(--xiome-video-display-select-background, #222);
	--xiome-video-display-selected-option-color: cyan;
}

.controls-title,
.view,
.viewcreator {
	max-width: 42rem;
}

[part="iframe"] {
	width: 100%;
	border: none;
}

.mock-embed img {
	width: 100%;
}

.buttonbar {
	text-align: right;
}

.controls-title,
.viewcreator,
.view {
	border: 1px solid;
	border-radius: 0.2em;
}

.controls-title {
	padding: 0.1em 0.5em;
}
.controls-title[data-open] {
	border-bottom-left-radius: 0;
	border-bottom-right-radius: 0;
}
.view, .viewcreator {
	border-top: 0;
	border-top-left-radius: 0;
	border-top-right-radius: 0;
}

.controls-title {
	display: flex;
	align-items: center;
}
.controls-title div span {
	display: block;
}
.controls-title span:nth-of-type(2) {
	opacity: 0.8;
	font-size: 0.8em;
	font-weight: normal;
	padding-left: 0.2em;
}

.togglebutton {
	--xio-button-border: 0;
	margin-left: auto;
	transition: transform 300ms ease;
	transform: rotate(0deg);
}
[data-open] .togglebutton {
	transform: rotate(180deg);
}

.view, .viewcreator {
	display: flex;
	flex-direction: column;
	gap: 0.2em;
	padding: 0.5em;
}

.viewcreator .selectionarea {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	width: 100%;
	gap: 0.5em;
	margin: 0.5em 0;
}

.viewcreator .selectionarea > * {
	flex: 1 1 auto;
}

select {
	color: inherit;
	background: transparent;
	border: 1px solid;
	width: 100%;
}

select[multiple] {
	min-height: 10em;
}

select option {
	padding: 0.1em 0.2em;
	color: inherit;
	background: var(--_select-bg);
}

.create-privileges {
	visibility: hidden;
}

.create-privileges[data-visible] {
	visibility: visible;
}

.create-privileges option[selected] {
	color: var(--xiome-video-display-selected-option-color);
}

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-thumb { background: currentColor; }

::scrollbar { width: 8px; }
::scrollbar-thumb { background: currentColor; }

/* When video is displayed css */

.view-details {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-around;
	gap: 0.8em;
	margin: 0.5em 0;
}

.view-details > * {
	text-align: center;
}

.view ul {
	display: flex;
	justify-content: left;
	text-align: center;
	list-style-type: none;
	flex-wrap: wrap;
}

.view ul li {
	border: 1px solid;
	margin: 0.2em;
	padding: 0.1em 0.4em;
	border-radius: 1em;
}

`;

    function makeHtmlElement(tag, attributes) {
        const element = document.createElement(tag);
        for (const [key, value] of Object.entries(attributes))
            element.setAttribute(key, value);
        return element;
    }

    const dacastIframeRegex = /"(https:\/\/iframe\.dacast\.com\/(\S+)\/(\S+))"/i;
    function parseDacastIframeSrc(code) {
        const parts = code.match(dacastIframeRegex);
        if (!parts)
            throw new Error(`failed to parse dacast iframe embed code: make-dacast-iframe likely needs to be updated`);
        const [, , resource, id] = parts;
        const fixedResource = resource === "playlists"
            ? "playlist"
            : resource;
        return `https://iframe.dacast.com/${fixedResource}/${id}`;
    }

    let mockCount = 0;
    function prepareEmbeds() {
        const map = new Map();
        return {
            obtain(details, mockEmbed) {
                if (details.provider !== "dacast")
                    throw new Error(`unsupported video provider "${details.provider}"`);
                let div = map.get(details.id);
                if (!div) {
                    div = makeHtmlElement("div", {
                        "data-id": details.id,
                    });
                    const embed = mockEmbed
                        ? makeHtmlElement("img", {
                            part: "iframe",
                            alt: "",
                            src: `https://source.unsplash.com/random/480x270?${mockCount++}`
                        })
                        : makeHtmlElement("iframe", {
                            src: parseDacastIframeSrc(details.embed),
                            part: "iframe",
                            allowfullscreen: "",
                            webkitallowfullscreen: "",
                            mozallowfullscreen: "",
                            oallowfullscreen: "",
                            msallowfullscreen: "",
                            frameborder: "0",
                            scrolling: "no",
                            allow: "autoplay",
                        });
                    div.appendChild(embed);
                    map.set(details.id, div);
                }
                return div;
            },
        };
    }

    function renderViewCreator({ isContentSelected, isCreateButtonDisabled, privilegesOp, catalogOp, selectedContent, queryAll, onCatalogSelect, onPrivilegesSelect, onCreateClick, isPrivilegeSelected, }) {
        const onCatalogSelectChange = (event) => {
            const target = event.target;
            onCatalogSelect(parseInt(target.value));
        };
        const onPrivilegesSelectChange = () => {
            onPrivilegesSelect(queryAll(".create-privileges select option")
                .filter(option => option.selected).map(option => option.value));
        };
        function renderContentSelector() {
            const catalog = ops.value(catalogOp);
            return x `
			<div class=create-content>
				${catalog.length ? x `
					<h5>Select content for this view</h5>
					<select @change=${onCatalogSelectChange}>
						${isContentSelected
            ? null
            : x `
								<option disabled selected>
									(select video content)
								</option>
							`}
						${catalog.map(({ provider, type, title }, index) => x `
							<option value=${index} ?selected=${index === selectedContent}>
								${`${provider} ${type} ${title}`}
							</option>
						`)}
					</select>
				` : x `
					<p>no available video content (are your video accounts linked?)</p>
				`}
			</div>
		`;
        }
        function renderPrivilegeSelector() {
            const privileges = ops.value(privilegesOp);
            return x `
			<div class="create-privileges" ?data-visible=${isContentSelected}>
				<h5>Select which privileges have access</h5>
				<select multiple @change=${onPrivilegesSelectChange}>
					${privileges.map(privilege => x `
						<option
							?selected=${isPrivilegeSelected(privilege.privilegeId)}
							value="${privilege.privilegeId}">
								${privilege.label}
						</option>
					`)}
				</select>
			</div>
		`;
        }
        return renderOp(ops.combine(catalogOp, privilegesOp), () => x `
		<div class=viewcreator>
			<h4>Assign Video Content</h4>
			<div class=selectionarea>
				${renderContentSelector()}
				${renderPrivilegeSelector()}
			</div>
			<div class=buttonbar>
				<xio-button
					class=create-button
					?disabled=${isCreateButtonDisabled}
					@press=${onCreateClick}>
						Assign To This Video
				</xio-button>
			</div>
		</div>
	`);
    }

    var triangle = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g transform="rotate(180 8 8)"><g fill="currentColor"><path fill-rule="evenodd" d="M7.022 1.566a1.13 1.13 0 0 1 1.96 0l6.857 11.667c.457.778-.092 1.767-.98 1.767H1.144c-.889 0-1.437-.99-.98-1.767L7.022 1.566z"/></g></g></svg>`;

    function videoControls({ queryAll, contentModel: model, requestUpdate, }) {
        const { readable, writable, subscribe } = snapstate({
            open: false,
            selectedContent: undefined,
            selectedPrivileges: [],
        });
        const toggleControls = () => {
            writable.open = !writable.open;
        };
        function render(label) {
            const currentView = model.getView(label);
            return x `
			<h3 class=controls-title ?data-open=${readable.open}>
				<div>
					<span>video display controls</span>
					<span>label = <em>"${label}"</em></span>
				</div>
				<xio-button
					class=togglebutton
					title="${readable.open ? "close" : "open"} video controls"
					@press=${toggleControls}>
						${triangle}
				</xio-button>
			</h3>
			${readable.open ? x `
				${currentView
            ? renderView({
                view: currentView,
                onDeleteClick: () => model.deleteView(label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            })
            : renderViewCreator({
                queryAll,
                catalogOp: model.state.catalogOp,
                privilegesOp: model.state.privilegesOp,
                isContentSelected: readable.selectedContent !== undefined,
                selectedContent: readable.selectedContent,
                isCreateButtonDisabled: readable.selectedContent === undefined
                    || readable.selectedPrivileges.length === 0,
                onCatalogSelect: index => {
                    writable.selectedContent = index;
                    writable.selectedPrivileges = [];
                },
                isPrivilegeSelected: id => {
                    return readable.selectedPrivileges.some(e => e === id);
                },
                onPrivilegesSelect: privileges => {
                    writable.selectedPrivileges = privileges;
                },
                onCreateClick: () => {
                    const { selectedContent, selectedPrivileges } = readable;
                    writable.selectedContent = undefined;
                    writable.selectedPrivileges = [];
                    const content = model.catalog[selectedContent];
                    model.setView({
                        label,
                        privileges: selectedPrivileges,
                        reference: {
                            id: content.id,
                            type: content.type,
                            provider: content.provider,
                        },
                    });
                }
            })}
			` : null}
		`;
        }
        return {
            render,
            subscribe: () => subscribe(requestUpdate),
        };
    }

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$9 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoDisplay_instances, _XiomeVideoDisplay_model_get, _XiomeVideoDisplay_embeds, _XiomeVideoDisplay_videoControls, _XiomeVideoDisplay_renderShow;
    let XiomeVideoDisplay = class XiomeVideoDisplay extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoDisplay_instances.add(this);
            this.label = "default";
            this["mock-embed"] = false;
            this["show-title"] = false;
            _XiomeVideoDisplay_embeds.set(this, prepareEmbeds());
            _XiomeVideoDisplay_videoControls.set(this, (() => {
                const controls = videoControls({
                    contentModel: __classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get),
                    requestUpdate: () => this.requestUpdate(),
                    queryAll: s => Array.from(this.shadowRoot.querySelectorAll(s)),
                });
                this.addSubscription(controls.subscribe);
                return controls;
            })());
        }
        async init() {
            await __classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).initializeForVideo(this.label);
        }
        render() {
            return renderOp(__classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).state.accessOp, () => x `
			${__classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).allowance.canModerateVideos
            ? __classPrivateFieldGet$9(this, _XiomeVideoDisplay_videoControls, "f").render(this.label)
            : null}
			${__classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "m", _XiomeVideoDisplay_renderShow).call(this)}
		`);
        }
    };
    _XiomeVideoDisplay_embeds = new WeakMap();
    _XiomeVideoDisplay_videoControls = new WeakMap();
    _XiomeVideoDisplay_instances = new WeakSet();
    _XiomeVideoDisplay_model_get = function _XiomeVideoDisplay_model_get() {
        return this.share.contentModel;
    };
    _XiomeVideoDisplay_renderShow = function _XiomeVideoDisplay_renderShow() {
        var _a, _b;
        const show = __classPrivateFieldGet$9(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).getShow(this.label);
        switch ((_a = show === null || show === void 0 ? void 0 : show.status) !== null && _a !== void 0 ? _a : "unavailable") {
            case "unavailable":
                return x `<slot name=unavailable></slot>`;
            case "unprivileged":
                return x `<slot name=unprivileged></slot>`;
            case "available":
                return x `
					${this["show-title"]
                ? x `<h4 part=title>${show.details.title}</h4>`
                : null}
					${(_b = __classPrivateFieldGet$9(this, _XiomeVideoDisplay_embeds, "f")
                .obtain(show.details, this["mock-embed"])) !== null && _b !== void 0 ? _b : "(embed missing)"}
					<slot></slot>
				`;
        }
    };
    __decorate$7([
        e({ type: String })
    ], XiomeVideoDisplay.prototype, "label", void 0);
    __decorate$7([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "mock-embed", void 0);
    __decorate$7([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "show-title", void 0);
    XiomeVideoDisplay = __decorate$7([
        mixinStyles(styles$a)
    ], XiomeVideoDisplay);

    var styles$9 = i$3 `

:host {
	display: block;
}

`;

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$8 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoCompanion_instances, _XiomeVideoCompanion_model_get;
    let XiomeVideoCompanion = class XiomeVideoCompanion extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoCompanion_instances.add(this);
            this.label = "default";
        }
        init() {
            __classPrivateFieldGet$8(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).initializeForVideo(this.label);
        }
        render() {
            const show = __classPrivateFieldGet$8(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).getShow(this.label);
            const { accessOp, showsOp } = __classPrivateFieldGet$8(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).state;
            const combinedOp = ops.combine(accessOp, showsOp);
            return renderOp(combinedOp, () => show
                ? show.details
                    ? x `<slot></slot>`
                    : x `<slot name=unprivileged></slot>`
                : x `<slot name=unavailable></slot>`);
        }
    };
    _XiomeVideoCompanion_instances = new WeakSet();
    _XiomeVideoCompanion_model_get = function _XiomeVideoCompanion_model_get() {
        return this.share.contentModel;
    };
    __decorate$6([
        e({ type: String })
    ], XiomeVideoCompanion.prototype, "label", void 0);
    XiomeVideoCompanion = __decorate$6([
        mixinStyles(styles$9)
    ], XiomeVideoCompanion);

    function integrateVideoComponents({ models }) {
        const { dacastModel, contentModel } = models.videoModels;
        return {
            XiomeVideoHosting: (mixinSnapstateSubscriptions(dacastModel.subscribe)(mixinShare({
                dacastModel,
            })(XiomeVideoHosting))),
            XiomeVideoDisplay: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoDisplay))),
            XiomeVideoViews: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoViews))),
            XiomeVideoCompanion: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoCompanion))),
        };
    }

    var styles$8 = i$3 `

:host {
	display: block;
}

`;

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeExample = class XiomeExample extends mixinRequireShare()(Component) {
        get state() {
            return this.share.exampleModel.state;
        }
        render() {
            return renderOp(this.state.accessOp, access => x `
			<p>Example Component</p>
			${(access === null || access === void 0 ? void 0 : access.user)
            ? x `<p>Welcome, ${access.user.profile.nickname}</p>`
            : x `<p>User is not logged in.</p>`}
		`);
        }
    };
    XiomeExample = __decorate$5([
        mixinStyles(styles$8)
    ], XiomeExample);

    function integrateExampleComponents({ models, modals }) {
        const { exampleModel } = models;
        return {
            XiomeExample: (mixinSnapstateSubscriptions(exampleModel.subscribe)(mixinShare({
                modals,
                exampleModel,
            })(XiomeExample))),
        };
    }

    var votingUnitCss = i$3 `

[data-vote] {
	display: block;
	border: none;
	font: inherit;
	background: transparent;
	color: inherit;
}

[data-vote] {
	cursor: pointer;
	opacity: 0.6;
	user-select: none;
}

[data-vote="report"] {
	opacity: 0.4;
}

[data-vote]:not([disabled]):hover,
[data-vote]:not([disabled]):focus {
	opacity: 1;
}

[data-vote][disabled] {
	cursor: default;
}

[data-vote="like"][data-active] {
	color: var(--like-color);
}

[data-vote="report"][data-active] {
	color: var(--report-color);
}

[data-vote] > span {
	vertical-align: middle;
}

[data-vote] > span:nth-child(2) {
	font-size: 0.9em;
}

[data-vote] svg {
	width: 1.4em;
	height: 1.4em;
	position: relative;
	top: 0.1em;
}

`;

    var postCss = i$3 `

${votingUnitCss}

.post {
	display: grid;
	grid-template-rows: auto;
	grid-template-columns: auto 1fr auto;
	grid-template-areas:
		".... tophat    ...."
		"bar1 bubble    bar2"
		".... buttonbar ....";
}

a {
	opacity: 0.5;
	color: inherit;
	text-decoration: none;
}

a:hover, a:focus {
	opacity: 0.8;
	text-decoration: underline;
}

/*
** normal questions
*/

.post .tophat { grid-area: tophat }
.post .bar1 { grid-area: bar1 }
.post .bar2 { grid-area: bar2 }
.post .bubble { grid-area: bubble }
.post .buttonbar { grid-area: buttonbar }

.post .bar {
	padding: 0.5em;
	padding-top: 0.2em;
	display: flex;
	flex-direction: column;
}

.post .bar > * + * {
	margin-top: 0.1em;
}

.post .bar.bar2 {
	padding-top: 0;
}

.post .metabar {
	font-size: 0.7em;
	padding: 0 1.5em;
	opacity: 0.6;
}

.post .tophat xio-profile-card {
	width: 100%;
}

.post .bubble {
	flex: 1 1 auto;
	/* padding-left: 1em; */
}

.post .bubble xio-text-input {
	--xio-text-input-border-radius: 0 1em 1em 1em;
	--xio-text-input-pad: 0.5em;
}

.post .bubble .textbox p {
	border-radius: 0 1em 1em 1em;
	border: 1px solid;
	padding: 0.5em;
	min-height: 4em;
}

.post [part="bubble"] {
	white-space: pre-wrap;
}

/*
** question editor
*/

.intro {
	margin-bottom: 1em;
}

.intro .heading {
	font-size: 2em;
}

.post.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.post.editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

`;

    var styles$7 = i$3 `

/* * {
	outline: 1px solid #f002;
} */

:host {
	display: block;
	max-width: 42em;
	--like-color: var(--xiome-questions-like-color, cyan);
	--report-color: var(--xiome-questions-report-color, #f90);
}

.questions-moderation-panel {
	padding: 1em;
	border: 1px dotted;
	margin-bottom: 1em;
}

.questions-moderation-panel .purge-button {
	--xio-button-hover-color: red;
}

slot[name="empty"] {
	display: block;
	margin-top: 1em;
}

[part="questions-list"] {
	list-style: none;

}

[part="questions-list"] > li {
	margin-top: 2em;
}

${postCss}

[part="answers-list"] {
	list-style: none;
	margin-left: 3.4em;
	margin-right: 1em;
	margin-bottom: 1em;
}

[part="answers-list"] > li {
	
	margin-top: 1em;
}

@media (max-width: 420px) {
	[part="answers-list"] {
		margin-left: 1em;
		margin-right: 0;
	}
	[part="answers-list"] > li {
		border-left: 1px solid;
	}
}

/*
** question editor
*/

.editor .intro {
	margin-bottom: 1em;
}

.editor .intro .heading {
	font-size: 2em;
}

.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.question-editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

/*
** answer editor
*/

.answer-editor {
	border: 1px dashed;
	margin-left: 5em;
	margin-top: 1em;
}

.answer-editor .intro {
	padding: 1em;
}

`;

    const timeFactor = 1 * day;
    function sortQuestions(questions, myUserId) {
        const myQuestions = [];
        const otherQuestions = [];
        for (const question of questions) {
            const isMine = myUserId && question.authorUserId === myUserId;
            if (isMine)
                myQuestions.push(question);
            else
                otherQuestions.push(question);
        }
        return [
            ...myQuestions.sort(compareQuestions),
            ...otherQuestions.sort(compareQuestions),
        ];
    }
    function compareQuestions(a, b) {
        const promoteA = -1;
        const promoteB = 1;
        const scoreA = score(a);
        const scoreB = score(b);
        if (scoreA > scoreB)
            return promoteA;
        if (scoreB < scoreA)
            return promoteB;
        return 0;
    }
    function score({ timePosted, likes, reports }) {
        return timePosted
            + voteValue(likes, timeFactor)
            - voteValue(reports, 2 * timeFactor);
    }
    function voteValue(votes, timeFactor) {
        const voteWeight = votes === 0
            ? 0
            : 1 + Math.log10(votes);
        return voteWeight * timeFactor;
    }

    function renderBubble({ content, editable, timePosted, handleValueChange = () => { }, }) {
        const { date, time } = formatDate(timePosted);
        return x `
		<div class=bubble ?data-editable=${editable}>
			<div class=textbox>
				${editable
        ? x `
						<xio-text-input
							exportparts="textinput: bubble"
							textarea
							.validator=${validatePostContent}
							@valuechange=${handleValueChange}
						></xio-text-input>
					`
        : x `
						<p part=bubble>${content}</p>
					`}
			</div>
			<div class=metabar>
				<p>${`${date} ${time}`}</p>
			</div>
		</div>
	`;
    }

    function linkClick(handler) {
        return (event) => {
            event.preventDefault();
            handler();
        };
    }

    var PostType;
    (function (PostType) {
        PostType[PostType["Question"] = 0] = "Question";
        PostType[PostType["Answer"] = 1] = "Answer";
        PostType[PostType["Editor"] = 2] = "Editor";
    })(PostType || (PostType = {}));

    var heartSvg = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M6.736 4C4.657 4 2.5 5.88 2.5 8.514c0 3.107 2.324 5.96 4.861 8.12a29.66 29.66 0 0 0 4.566 3.175l.073.041l.073-.04c.271-.153.661-.38 1.13-.674c.94-.588 2.19-1.441 3.436-2.502c2.537-2.16 4.861-5.013 4.861-8.12C21.5 5.88 19.343 4 17.264 4c-2.106 0-3.801 1.389-4.553 3.643a.75.75 0 0 1-1.422 0C10.537 5.389 8.841 4 6.736 4zM12 20.703l.343.667a.75.75 0 0 1-.686 0l.343-.667zM1 8.513C1 5.053 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262a31.146 31.146 0 0 1-5.233 3.576l-.025.013l-.007.003l-.002.001l-.344-.666l-.343.667l-.003-.002l-.007-.003l-.025-.013A29.308 29.308 0 0 1 10 20.408a31.147 31.147 0 0 1-3.611-2.632C3.8 15.573 1 12.332 1 8.514z" fill="currentColor"/></svg>`;

    var heartFillSvg = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M14 20.408c-.492.308-.903.546-1.192.709c-.153.086-.308.17-.463.252h-.002a.75.75 0 0 1-.686 0a16.709 16.709 0 0 1-.465-.252a31.147 31.147 0 0 1-4.803-3.34C3.8 15.572 1 12.331 1 8.513C1 5.052 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262A31.146 31.146 0 0 1 14 20.408z" fill="currentColor"/></svg>`;

    function renderVotingUnit({ title, dataVote, voteCount, voteCasted, icon, castVote, }) {
        const handleClick = castVote
            ? voteCasted
                ? () => castVote(false)
                : () => castVote(true)
            : () => { };
        return x `
		<button
			tabindex=0
			data-vote="${dataVote}"
			?data-active=${voteCasted}
			?disabled=${!castVote}
			title="${title}"
			@click=${handleClick}>
				<span>${icon}</span>
				<span>${voteCount}</span>
		</button>
	`;
    }

    function renderLiking(liking) {
        return renderVotingUnit({
            dataVote: "like",
            icon: liking.liked
                ? heartFillSvg
                : heartSvg,
            title: liking.liked
                ? "unlike this post"
                : "like this post",
            voteCount: liking.likes,
            voteCasted: liking.liked,
            castVote: liking.castLikeVote
                ? status => liking.castLikeVote(status)
                : undefined,
        });
    }

    var warningFillSvg = b `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M8.686 2.852L2.127 14.777A1.5 1.5 0 0 0 3.441 17H16.56a1.5 1.5 0 0 0 1.314-2.223L11.314 2.852a1.5 1.5 0 0 0-2.628 0zM10 6.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4a.75.75 0 0 1 .75-.75zm.75 7a.75.75 0 1 1-1.5 0a.75.75 0 0 1 1.5 0z" fill="currentColor"/></g></svg>`;

    function renderReporting(reporting) {
        return renderVotingUnit({
            dataVote: "report",
            icon: reporting.reported
                ? warningFillSvg
                : warningSvg,
            title: reporting.reported
                ? "unreport this post"
                : "report this post",
            voteCount: reporting.reports,
            voteCasted: reporting.reported,
            castVote: reporting.castReportVote
                ? status => reporting.castReportVote(status)
                : undefined,
        });
    }

    function renderPostStructure({ postOptions, bar1, bubble, bar2, buttonBar }) {
        var _a;
        return x `
		<div class=post data-post-id="${(_a = postOptions.postId) !== null && _a !== void 0 ? _a : ""}">
			<div class=tophat>
				<xio-profile-card .user=${postOptions.author} show-details></xio-profile-card>
			</div>
			<div class="bar bar1">
				${bar1}
			</div>
			${bubble}
			<div class="bar bar2">
				${bar2}
			</div>
			${buttonBar
        ? x `
					<div class=buttonbar>
						${buttonBar}
					</div>
				`
        : null}
		</div>
	`;
    }

    function renderPost(options) {
        const { author, content, timePosted, ...specificOptions } = options;
        switch (specificOptions.type) {
            case PostType.Question: {
                const { liking, reporting, deletePost, toggleAnswerEditor } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: x `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: x `
					${renderReporting(reporting)}
					${deletePost
                    ? x `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
					${toggleAnswerEditor
                    ? x `<a href="#" @click=${linkClick(toggleAnswerEditor)}>answer</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Answer: {
                const { liking, reporting, deletePost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: x `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: x `
					${renderReporting(reporting)}
					${deletePost
                    ? x `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Editor: {
                const { isPostable, postButtonText, changeDraftContent, submitPost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: null,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: true,
                        handleValueChange: changeDraftContent,
                    }),
                    bar2: null,
                    buttonBar: x `
					<xio-button
						?disabled=${!isPostable}
						@click=${submitPost}
							>${postButtonText}</xio-button>
				`,
                });
            }
        }
    }

    function renderAnswer({ answer, questionId, modals, boardModel, canDeleteAnswer, }) {
        const permissions = boardModel.getPermissions();
        const canLike = permissions["like questions"];
        const canReport = permissions["report questions"];
        return renderPost({
            type: PostType.Answer,
            postId: answer.answerId,
            author: boardModel.getUser(answer.authorUserId),
            content: answer.content,
            timePosted: answer.timePosted,
            liking: {
                liked: answer.liked,
                likes: answer.likes,
                castLikeVote: canLike
                    ? like => boardModel.likeAnswer(questionId, answer.answerId, like)
                    : undefined,
            },
            reporting: {
                reported: answer.reported,
                reports: answer.reports,
                castReportVote: canReport
                    ? async (report) => {
                        const confirmed = report
                            ? await modals.confirm({
                                title: "Report answer?",
                                body: "Are you sure you want to submit a report against this answer?",
                                yes: { vibe: "negative", label: "Submit report" },
                                no: { vibe: "neutral", label: "Nevermind" },
                                focusNthElement: 2,
                            })
                            : true;
                        if (confirmed)
                            await boardModel.reportAnswer(questionId, answer.answerId, report);
                    }
                    : undefined,
            },
            deletePost: canDeleteAnswer(answer)
                ? async () => {
                    const confirmed = await modals.confirm({
                        title: "Delete answer?",
                        body: "Are you sure you want to delete this answer? This cannot be undone.",
                        yes: { vibe: "negative", label: "Delete answer" },
                        no: { vibe: "neutral", label: "Nevermind" },
                        focusNthElement: 2,
                    });
                    if (confirmed)
                        await boardModel.archiveAnswer(questionId, answer.answerId, true);
                }
                : undefined,
        });
    }

    function renderAnswerEditor({ now, boardModel, answerEditor, }) {
        const answerEditorState = answerEditor.state;
        return x `
		<div class="editor answer-editor">
			<div class=intro>
				<p class=heading>Post your answer</p>
			</div>
			${renderPost({
        author: boardModel.getAccess().user,
        type: PostType.Editor,
        timePosted: now,
        postButtonText: "post answer",
        content: answerEditorState.draftText,
        isPostable: answerEditorState.isPostable,
        submitPost: answerEditor.submitAnswer,
        changeDraftContent: answerEditor.actions.handleValueChange,
    })}
		</div>
	`;
    }

    function renderQuestion({ now, question, modals, boardModel, answerEditor, }) {
        const { questionId } = question;
        const access = boardModel.getAccess();
        const permissions = boardModel.getPermissions();
        const author = boardModel.getUser(question.authorUserId);
        const questionAuthorities = (() => {
            const isAuthor = (access && access.user)
                ? access.user.userId === author.userId
                : false;
            const canDelete = permissions["moderate questions"] || isAuthor;
            const canAnswer = permissions["answer questions"];
            const canLike = permissions["like questions"];
            const canReport = permissions["report questions"];
            return { canDelete, canAnswer, canLike, canReport };
        })();
        const handleDelete = async () => {
            const confirmed = await modals.confirm({
                title: "Delete question?",
                body: "Are you sure you want to delete this question? This cannot be undone.",
                yes: { vibe: "negative", label: "Delete question" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await boardModel.archiveQuestion(questionId, true);
        };
        const handleLike = (like) => {
            boardModel.likeQuestion(questionId, like);
        };
        const handleReport = async (report) => {
            const confirmed = report
                ? await modals.confirm({
                    title: "Report question?",
                    body: "Are you sure you want to submit a report against this question?",
                    yes: { vibe: "negative", label: "Submit report" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                })
                : true;
            if (confirmed)
                await boardModel.reportQuestion(questionId, report);
        };
        const answerEditorState = answerEditor.state;
        const canDeleteAnswer = (answer) => {
            var _a;
            const isAuthor = ((_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId) === answer.authorUserId;
            return permissions["moderate questions"] || isAuthor;
        };
        return x `
		${renderPost({
        type: PostType.Question,
        author,
        content: question.content,
        deletePost: questionAuthorities.canDelete
            ? handleDelete
            : undefined,
        liking: {
            liked: question.liked,
            likes: question.likes,
            castLikeVote: questionAuthorities.canLike
                ? handleLike
                : undefined,
        },
        postId: question.questionId,
        reporting: {
            reported: question.reported,
            reports: question.reports,
            castReportVote: questionAuthorities.canReport
                ? handleReport
                : undefined,
        },
        timePosted: question.timePosted,
        toggleAnswerEditor: questionAuthorities.canAnswer
            ? answerEditor.actions.toggleEditMode
            : undefined,
    })}
		${answerEditorState.editMode
        ? renderAnswerEditor({ now, boardModel, answerEditor })
        : null}
		${question.answers.length ? x `
			<ol part=answers-list>
				${question.answers.map(answer => x `
					<li part=answer data-answer-id="${answer.answerId}">
						${renderAnswer({
        answer,
        modals,
        questionId,
        boardModel,
        canDeleteAnswer,
    })}
					</li>
				`)}
			</ol>
		` : null}
	`;
    }

    function makeEditorState() {
        const state = snapstate({
            editMode: false,
            draftText: "",
            isPostable: false,
        });
        return {
            ...state,
            actions: {
                toggleEditMode() {
                    state.writable.editMode = !state.writable.editMode;
                },
                handleValueChange(event) {
                    state.writable.draftText = event.detail.value;
                    state.writable.isPostable = !!state.writable.draftText;
                },
            },
        };
    }

    function makeQuestionEditor({ requestUpdate, getTextInput, getBoardModel, }) {
        const state = makeEditorState();
        state.subscribe(requestUpdate);
        const resetEditor = () => {
            const input = getTextInput();
            input.text = "";
        };
        return {
            state: state.readable,
            actions: state.actions,
            subscribe: state.subscribe,
            getTextInput,
            submitQuestion: async () => {
                const { draftText } = state.readable;
                resetEditor();
                await getBoardModel().postQuestion({
                    content: draftText,
                });
            },
        };
    }

    function makeAnswerEditorGetter({ requestUpdate, getBoardModel, getTextInput, }) {
        const getRecord = strongRecordKeeper()(questionId => {
            const state = makeEditorState();
            state.subscribe(requestUpdate);
            const resetEditor = () => {
                const input = getTextInput(questionId);
                input.text = "";
            };
            return {
                state: state.readable,
                actions: state.actions,
                subscribe: state.subscribe,
                submitAnswer: async () => {
                    const { draftText } = state.readable;
                    resetEditor();
                    state.actions.toggleEditMode();
                    await getBoardModel().postAnswer(questionId, { content: draftText });
                },
            };
        });
        return (questionId) => getRecord(questionId);
    }

    function renderModerationPanel({ modals, board, archiveBoard }) {
        const handlePressPurgeButton = async () => {
            const confirmed = await modals.confirm({
                title: `Purge questions?`,
                body: `Are you sure you want to delete all the questions on the board "${board}"? This cannot be undone.`,
                yes: { vibe: "negative", label: "Purge all" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await archiveBoard();
        };
        return x `
		<div class=questions-moderation-panel>
			<h3>moderate questions board "${board}"</h3>
			<xio-button
				class=purge-button
				@press=${handlePressPurgeButton}>
					Purge all questions
			</xio-button>
		</div>
	`;
    }

    function renderQuestionEditor({ now, access, postingOp, questionEditor, }) {
        const author = access === null || access === void 0 ? void 0 : access.user;
        const editorState = questionEditor.state;
        return renderOp(postingOp, () => x `
		<div class="editor question-editor" part=question-editor>
			<div class=intro>
				<p class=heading>Post a new question</p>
			</div>
			${renderPost({
        type: PostType.Editor,
        author,
        content: editorState.draftText,
        isPostable: editorState.isPostable,
        timePosted: now,
        postButtonText: "post question",
        submitPost: questionEditor.submitQuestion,
        changeDraftContent: questionEditor.actions.handleValueChange,
    })}
		</div>
	`);
    }

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$3 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$7 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeQuestions_boardModel, _XiomeQuestions_questionEditor, _XiomeQuestions_getAnswerEditor, _XiomeQuestions_now;
    let XiomeQuestions = class XiomeQuestions extends mixinTicker(1000)(mixinRequireShare()(Component)) {
        constructor() {
            super(...arguments);
            _XiomeQuestions_boardModel.set(this, void 0);
            _XiomeQuestions_questionEditor.set(this, makeQuestionEditor({
                getBoardModel: () => __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: () => (this.shadowRoot.querySelector(".question-editor xio-text-input")),
            }));
            _XiomeQuestions_getAnswerEditor.set(this, makeAnswerEditorGetter({
                getBoardModel: () => __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: (questionId) => (this.shadowRoot.querySelector(`[part="questions-list"] li[data-question-id="${questionId}"] xio-text-input`)),
            }));
            _XiomeQuestions_now.set(this, Date.now());
            this.board = "default";
        }
        tick() {
            __classPrivateFieldSet$3(this, _XiomeQuestions_now, Date.now(), "f");
        }
        init() {
            __classPrivateFieldSet$3(this, _XiomeQuestions_boardModel, this.share.questionsModel.makeBoardModel(this.board), "f");
            __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").loadQuestions();
        }
        renderQuestionsBoard() {
            var _a;
            const now = __classPrivateFieldGet$7(this, _XiomeQuestions_now, "f");
            const { modals } = this.share;
            const questionEditor = __classPrivateFieldGet$7(this, _XiomeQuestions_questionEditor, "f");
            const { archiveBoard } = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f");
            const access = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getAccess();
            const board = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getBoardName();
            const boardOp = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getBoardOp();
            const postingOp = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getPostingOp();
            const permissions = __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getPermissions();
            const questions = sortQuestions(__classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getQuestions(), (_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId);
            return renderOp(boardOp, () => x `

			${permissions["moderate questions"]
            ? renderModerationPanel({ modals, board, archiveBoard })
            : null}

			${permissions["post questions"]
            ? renderQuestionEditor({ now, access, postingOp, questionEditor })
            : null}

			${questions.length > 0
            ? x `
					<ol part=questions-list>
						${questions.map(question => x `
							<li data-question-id="${question.questionId}">
								${renderQuestion({
                question,
                now: __classPrivateFieldGet$7(this, _XiomeQuestions_now, "f"),
                modals: this.share.modals,
                boardModel: __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f"),
                answerEditor: __classPrivateFieldGet$7(this, _XiomeQuestions_getAnswerEditor, "f").call(this, question.questionId),
            })}
							</li>
						`)}
					</ol>
				`
            : x `<slot name=empty><p>Be the first to post a question!</p></slot>`}
		`);
        }
        render() {
            return __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f") && __classPrivateFieldGet$7(this, _XiomeQuestions_boardModel, "f").getBoardOp()
                ? this.renderQuestionsBoard()
                : null;
        }
    };
    _XiomeQuestions_boardModel = new WeakMap();
    _XiomeQuestions_questionEditor = new WeakMap();
    _XiomeQuestions_getAnswerEditor = new WeakMap();
    _XiomeQuestions_now = new WeakMap();
    __decorate$4([
        e({ type: String, reflect: true })
    ], XiomeQuestions.prototype, "board", void 0);
    XiomeQuestions = __decorate$4([
        mixinStyles(styles$7)
    ], XiomeQuestions);

    function integrateQuestionsComponents({ models, modals }) {
        const { questionsModel } = models;
        return {
            XiomeQuestions: mixinSnapstateSubscriptions(questionsModel.subscribe)(mixinShare({
                modals,
                questionsModel,
            })(XiomeQuestions)),
        };
    }

    var styles$6 = i$3 `

.container {
	display: block;
	width: 100%;
	max-width: 36em;
	padding: 0.5em !important;
	border: 1px solid;
}

.results {
	margin-top: 0.5em;
}

.userlist {
	list-style: none;
}

.userlist > li {
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	background: #0002;
	padding: 0.5em;
	margin-top: 0.5em;
}

.userinfo {
	display: flex;
	flex-direction: row;
}

.userinfo xio-profile-card {
	flex: 1 1 auto;
}

.userinfo .controls {
	margin-left: 1em;
}

.userinfo .controls .edit[data-edit-mode] {
	color: lime;
	--xio-button-hover-color: lime;
}

.editwidget > div {
	margin-top: 1em;
}

.editwidget header + * {
	margin-top: 0.25em;
}

.editwidget header small {
	font-size: inherit;
	opacity: 0.6;
}

.editwidget ul {
	list-style: none;
}

.editwidget .allprivileges li {
	display: inline-block;
	font-size: 0.75em;
	padding: 0.1em 0.3em;
	margin: 0.2em 0.1em;
	border: 1px solid;
	border-radius: 1em;
}

`;

    function makeUserStates({ getUserResultsOp, rerender, }) {
        const states = new Map();
        function cleanupObsoleteStates() {
            const userIdsPendingRemovalFromState = [];
            const userResultsOp = getUserResultsOp();
            if (ops.ready(userResultsOp)) {
                const userResults = ops.value(userResultsOp);
                for (const stateUserId of states.keys()) {
                    const userIsGone = !userResults.find(({ user }) => user.userId === stateUserId);
                    if (userIsGone)
                        userIdsPendingRemovalFromState.push(stateUserId);
                }
            }
            for (const obsoleteUserId of userIdsPendingRemovalFromState)
                states.delete(obsoleteUserId);
        }
        function obtainStateForUser(userId) {
            let state = states.get(userId);
            if (!state) {
                const newState = {
                    editMode: false,
                    toggleEditMode() {
                        newState.editMode = !newState.editMode;
                        rerender();
                    },
                };
                state = newState;
                states.set(userId, state);
            }
            return state;
        }
        return {
            cleanupObsoleteStates,
            obtainStateForUser,
        };
    }

    function sortAssignableFirst(roles) {
        const assignable = roles.filter(role => role.assignable);
        const notAssignable = roles.filter(role => !role.assignable);
        return [...assignable, ...notAssignable];
    }
    function renderRoleButton(role, onClick) {
        return x `
		<xio-button
			?disabled=${!role.assignable}
			title=${role.roleId}
			data-role-id=${role.roleId}
			@press=${() => onClick(role)}>
				${role.label}
		</xio-button>
	`;
    }
    function renderPrivilegeUserHas(privilege) {
        return x `
		<li
			title="${privilege.privilegeId}"
			data-privilege-id="${privilege.privilegeId}">
				${privilege.label}
		</li>
	`;
    }
    function renderEditWidget({ permissions, administrativeModel, updateLocalUserResultsCache, userResult: { user: { userId }, roleIds }, blur, search, }) {
        const rolesAssigned = sortAssignableFirst(roleIds
            .map(id => permissions.roles.find(role => role.roleId === id))
            .filter(id => !!id));
        const rolesAvailable = sortAssignableFirst(permissions.roles
            .filter(role => !roleIds.includes(role.roleId))
            .filter(id => !!id));
        const privilegesUserHas = permissions.privileges
            .filter(privilege => {
            const rolesWithThisPrivilege = permissions.rolesHavePrivileges
                .filter(r => r.active && r.privilegeId === privilege.privilegeId);
            const rolesUserHas = rolesWithThisPrivilege
                .filter(r => roleIds.includes(r.roleId));
            return rolesUserHas.length > 0;
        });
        async function ifChangingSelfThenReauthorize() {
            var _a, _b;
            if (userId === ((_b = (_a = administrativeModel.getAccess()) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.userId))
                await administrativeModel.reauthorize();
        }
        async function clickToAssign({ roleId }) {
            await administrativeModel.assignRoleToUser({
                userId,
                roleId,
                isPublic: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
            });
            updateLocalUserResultsCache.assignRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        async function clickToRevoke({ roleId }) {
            await administrativeModel.revokeRoleFromUser({
                userId,
                roleId,
            });
            updateLocalUserResultsCache.revokeRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        return x `
		<div class=editwidget>
			<div class=available>
				<header>roles available <small>(click to assign)</small></header>
				<div>
					${rolesAvailable.map(role => renderRoleButton(role, clickToAssign))}
				</div>
			</div>
			<div class=assigned>
				<header>roles assigned <small>(click to revoke)</small></header>
				<div>
					${rolesAssigned.map(role => renderRoleButton(role, clickToRevoke))}
				</div>
			</div>
			<div class=allprivileges>
				<header>user has these privileges</header>
				<ul>
					${privilegesUserHas.map(renderPrivilegeUserHas)}
				</ul>
			</div>
		</div>
	`;
    }

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$6 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeManageUsers_search, _XiomeManageUsers_lastSearch;
    let XiomeManageUsers = class XiomeManageUsers extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.userResults = ops.ready([]);
            this.updateLocalUserResultsCache = {
                assignRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: [...result.roleIds, roleId] }
                        : result));
                },
                revokeRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: result.roleIds.filter(id => id !== roleId) }
                        : result));
                },
            };
            this.userStates = makeUserStates({
                getUserResultsOp: () => this.userResults,
                rerender: () => this.requestUpdate(),
            });
            _XiomeManageUsers_search.set(this, "");
            _XiomeManageUsers_lastSearch.set(this, "");
            this.commitSearch = async () => {
                const isRedundantSearch = __classPrivateFieldGet$6(this, _XiomeManageUsers_search, "f") === __classPrivateFieldGet$6(this, _XiomeManageUsers_lastSearch, "f");
                __classPrivateFieldSet$2(this, _XiomeManageUsers_lastSearch, __classPrivateFieldGet$6(this, _XiomeManageUsers_search, "f"), "f");
                if (!isRedundantSearch) {
                    this.userResults = ops.ready([]);
                    if (__classPrivateFieldGet$6(this, _XiomeManageUsers_search, "f"))
                        await ops.operation({
                            setOp: op => this.userResults = op,
                            promise: this.share.administrativeModel.searchUsers({
                                term: __classPrivateFieldGet$6(this, _XiomeManageUsers_search, "f"),
                            })
                        });
                }
                this.userStates.cleanupObsoleteStates();
            };
            this.commitSearchSoon = debounce(1000, this.commitSearch);
            this.searchChange = (event) => {
                var _a;
                __classPrivateFieldSet$2(this, _XiomeManageUsers_search, (_a = event.detail.value) !== null && _a !== void 0 ? _a : "", "f");
                this.commitSearchSoon();
            };
            this.enterPress = () => {
                this.commitSearch();
            };
        }
        init() {
            this.share.administrativeModel.initialize();
        }
        render() {
            const { permissionsOp } = this.share.administrativeModel.state;
            const allowed = this.share.administrativeModel
                .isAllowed("administrate user roles");
            const renderUser = (userResult) => {
                const { user } = userResult;
                const state = this.userStates.obtainStateForUser(user.userId);
                return x `
				<li>
					<div class=userinfo>
						<xio-profile-card
							.user=${user}
							show-details
						></xio-profile-card>
						<div class=controls>
							<xio-button
								class=edit
								?data-edit-mode=${state.editMode}
								@press=${state.toggleEditMode}>
									${wrenchSvg}
							</xio-button>
						</div>
					</div>
					${state.editMode
                ? renderOp(permissionsOp, permissions => renderEditWidget({
                    userResult,
                    permissions,
                    administrativeModel: this.share.administrativeModel,
                    updateLocalUserResultsCache: this.updateLocalUserResultsCache,
                    blur: () => {
                        const activeElement = document.activeElement;
                        if (activeElement)
                            activeElement.blur();
                    },
                    search: () => this.commitSearch(),
                }))
                : null}
				</li>
			`;
            };
            return x `
			<div class=container>

				${allowed ? x `
					<xio-text-input
						placeholder="search for users"
						.validator=${validateUserSearchTerm}
						@valuechange=${this.searchChange}
						@enterpress=${this.enterPress}
					></xio-text-input>

					<div class=results>
						${renderOp(this.userResults, results => results.length > 0
            ? x `
								<ol class=userlist>
									${results.map(renderUser)}
								</ol>
							`
            : x `
								<div class=noresults>
									no results
								</div>
							`)}
					</div>
				` : x `
					<p>you are not permitted to administrate user roles</p>
				`}

			</div>
		`;
        }
    };
    _XiomeManageUsers_search = new WeakMap();
    _XiomeManageUsers_lastSearch = new WeakMap();
    __decorate$3([
        e()
    ], XiomeManageUsers.prototype, "userResults", void 0);
    XiomeManageUsers = __decorate$3([
        mixinStyles(styles$6)
    ], XiomeManageUsers);

    function integrateAdministrativeComponents({ models, modals }) {
        const { administrativeModel } = models;
        return {
            XiomeManageUsers: (mixinSnapstateSubscriptions(administrativeModel.subscribe)(mixinShare({
                modals,
                administrativeModel,
            })(XiomeManageUsers))),
        };
    }

    var __classPrivateFieldGet$5 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeStoreConnect_instances, _XiomeStoreConnect_storeModel_get;
    class XiomeStoreConnect extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeStoreConnect_instances.add(this);
        }
        async init() {
            await __classPrivateFieldGet$5(this, _XiomeStoreConnect_instances, "a", _XiomeStoreConnect_storeModel_get).initialize();
        }
        renderStripeConnectControls() {
            const state = __classPrivateFieldGet$5(this, _XiomeStoreConnect_instances, "a", _XiomeStoreConnect_storeModel_get).snap.readable;
            const { connectStatusOp } = state.stripeConnect;
            const { connectDetailsOp } = state.stripeConnect;
            const { isOnboardingNeeded, isAllowedToOnboard, stripeAccountOnboarding, stripeLogin, } = __classPrivateFieldGet$5(this, _XiomeStoreConnect_instances, "a", _XiomeStoreConnect_storeModel_get).connect;
            const showOnboardingButton = (isOnboardingNeeded
                && isAllowedToOnboard);
            return renderOp(connectStatusOp, status => {
                const details = ops.value(connectDetailsOp);
                function renderLoginAndSetupButton() {
                    return x `
					<xio-button @press=${stripeLogin}>
						Login to Stripe
					</xio-button>
					${showOnboardingButton
                    ? x `
							<xio-button @press=${stripeAccountOnboarding}>
								Onboard Stripe Account
							</xio-button>
						`
                    : null}
				`;
                }
                function renderStripeAccountDetailsReadout() {
                    return x `
					<p>details:</p>
					<ul>
						<li>charges enabled: ${details.charges_enabled ? "true" : "false"}</li>
						<li>details submitted: ${details.details_submitted ? "true" : "false"}</li>
						<li>payouts enabled: ${details.payouts_enabled ? "true" : "false"}</li>
						<li>email: ${details.email}</li>
						<li>paused: ${details.paused}</li>
						<li>stripe account id: ${details.stripeAccountId}</li>
						<li>time linked: ${details.timeLinked}</li>
					</ul>
				`;
                }
                switch (status) {
                    case StripeConnectStatus.Unlinked: return x `
					<p>status: unlinked</p>
					<xio-button @press=${stripeAccountOnboarding}>
						Onboard Stripe Account
					</xio-button>
				`;
                    case StripeConnectStatus.Incomplete: return x `
					<p>status: incomplete</p>
					${renderStripeAccountDetailsReadout()}
					${renderLoginAndSetupButton()}
				`;
                    case StripeConnectStatus.Paused: return x `
					<p>status: paused</p>
					${renderStripeAccountDetailsReadout()}
					${renderLoginAndSetupButton()}
				`;
                    case StripeConnectStatus.Ready: {
                        return details
                            ? x `
							<p>status: ready</p>
							${renderStripeAccountDetailsReadout()}
							${renderLoginAndSetupButton()}
						`
                            : x `
							<p>status: loading</p>
						`;
                    }
                }
            });
        }
        render() {
            const { allowance } = __classPrivateFieldGet$5(this, _XiomeStoreConnect_instances, "a", _XiomeStoreConnect_storeModel_get);
            return x `
			<h3>Connect Stripe Account</h3>
			${allowance.connectStripeAccount
            ? this.renderStripeConnectControls()
            : x `<p>your account is not allowed to control the linked stripe account</p>`}
		`;
        }
    }
    _XiomeStoreConnect_instances = new WeakSet(), _XiomeStoreConnect_storeModel_get = function _XiomeStoreConnect_storeModel_get() {
        return this.share.storeModel;
    };

    var styles$5 = css `
:host {
	display: block;
	width: max-content;
	border-radius: 5px;
}

.billing_area {
	display: flex;
	gap: 1em;
	align-items: center;
}
`;

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeStoreBillingArea_instances, _XiomeStoreBillingArea_state_get, _XiomeStoreBillingArea_paymentMethod_get;
    let XiomeStoreBillingArea = class XiomeStoreBillingArea extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeStoreBillingArea_instances.add(this);
        }
        async init() {
            await this.share.storeModel.initialize();
        }
        render() {
            var _a;
            const { paymentMethodOp } = __classPrivateFieldGet$4(this, _XiomeStoreBillingArea_instances, "a", _XiomeStoreBillingArea_state_get).billing;
            const { connectStatusOp } = __classPrivateFieldGet$4(this, _XiomeStoreBillingArea_instances, "a", _XiomeStoreBillingArea_state_get).stripeConnect;
            const connectStatus = ops.value(connectStatusOp);
            const card = (_a = __classPrivateFieldGet$4(this, _XiomeStoreBillingArea_instances, "a", _XiomeStoreBillingArea_paymentMethod_get)) === null || _a === void 0 ? void 0 : _a.cardClues;
            return renderOp(ops.combine(paymentMethodOp, connectStatusOp), () => {
                return connectStatus !== StripeConnectStatus.Ready
                    ? null
                    : x `
					<div class="billing_area">
						<xiome-store-customer-portal>
							<slot>billing settings</slot>
						</xiome-store-customer-portal>
						${card
                    ? x `
								<div>
									<p>Payment Method</p>
									${card.brand} ${card.last4}
								</div>
							`
                    : null}
					</div>
				`;
            });
        }
    };
    _XiomeStoreBillingArea_instances = new WeakSet();
    _XiomeStoreBillingArea_state_get = function _XiomeStoreBillingArea_state_get() {
        return this.share.storeModel.snap.readable;
    };
    _XiomeStoreBillingArea_paymentMethod_get = function _XiomeStoreBillingArea_paymentMethod_get() {
        return ops.value(__classPrivateFieldGet$4(this, _XiomeStoreBillingArea_instances, "a", _XiomeStoreBillingArea_state_get).billing.paymentMethodOp);
    };
    XiomeStoreBillingArea = __decorate$2([
        mixinStyles(styles$5)
    ], XiomeStoreBillingArea);

    var styles$4 = css ``;

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeStoreCustomerPortal_instances, _XiomeStoreCustomerPortal_storeModel_get, _XiomeStoreCustomerPortal_openPopup, _XiomeStoreCustomerPortal_renderButton, _XiomeStoreCustomerPortal_renderMessageWhenStoreInactive, _XiomeStoreCustomerPortal_renderMessageWhenLoggedOut;
    let XiomeStoreCustomerPortal = class XiomeStoreCustomerPortal extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeStoreCustomerPortal_instances.add(this);
            this.op = ops.ready(undefined);
            _XiomeStoreCustomerPortal_openPopup.set(this, async () => {
                const { customerPortal } = __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "a", _XiomeStoreCustomerPortal_storeModel_get).billing;
                await ops.operation({
                    promise: customerPortal(),
                    setOp: newOp => this.op = newOp
                });
            });
        }
        async init() {
            await __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "a", _XiomeStoreCustomerPortal_storeModel_get).initialize();
        }
        render() {
            const { accessOp } = __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "a", _XiomeStoreCustomerPortal_storeModel_get).state.user;
            const { connectStatusOp } = __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "a", _XiomeStoreCustomerPortal_storeModel_get).state.stripeConnect;
            const combinedOp = ops.combine(accessOp, connectStatusOp, this.op);
            return x `
			${renderOp(combinedOp, () => {
            const { userLoggedIn, storeActive } = __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "a", _XiomeStoreCustomerPortal_storeModel_get).get.is;
            if (userLoggedIn) {
                if (storeActive)
                    return __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "m", _XiomeStoreCustomerPortal_renderButton).call(this);
                else
                    return __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "m", _XiomeStoreCustomerPortal_renderMessageWhenStoreInactive).call(this);
            }
            else
                return __classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_instances, "m", _XiomeStoreCustomerPortal_renderMessageWhenLoggedOut).call(this);
        })}
		`;
        }
    };
    _XiomeStoreCustomerPortal_openPopup = new WeakMap();
    _XiomeStoreCustomerPortal_instances = new WeakSet();
    _XiomeStoreCustomerPortal_storeModel_get = function _XiomeStoreCustomerPortal_storeModel_get() {
        return this.share.storeModel;
    };
    _XiomeStoreCustomerPortal_renderButton = function _XiomeStoreCustomerPortal_renderButton() {
        return x `
			<xio-button @press=${__classPrivateFieldGet$3(this, _XiomeStoreCustomerPortal_openPopup, "f")}>
				<slot>
					billing panel
				</slot>
			</xio-button>
		`;
    };
    _XiomeStoreCustomerPortal_renderMessageWhenStoreInactive = function _XiomeStoreCustomerPortal_renderMessageWhenStoreInactive() {
        return x `
			<slot name="not-ready"></slot>
		`;
    };
    _XiomeStoreCustomerPortal_renderMessageWhenLoggedOut = function _XiomeStoreCustomerPortal_renderMessageWhenLoggedOut() {
        return x `
			<slot name="logged-out"></slot>
		`;
    };
    __decorate$1([
        e()
    ], XiomeStoreCustomerPortal.prototype, "op", void 0);
    XiomeStoreCustomerPortal = __decorate$1([
        mixinStyles(styles$4)
    ], XiomeStoreCustomerPortal);

    const examplePricing = {
        currency: "usd",
        interval: "month",
        price: 0,
        stripePriceId: "FAKE_STRIPE_PRICE_ID",
    };
    const examples = {
        basics: {
            tier: {
                active: true,
                label: "Example Tier",
                pricing: [examplePricing],
                roleId: "FAKE_ROLE_ID",
                tierId: "FAKE_TIER_ID",
                time: Date.now(),
            },
            pricing: examplePricing,
        },
        context: {
            isSubscribedToThisTier: true,
            status: SubscriptionStatus.Active,
        },
    };

    const elem = (element) => {
        return {
            attr: {
                string: new Proxy({}, {
                    get(target, key) {
                        return element.getAttribute(key);
                    },
                    set(target, key, value) {
                        element.setAttribute(key, value.toString());
                        return true;
                    },
                }),
                boolean: new Proxy({}, {
                    get(target, key) {
                        return element.hasAttribute(key);
                    },
                    set(target, key, value) {
                        if (value)
                            element.setAttribute(key, "");
                        else
                            element.removeAttribute(key);
                        return true;
                    },
                }),
            }
        };
    };

    var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function component(options, renderHtml) {
        var _renderCount, _stateCount, _stateMap, _teardowns, _use, _a;
        return _a = class extends s {
                constructor() {
                    super(...arguments);
                    _renderCount.set(this, 0);
                    _stateCount.set(this, 0);
                    _stateMap.set(this, new Map());
                    _teardowns.set(this, new Set());
                    _use.set(this, {
                        element: this,
                        ...elem(this),
                        setup: initializer => {
                            if (__classPrivateFieldGet$2(this, _renderCount, "f") === 0) {
                                const teardown = initializer(this);
                                if (teardown)
                                    __classPrivateFieldGet$2(this, _teardowns, "f").add(teardown);
                            }
                        },
                        state: initial => {
                            const currentCount = __classPrivateFieldGet$2(this, _stateCount, "f");
                            __classPrivateFieldSet$1(this, _stateCount, __classPrivateFieldGet$2(this, _stateCount, "f") + 1, "f");
                            let currentValue;
                            const alreadySet = __classPrivateFieldGet$2(this, _stateMap, "f").has(currentCount);
                            if (alreadySet)
                                currentValue = __classPrivateFieldGet$2(this, _stateMap, "f").get(currentCount);
                            else {
                                currentValue = ((typeof initial === "function")
                                    ? initial(this)
                                    : initial);
                                __classPrivateFieldGet$2(this, _stateMap, "f").set(currentCount, currentValue);
                            }
                            return [
                                currentValue,
                                newValue => {
                                    __classPrivateFieldGet$2(this, _stateMap, "f").set(currentCount, newValue);
                                    this.requestUpdate();
                                },
                            ];
                        },
                    });
                }
                disconnectedCallback() {
                    for (const teardown of __classPrivateFieldGet$2(this, _teardowns, "f"))
                        teardown();
                    __classPrivateFieldGet$2(this, _teardowns, "f").clear();
                    __classPrivateFieldSet$1(this, _renderCount, 0, "f");
                    super.disconnectedCallback();
                }
                createRenderRoot() {
                    var _a;
                    if ((_a = options.shadow) !== null && _a !== void 0 ? _a : true)
                        return super.createRenderRoot();
                    else {
                        const style = document.createElement("style");
                        style.textContent = options.styles.cssText;
                        const root = document.createElement("div");
                        this.appendChild(style);
                        this.appendChild(root);
                        return root;
                    }
                }
                render() {
                    __classPrivateFieldSet$1(this, _stateCount, 0, "f");
                    const result = renderHtml(__classPrivateFieldGet$2(this, _use, "f"));
                    __classPrivateFieldSet$1(this, _renderCount, __classPrivateFieldGet$2(this, _renderCount, "f") + 1, "f");
                    return result;
                }
            },
            _renderCount = new WeakMap(),
            _stateCount = new WeakMap(),
            _stateMap = new WeakMap(),
            _teardowns = new WeakMap(),
            _use = new WeakMap(),
            _a.styles = options.styles,
            _a.properties = options.properties,
            _a;
    }

    function getStatusIcon(status) {
        switch (status) {
            case SubscriptionStatus.Unsubscribed:
                return undefined;
            case SubscriptionStatus.Active:
                return {
                    name: "check",
                    svg: checkSvg,
                };
            case SubscriptionStatus.Unpaid:
                return {
                    name: "warning",
                    svg: warningSvg,
                };
            case SubscriptionStatus.Cancelled:
                return {
                    name: "x",
                    svg: crossSvg,
                };
        }
    }

    var TierButton;
    (function (TierButton) {
        TierButton[TierButton["Buy"] = 0] = "Buy";
        TierButton[TierButton["Upgrade"] = 1] = "Upgrade";
        TierButton[TierButton["Downgrade"] = 2] = "Downgrade";
        TierButton[TierButton["Pay"] = 3] = "Pay";
        TierButton[TierButton["Cancel"] = 4] = "Cancel";
        TierButton[TierButton["Renew"] = 5] = "Renew";
    })(TierButton || (TierButton = {}));

    function getButtonLabel(button) {
        switch (button) {
            case TierButton.Buy:
                return "buy";
            case TierButton.Downgrade:
                return "downgrade";
            case TierButton.Upgrade:
                return "upgrade";
            case TierButton.Pay:
                return "pay";
            case TierButton.Cancel:
                return "cancel";
            case TierButton.Renew:
                return "renew";
        }
    }

    function getStatusLabel(status) {
        switch (status) {
            case SubscriptionStatus.Unsubscribed:
                return "unsubscribed";
            case SubscriptionStatus.Active:
                return "active";
            case SubscriptionStatus.Unpaid:
                return "unpaid";
            case SubscriptionStatus.Cancelled:
                return "cancelled";
        }
    }

    function dollarsToCents(dollars) {
        return dollars
            ? Math.round(parseFloat(dollars) * 100)
            : undefined;
    }
    function centsToDollars(cents) {
        return (cents / 100).toFixed(2);
    }

    var styles$3 = css `

:host {
	max-width: max-content;

	display: flex;
	flex-direction: column;
	justify-content: space-between;

	font: inherit;
	color: inherit;

	border: 1px solid;
	border-radius: 3px;
}

:host > div {
	padding: 0.5em;
}

[part~="tier_details"] {
	position: relative;

	text-align: center;
	flex-basis: 50%;

	[part~="tier_label"] {
		font-size: 1.5em;
	}

	[part~="tier_icon"] {
		position: absolute;
		top: -0.75em;
		right: -0.75em;
		width: 1.5em;
		height: 1.5em;
		padding: 0.2em;
		border-radius: 1em;
		background: currentColor;
		svg, [part~="tier_icon_content"] {
			width: 100%;
			height: 100%;
		}
		[part~="tier_icon_content"] { color: blue; }
		^[data-icon="check"] [part~="tier_icon_content"] { color: green; }
		^[data-icon="x"] [part~="tier_icon_content"] { color: red; }
		^[data-icon="warning"] [part~="tier_icon_content"] { color: orange; }
	}
}

[part~="tier_info"] {
	display: flex;
	flex-basis: 50%;
	align-items: center;
	flex-direction: column;
	justify-content: flex-end;
	gap: 0.2rem;
	background: #fff2;

	[part~="tier_button"] {
		padding: 0.3rem;
		border: 1px solid;
		border-radius: 5px;
		cursor: pointer;
		color: inherit;
		background: transparent;
		opacity: 0.7;

		^:is(:hover, :focus) {
			opacity: 1;
		}
	}
}

`;

    const XiomeStoreSubscriptionTier = component({
        styles: styles$3,
        shadow: true,
        properties: {
            basics: { type: Object },
            context: { type: Object },
            interactivity: { type: Object },
        },
    }, use => {
        const { basics: { tier, pricing } = examples.basics, context: { status, isSubscribedToThisTier } = examples.context, interactivity, } = use.element;
        const recurringInterval = (pricing === null || pricing === void 0 ? void 0 : pricing.interval) === "month"
            ? "monthly"
            : "yearly";
        const icon = getStatusIcon(status);
        const statusLabel = getStatusLabel(status);
        use.attr.string["data-tier"] = tier.tierId;
        use.attr.string["data-status"] = statusLabel;
        use.attr.boolean["data-subscribed"] = isSubscribedToThisTier;
        function renderButton() {
            const buttonLabel = getButtonLabel(interactivity.button);
            const buttonify = (part) => `${part} ${part}_${buttonLabel}`;
            return x `
			<button part="${buttonify("tier_button")}" @click=${interactivity.action}>
				${buttonLabel}
			</button>
		`;
        }
        return x `
		<div part=tier_details>
			${icon
        ? x `
						<div part=tier_icon data-icon="${icon.name}">
							<div part=tier_icon_content>
								${icon.svg}
							</div>
						</div>
					`
        : null}
			<h4 part=tier_label>${tier.label}</h4>
			<slot></slot>
			${pricing
        ? x `
					<xio-price-display
						unit-superscript
						value="${centsToDollars(pricing.price)}">
							${tier.label}
					</xio-price-display>
					<p>${recurringInterval}</p>
				`
        : x `
					<p style="color: red">price not set</p>
				`}
		</div>

		<div part=tier_info>
			${status !== SubscriptionStatus.Unsubscribed
        ? x `<span part=tier_status>${statusLabel}</span>`
        : undefined}
			${interactivity
        ? renderButton()
        : undefined}
		</div>
	`;
    });

    var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _TemplateSlots_instances, _TemplateSlots_parent, _TemplateSlots_templates, _TemplateSlots_parentObserver, _TemplateSlots_templateObservers, _TemplateSlots_onChange, _TemplateSlots_refresh;
    class TemplateSlots {
        constructor(parent, onChange = () => { }) {
            _TemplateSlots_instances.add(this);
            _TemplateSlots_parent.set(this, void 0);
            _TemplateSlots_templates.set(this, new Map());
            _TemplateSlots_parentObserver.set(this, void 0);
            _TemplateSlots_templateObservers.set(this, new Set);
            _TemplateSlots_onChange.set(this, () => { });
            __classPrivateFieldSet(this, _TemplateSlots_parent, parent, "f");
            __classPrivateFieldSet(this, _TemplateSlots_onChange, onChange, "f");
            __classPrivateFieldSet(this, _TemplateSlots_parentObserver, new MutationObserver(() => __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this)), "f");
            __classPrivateFieldGet$1(this, _TemplateSlots_parentObserver, "f").observe(parent, TemplateSlots.parentObservationOptions);
            __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this);
        }
        get(name) {
            const selector = name
                ? `:scope > template[slot="${name}"]`
                : `:scope > template:not([slot])`;
            const template = __classPrivateFieldGet$1(this, _TemplateSlots_parent, "f")
                .querySelector(selector);
            return template === null || template === void 0 ? void 0 : template.content.cloneNode(true);
        }
    }
    _TemplateSlots_parent = new WeakMap(), _TemplateSlots_templates = new WeakMap(), _TemplateSlots_parentObserver = new WeakMap(), _TemplateSlots_templateObservers = new WeakMap(), _TemplateSlots_onChange = new WeakMap(), _TemplateSlots_instances = new WeakSet(), _TemplateSlots_refresh = function _TemplateSlots_refresh() {
        var _a;
        for (const observer of __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f"))
            observer.disconnect();
        __classPrivateFieldGet$1(this, _TemplateSlots_templates, "f").clear();
        __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f").clear();
        const templates = Array.from(__classPrivateFieldGet$1(this, _TemplateSlots_parent, "f").querySelectorAll(":scope > template"));
        for (const template of templates) {
            const name = (_a = template.getAttribute("slot")) !== null && _a !== void 0 ? _a : undefined;
            __classPrivateFieldGet$1(this, _TemplateSlots_templates, "f").set(name, template);
            const deepObserver = new MutationObserver(__classPrivateFieldGet$1(this, _TemplateSlots_onChange, "f"));
            const attributeObserver = new MutationObserver(() => {
                __classPrivateFieldGet$1(this, _TemplateSlots_instances, "m", _TemplateSlots_refresh).call(this);
                __classPrivateFieldGet$1(this, _TemplateSlots_onChange, "f").call(this);
            });
            deepObserver.observe(template.content, TemplateSlots.templateDeepObserverationOptions);
            attributeObserver.observe(template, TemplateSlots.templateAttributeObserverationOptions);
            __classPrivateFieldGet$1(this, _TemplateSlots_templateObservers, "f").add(deepObserver);
        }
    };
    TemplateSlots.parentObservationOptions = {
        childList: true,
    };
    TemplateSlots.templateDeepObserverationOptions = {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true,
    };
    TemplateSlots.templateAttributeObserverationOptions = {
        attributes: true,
    };

    function getOngoingSubscriptions({ plans = [], mySubscriptionDetails = [], }) {
        return mySubscriptionDetails.map(subscription => {
            const plan = plans
                .find(p => p.planId === subscription.planId);
            const tier = plan
                .tiers
                .find(t => t.tierId === subscription.tierId);
            return {
                plan,
                tier,
                subscription,
                pricing: subscription.pricing,
            };
        });
    }

    function ascertainTierContext({ tier, plan, subscription, }) {
        var _a;
        const { tierId } = tier;
        const tierIndex = (plan
            .tiers
            .findIndex(t => t.tierId === tierId));
        const subscribedTierIndex = subscription && (plan
            .tiers
            .findIndex(t => t.tierId === subscription.tierId));
        const isSubscribedToThisTier = !!subscription && (tierIndex === subscribedTierIndex);
        const status = isSubscribedToThisTier
            ? ((_a = subscription === null || subscription === void 0 ? void 0 : subscription.status) !== null && _a !== void 0 ? _a : SubscriptionStatus.Unsubscribed)
            : SubscriptionStatus.Unsubscribed;
        const isAnotherTierInPlanUnpaid = (subscription
            && !isSubscribedToThisTier
            && subscription.status === SubscriptionStatus.Unpaid);
        return {
            subscription,
            status,
            tierIndex,
            subscribedTierIndex,
            isSubscribedToThisTier,
            isAnotherTierInPlanUnpaid,
        };
    }

    var styles$2 = css `

[data-card-list] {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 1em;
}

[data-card] {
	display: flex;
	flex-direction: column;
	gap: 0.5em;
}

`;

    function setupRerenderingOnSnapstateChanges(use, snap) {
        use.setup(() => snap.subscribe(() => use.element.requestUpdate()));
    }

    const XiomeStoreSubscriptionStatus = ({ storeModel }) => component({
        styles: styles$2,
        shadow: false,
        properties: {},
    }, use => {
        use.setup(() => { storeModel.initialize(); });
        setupRerenderingOnSnapstateChanges(use, storeModel.snap);
        const [slots] = use.state(() => new TemplateSlots(use.element, () => use.element.requestUpdate()));
        const { stripeConnect: { connectStatusOp }, subscriptions: { subscriptionPlansOp, mySubscriptionDetailsOp }, } = storeModel.state;
        const op = ops.combine(subscriptionPlansOp, mySubscriptionDetailsOp, connectStatusOp);
        const ongoingSubscriptions = getOngoingSubscriptions({
            plans: storeModel.get.subscriptions.plans,
            mySubscriptionDetails: storeModel.get.subscriptions.mySubscriptionDetails,
        });
        return renderOp(op, () => x `
		<div data-card-list>
			${ongoingSubscriptions.map(basics => x `
				<div data-card>
					<strong data-plan-label>${basics.plan.label}</strong>
					<xiome-store-subscription-tier
						.basics=${basics}
						.context=${ascertainTierContext(basics)}>
							${slots.get(basics.tier.tierId)}
					</xiome-store-subscription-tier>
				</div>
			`)}
		</div>
	`);
    });

    function preparePurchaseActions({ modals, button, tier, subscriptions, }) {
        const { stripePriceId } = tier.pricing[0];
        return {
            upgradeOrDowngrade: async () => {
                const label = button === TierButton.Upgrade
                    ? "upgrade"
                    : "downgrade";
                await modals.confirmAction({
                    title: button === TierButton.Upgrade
                        ? "upgrade subscription"
                        : "downgrade subscription",
                    message: `are you sure you want to ${label} your subscription to ${tier.label} for $${centsToDollars(tier.pricing[0].price)}/month?`,
                    loadingMessage: `switching to ${tier.label}`,
                    actionWhenConfirmed: () => subscriptions.purchase({
                        stripePriceId,
                        showLoadingSpinner: true,
                    }),
                });
            },
            buySubscriptionWithCheckoutPopup: async () => {
                await subscriptions.purchase({ stripePriceId });
            },
            buySubscriptionWithExistingPaymentMethod: async () => {
                await modals.confirmAction({
                    title: `buy subscription`,
                    message: `are you sure you want to buy ${tier.label} for $${centsToDollars(tier.pricing[0].price)}/month?`,
                    actionWhenConfirmed: () => subscriptions.purchase({ stripePriceId }),
                    loadingMessage: `purchasing subscription`
                });
            }
        };
    }

    function ascertainTierInteractivity({ basics: { tier }, context: { subscription, status, tierIndex, subscribedTierIndex, isAnotherTierInPlanUnpaid, }, modals, paymentMethod, billing, subscriptions, setOp, }) {
        const { tierId } = tier;
        switch (status) {
            case SubscriptionStatus.Unsubscribed: {
                const button = (!subscription
                    ? TierButton.Buy
                    : (subscribedTierIndex > tierIndex)
                        ? TierButton.Downgrade
                        : TierButton.Upgrade);
                if (isAnotherTierInPlanUnpaid)
                    return undefined;
                return {
                    button,
                    async action() {
                        const actions = preparePurchaseActions({
                            tier,
                            button,
                            modals,
                            subscriptions,
                        });
                        const scenario = determinePurchaseScenario({
                            hasDefaultPaymentMethod: !!paymentMethod,
                            hasExistingSubscription: !!subscription,
                        });
                        switch (scenario) {
                            case PurchaseScenario.Update:
                                return actions.upgradeOrDowngrade();
                            case PurchaseScenario.UsePaymentMethod:
                                return actions.buySubscriptionWithExistingPaymentMethod();
                            case PurchaseScenario.CheckoutPopup:
                                return ops.operation({
                                    setOp,
                                    promise: actions.buySubscriptionWithCheckoutPopup(),
                                });
                            default:
                                throw new Error("unknown purchase scenario");
                        }
                    },
                };
            }
            case SubscriptionStatus.Active: {
                return {
                    button: TierButton.Cancel,
                    action: async () => modals.confirmAction({
                        title: "Cancel subscription",
                        message: `are you sure you want to cancel your ${tier.label} subscription`,
                        loadingMessage: "cancelling subscription",
                        actionWhenConfirmed: () => subscriptions.cancel(tierId)
                    }),
                };
            }
            case SubscriptionStatus.Unpaid: {
                return {
                    button: TierButton.Pay,
                    action: async () => ops.operation({
                        promise: billing.customerPortal(),
                        setOp,
                    }),
                };
            }
            case SubscriptionStatus.Cancelled: {
                return {
                    button: TierButton.Renew,
                    action: async () => await modals.confirmAction({
                        title: "Renew subscription",
                        message: `are you sure you want to renew your ${tier.label} subscription for $${centsToDollars(tier.pricing[0].price)}/month?`,
                        loadingMessage: "renewing subscription",
                        actionWhenConfirmed: () => subscriptions.uncancel(tierId),
                    })
                };
            }
            default:
                throw new Error("unknown subscription status");
        }
    }

    function renderTier(params, plan, tier) {
        const { slots, modals, billing, paymentMethod, subscriptions, mySubscriptionDetails, setOp, } = params;
        const subscription = (mySubscriptionDetails
            .find(s => s.planId === plan.planId));
        const basics = {
            plan,
            tier,
            subscription,
            pricing: tier.pricing && tier.pricing[0],
        };
        const context = ascertainTierContext(basics);
        const interactivity = ascertainTierInteractivity({
            basics,
            context,
            modals,
            billing,
            subscriptions,
            paymentMethod,
            setOp,
        });
        const hasPricing = !!basics.pricing;
        return hasPricing
            ? x `
			<xiome-store-subscription-tier
				.basics=${basics}
				.context=${context}
				.interactivity=${interactivity}>
					${slots.get(tier.tierId)}
			</xiome-store-subscription-tier>
		`
            : null;
    }

    function renderPlan(params) {
        return (plan) => x `
		<li data-plan=${plan.planId} data-plan>
			<h3 data-plan-label>${plan.label}</h3>
			<div data-tiers>
				${plan.tiers
        .filter(tier => tier.active)
        .map(tier => renderTier(params, plan, tier))}
			</div>
		</li>
	`;
    }

    function planHasTiers() {
        return (plan) => plan.tiers.length > 0;
    }

    function planIsSpecified(specifiedPlans) {
        return (plan) => (specifiedPlans.length > 0
            ? specifiedPlans.includes(plan.planId)
            : true);
    }

    function planIsNotArchived() {
        return (plan) => !plan.archived;
    }

    function engageTemplateSlotting(use) {
        const [slots] = use.state(() => new TemplateSlots(use.element, () => use.element.requestUpdate()));
        return slots;
    }

    function planHasTiersThatAreActive() {
        return (plan) => plan
            .tiers
            .some(tier => tier.active);
    }

    function planHasAtLeastOneTierWithPricing() {
        return (plan) => plan
            .tiers
            .some(tier => !!tier.pricing);
    }

    var styles$1 = css `xiome-store-subscription-catalog {

:is(ol, ul) {
	list-style: none;
}

[data-plans] > li {
	margin-top: 1em;
}

[data-tiers] {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 0.5em;
	align-items: stretch;
	> span {
		display: block;
	}
	> * {
		max-width: 100%;
	}
}

[data-plan-label] {
	font-size: 1em;
	padding-bottom: 0.2em;
}

}`;

    function parseSpecifiedPlans(plans) {
        var _a, _b;
        return [
            ...(_b = (_a = (plans !== null && plans !== void 0 ? plans : "")) === null || _a === void 0 ? void 0 : _a.match(/(\w+)/g)) !== null && _b !== void 0 ? _b : []
        ];
    }

    const XiomeStoreSubscriptionCatalog = ({ modals, storeModel }) => component({
        styles: styles$1,
        shadow: false,
        properties: {
            "plans": { type: String },
        },
    }, use => {
        var _a;
        use.setup(() => { storeModel.initialize(); });
        setupRerenderingOnSnapstateChanges(use, storeModel.snap);
        const slots = engageTemplateSlotting(use);
        const [op, setOp] = use.state(ops.ready(undefined));
        const specifiedPlans = parseSpecifiedPlans(use.element.plans);
        const allPlans = ((_a = storeModel
            .get
            .subscriptions
            .plans) !== null && _a !== void 0 ? _a : []);
        const plans = allPlans
            .filter(planIsSpecified(specifiedPlans))
            .filter(planIsNotArchived())
            .filter(planHasTiers())
            .filter(planHasTiersThatAreActive())
            .filter(planHasAtLeastOneTierWithPricing());
        return renderOp(ops.combine(op, storeModel.state.subscriptions.subscriptionPlansOp), () => {
            var _a;
            return x `
			<ol data-plans>
				${plans.map(renderPlan({
            modals,
            slots,
            billing: storeModel.billing,
            mySubscriptionDetails: (_a = storeModel.get.subscriptions.mySubscriptionDetails) !== null && _a !== void 0 ? _a : [],
            paymentMethod: storeModel.get.billing.paymentMethod,
            subscriptions: storeModel.subscriptions,
            setOp,
        }))}
			</ol>
		`;
        });
    });

    /**
     * Select a single dom element
     */
    function select(selector, context = document) {
        return context.querySelector(selector);
    }

    function preparePricing(dollars) {
        return {
            currency: "usd",
            interval: "month",
            price: dollarsToCents(dollars),
        };
    }
    function isPricingChanged(pricing, draft) {
        for (const changed of [
            draft.price !== pricing.price,
            draft.currency !== pricing.currency,
            draft.interval !== pricing.interval,
        ]) {
            if (changed)
                return true;
        }
        return false;
    }
    function planningUi({ storeModel, componentSnap, getShadowRoot }) {
        const states = {
            store: storeModel.snap.readable,
            component: componentSnap.state,
        };
        const formGathering = {
            newPlan() {
                const shadow = getShadowRoot();
                const elements = {
                    planlabel: select(`.plandraft xio-text-input[data-field="planlabel"]`, shadow),
                    tierlabel: select(`.plandraft xio-text-input[data-field="tierlabel"]`, shadow),
                    tierprice: select(`.plandraft xio-price-input[data-field="tierprice"]`, shadow),
                };
                const draft = {
                    planLabel: elements.planlabel.value,
                    tier: {
                        label: elements.tierlabel.value,
                        pricing: preparePricing(elements.tierprice.value),
                    },
                };
                const problems = validateNewPlanDraft(draft);
                states.component.draftNewPlan.problems = problems;
                return { draft, problems };
            },
            newTier() {
                const shadow = getShadowRoot();
                const elements = {
                    label: select(`.tierdraft xio-text-input[data-field="tierlabel"]`, shadow),
                    price: select(`.tierdraft xio-price-input[data-field="tierprice"]`, shadow),
                };
                const draft = {
                    label: elements.label.value,
                    pricing: preparePricing(elements.price.value),
                };
                const problems = validateNewTierDraft(draft);
                states.component.draftNewTier.problems = problems;
                return { draft, problems };
            },
            editedPlan(plan) {
                const shadow = getShadowRoot();
                const elements = {
                    label: select(`.planediting [data-field="label"]`, shadow),
                    archived: select(`.planediting [data-field="archived"]`, shadow),
                };
                const draft = {
                    planId: plan.planId,
                    label: elements.label.value,
                    archived: elements.archived.checked,
                };
                const problems = validateEditPlanDraft(draft);
                const isChanged = draft.label !== plan.label ||
                    draft.archived !== plan.archived;
                states.component.editingPlanDraft.isChanged = isChanged;
                states.component.editingPlanDraft.problems = problems;
                return { draft, problems, isChanged };
            },
            editedTier(tier) {
                const initialPricing = tier.pricing ? tier.pricing[0] : {
                    stripePriceId: "",
                    currency: "usd",
                    interval: "month",
                    price: dollarsToCents(""),
                };
                const shadow = getShadowRoot();
                const elements = {
                    label: select(`.tierediting [data-field="label"]`, shadow),
                    active: select(`.tierediting [data-field="active"]`, shadow),
                    price: select(`.tierediting [data-field="price"]`, shadow),
                };
                const draft = {
                    tierId: tier.tierId,
                    label: elements.label.value,
                    active: elements.active.checked,
                    pricing: preparePricing(elements.price.value)
                };
                const problems = validateEditTierDraft(draft);
                const isChanged = draft.label !== tier.label ||
                    draft.active !== tier.active ||
                    isPricingChanged(initialPricing, draft.pricing);
                states.component.editingTierDraft.isChanged = isChanged;
                states.component.editingTierDraft.problems = problems;
                return { draft, problems, isChanged };
            },
        };
        const actions = {
            newPlan: {
                toggleDraftPanel() {
                    states.component.draftNewPlan = states.component.draftNewPlan
                        ? undefined
                        : { loading: false, problems: ["cannot be empty"] };
                },
                async submit() {
                    const { draft, problems } = formGathering.newPlan();
                    if (problems.length === 0) {
                        try {
                            states.component.draftNewPlan.loading = true;
                            await storeModel.subscriptions.addPlan(draft);
                        }
                        finally {
                            states.component.draftNewPlan = undefined;
                        }
                    }
                },
            },
            newTier: {
                toggleDraftPanel(planId) {
                    states.component.draftNewTier = states.component.draftNewTier
                        ? undefined
                        : { planId, loading: false, problems: [] };
                },
                async submit(planId) {
                    const { draft, problems } = formGathering.newTier();
                    if (problems.length === 0) {
                        try {
                            states.component.draftNewTier.loading = true;
                            await storeModel.subscriptions.addTier({
                                ...draft,
                                planId,
                            });
                        }
                        finally {
                            states.component.draftNewTier = undefined;
                        }
                    }
                },
            },
            planEditing: {
                handleEditButtonPress(plan) {
                    var _a;
                    const isEditing = ((_a = states.component.editingPlanDraft) === null || _a === void 0 ? void 0 : _a.planId)
                        === plan.planId;
                    states.component.editingPlanDraft = isEditing
                        ? undefined
                        : {
                            isChanged: false,
                            loading: false,
                            planId: plan.planId,
                            problems: [],
                        };
                },
                async submit(plan) {
                    const { draft, problems } = formGathering.editedPlan(plan);
                    if (problems.length === 0) {
                        try {
                            states.component.editingPlanDraft.loading = true;
                            await storeModel.subscriptions.editPlan(draft);
                        }
                        finally {
                            states.component.editingPlanDraft = undefined;
                        }
                    }
                },
            },
            tierEditing: {
                handleEditButtonPress(plan, tier) {
                    var _a;
                    const isEditing = ((_a = states.component.editingTierDraft) === null || _a === void 0 ? void 0 : _a.tierId)
                        === tier.tierId;
                    states.component.editingTierDraft = isEditing
                        ? undefined
                        : {
                            isChanged: false,
                            loading: false,
                            planId: plan.planId,
                            tierId: tier.tierId,
                            problems: [],
                        };
                },
                async submit(plan, tier) {
                    const { draft, problems } = formGathering.editedTier(tier);
                    if (problems.length === 0) {
                        try {
                            states.component.editingTierDraft.loading = true;
                            await storeModel.subscriptions.editTier({
                                planId: plan.planId,
                                tierId: tier.tierId,
                                label: draft.label,
                                active: draft.active,
                                pricing: draft.pricing,
                            });
                        }
                        finally {
                            states.component.editingTierDraft = undefined;
                        }
                    }
                }
            },
        };
        const handlers = {
            planDraft: {
                valuechange: formGathering.newPlan,
            },
            tierDraft: {
                valuechange: formGathering.newTier,
            },
        };
        function renderNewPlanPanel() {
            const { loading, problems } = states.component.draftNewPlan;
            return x `
			<div class=plandraft @valuechange=${handlers.planDraft.valuechange}>
				<xio-text-input
					data-field=planlabel
					?disabled=${loading}
					.validator=${validateLabel}>
						plan label</xio-text-input>
				<xio-text-input
					data-field=tierlabel
					?disabled=${loading}
					.validator=${validateLabel}>
						tier label</xio-text-input>
				<xio-price-input
					data-field=tierprice
					.validator=${validatePriceNumber}>
						tier price</xio-price-input>
				<xio-button
					?disabled=${loading || problems.length}
					@click=${actions.newPlan.submit}>
						Submit new plan</xio-button>
			</div>
		`;
        }
        function renderNewTierPanel(planId) {
            const { loading, problems } = states.component.draftNewTier;
            return x `
			<div class=tierdraft @valuechange=${handlers.tierDraft.valuechange}>
				<xio-text-input
					data-field=tierlabel
					?disabled=${loading}
					.validator=${validateLabel}>
						tier label</xio-text-input>
				<xio-price-input
					data-field=tierprice
					.validator=${validatePriceNumber}>
						tier price</xio-price-input>
				<xio-button
					?disabled=${loading || problems.length}
					@click=${() => actions.newTier.submit(planId)}>
						submit new tier</xio-button>
			</div>
		`;
        }
        function renderTier(plan, tier) {
            var _a, _b;
            const isEditing = ((_a = states.component.editingTierDraft) === null || _a === void 0 ? void 0 : _a.tierId) === tier.tierId;
            const loading = (_b = states.component.editingTierDraft) === null || _b === void 0 ? void 0 : _b.loading;
            const hasPricing = !!tier.pricing;
            const initialPrice = hasPricing ? centsToDollars(tier.pricing[0].price) : "";
            return x `
			<li data-tier="${tier.tierId}">
				<xio-button
					@press=${() => actions.tierEditing.handleEditButtonPress(plan, tier)}>
						edit tier
				</xio-button>
				<div class=tierdetails>
					${isEditing ? x `
						<div
							class=tierediting
							@valuechange=${() => formGathering.editedTier(tier)}
							@change=${() => formGathering.editedTier(tier)}>
							<xio-text-input
								data-field="label"
								?disabled=${loading}
								.text="${tier.label}"
								.validator=${validateLabel}>
									tier label
							</xio-text-input>
							<xio-price-input
								data-field="price"
								.validator=${validatePriceNumber}
								initial-value=${initialPrice}>
									Price</xio-price-input>
							<label>
								active:
								<input
									type=checkbox
									data-field="active"
									?disabled=${loading}
									?checked=${tier.active} />
							</label>
							${states.component.editingTierDraft.isChanged
            ? x `
									<xio-button
										?disabled=${loading || !!states.component.editingTierDraft.problems.length}
										@press=${() => actions.tierEditing.submit(plan, tier)}>
										save tier
									</xio-button>
								`
            : null}
						</div>
					` : x `
						<p class=label>tier label: ${tier.label}</p>
						${hasPricing
            ? x `<p>price: $${centsToDollars(tier.pricing[0].price)}</p>`
            : x `<p style="color: red">price not set</p>`}
						<p>active: ${tier.active ? "true" : "false"}</p>
					`}
				</div>
				<p>tier id: <xio-id id="${tier.tierId}"></xio-id></p>
				<p>role id: <xio-id id="${tier.roleId}"></xio-id></p>
				<p>created: ${formatDate(tier.time).full}</p>
			</li>
		`;
        }
        function renderPlan(plan, index) {
            var _a, _b, _c;
            const isEditing = ((_a = states.component.editingPlanDraft) === null || _a === void 0 ? void 0 : _a.planId) === plan.planId;
            const loading = (_b = states.component.editingPlanDraft) === null || _b === void 0 ? void 0 : _b.loading;
            const activeTiers = [];
            const inactiveTiers = [];
            for (const tier of plan.tiers) {
                if (tier.active)
                    activeTiers.push(tier);
                else
                    inactiveTiers.push(tier);
            }
            return x `
			<li data-plan="${plan.planId}">
				<xio-button
					class=editplan
					@press=${() => actions.planEditing.handleEditButtonPress(plan)}>
						edit plan
				</xio-button>
				<div class=plandetails>
					${isEditing ? x `
						<div class=planediting
							@change=${() => formGathering.editedPlan(plan)}
							@valuechange=${() => formGathering.editedPlan(plan)}>
								<xio-text-input
									data-field="label"
									?disabled=${loading}
									.text="${plan.label}"
									.validator=${validateLabel}>
										plan label
								</xio-text-input>
								<label>
									archived:
									<input
										type=checkbox
										data-field="archived"
										?disabled=${loading}
										?checked=${plan.archived} />
								</label>
								${states.component.editingPlanDraft.isChanged
            ? x `
										<xio-button
											?disabled=${loading || !!states.component.editingPlanDraft.problems.length}
											@press=${() => actions.planEditing.submit(plan)}>
												save plan
										</xio-button>
									`
            : null}
						</div>
					` : x `
						<p class=label>plan label: ${plan.label}</p>
						<p>archived: ${plan.archived ? "true" : "false"}</p>
					`}
				</div>
				<p>plan id: <xio-id id="${plan.planId}"></xio-id></p>
				<p>created: ${formatDate(plan.time).full}</p>
				<h3 class=tiersheading>tiers</h3>
				<xio-button class=addtier @click=${() => actions.newTier.toggleDraftPanel(plan.planId)}>
					+ add tier
				</xio-button>
				${((_c = states.component.draftNewTier) === null || _c === void 0 ? void 0 : _c.planId) === plan.planId
            ? renderNewTierPanel(plan.planId)
            : null}
				<ol>
					${activeTiers.map(tier => renderTier(plan, tier))}
				</ol>
				${inactiveTiers.length
            ? x `
						<details>
							<summary>inactive tiers</summary>
							<ol>
								${inactiveTiers.map(tier => renderTier(plan, tier))}
							</ol>
						</details>
					`
            : null}
			</li>
		`;
        }
        function renderPlanning() {
            const { subscriptionPlansOp } = states.store.subscriptions;
            return renderOp(subscriptionPlansOp, plans => {
                const availablePlans = [];
                const archivedPlans = [];
                for (const plan of plans) {
                    if (plan.archived)
                        archivedPlans.push(plan);
                    else
                        availablePlans.push(plan);
                }
                return x `
				<xio-button class=addplan @click=${actions.newPlan.toggleDraftPanel}>
					+ add plan
				</xio-button>
				${states.component.draftNewPlan
                ? renderNewPlanPanel()
                : null}
				<ol>
					${availablePlans.map(renderPlan)}
				</ol>
				${archivedPlans.length
                ? x `
						<details>
							<summary>archived plans</summary>
							<ol>
								${archivedPlans.map(renderPlan)}
							</ol>
						</details>
					`
                : null}
			`;
            });
        }
        return {
            renderPlanning,
        };
    }

    function makePlanningComponentSnap() {
        return snapstate({
            draftNewPlan: undefined,
            draftNewTier: undefined,
            editingPlanDraft: undefined,
            editingTierDraft: undefined,
        });
    }

    var styles = css `

ul, ol {
	list-style: none;
}

.plandraft {
	> * {
		display: block;
		margin-top: 0.5em;
	}
}

[data-plan] {
	border: 1px solid;
	padding: 1em;
	margin-top: 1em;

	.editplan {
		margin-bottom: 1em;
	}

	.plandetails {
		margin-bottom: 1em;
	}

	.planediting > * + * {
		display: block;
		margin-top: 0.5em;
	}

	details {
		border: 1px dashed;
		padding: 0.5em;
		margin-top: 0.5em;
	}
	
	summary {
		font-size: 1.2em;
	}
	
	.tiersheading {
		margin-top: 1em;
	}
	
	.addtier {
		margin-top: 1em;
	}
	
	.tierdraft > * {
		display: block;
		margin-top: 0.5em;
	}
}

[data-tier] {
	border: 1px solid;
	padding: 1em;
	margin-top: 1em;

	.tierdetails {
		margin: 1em 0;
	}

	.tierediting > * {
		display: block;
		margin-top: 0.5em;
	}
}

[data-field="label"], .label {
	font-weight: bold;
}

`;

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeStoreSubscriptionPlanning_instances, _XiomeStoreSubscriptionPlanning_componentSnap, _XiomeStoreSubscriptionPlanning_storeModel_get, _XiomeStoreSubscriptionPlanning_planningUi;
    let XiomeStoreSubscriptionPlanning = class XiomeStoreSubscriptionPlanning extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeStoreSubscriptionPlanning_instances.add(this);
            _XiomeStoreSubscriptionPlanning_componentSnap.set(this, makePlanningComponentSnap());
            _XiomeStoreSubscriptionPlanning_planningUi.set(this, planningUi({
                storeModel: __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_instances, "a", _XiomeStoreSubscriptionPlanning_storeModel_get),
                componentSnap: __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_componentSnap, "f"),
                getShadowRoot: () => this.shadowRoot,
            }));
        }
        async init() {
            this.addSubscription(() => __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_componentSnap, "f")
                .subscribe(() => this.requestUpdate()));
            await __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_instances, "a", _XiomeStoreSubscriptionPlanning_storeModel_get)
                .initialize();
        }
        render() {
            const { snap, allowance } = __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_instances, "a", _XiomeStoreSubscriptionPlanning_storeModel_get);
            const state = snap.readable;
            const connectStatus = ops.value(state.stripeConnect.connectStatusOp);
            return x `
			${connectStatus === StripeConnectStatus.Ready
            ? allowance.manageStore
                ? __classPrivateFieldGet(this, _XiomeStoreSubscriptionPlanning_planningUi, "f").renderPlanning()
                : x `<p>your account does not have permissions to manage the store</p>`
            : x `<p>store is not active</p>`}
		`;
        }
    };
    _XiomeStoreSubscriptionPlanning_componentSnap = new WeakMap();
    _XiomeStoreSubscriptionPlanning_planningUi = new WeakMap();
    _XiomeStoreSubscriptionPlanning_instances = new WeakSet();
    _XiomeStoreSubscriptionPlanning_storeModel_get = function _XiomeStoreSubscriptionPlanning_storeModel_get() { return this.share.storeModel; };
    XiomeStoreSubscriptionPlanning = __decorate([
        mixinStyles(styles)
    ], XiomeStoreSubscriptionPlanning);

    function integrateStoreComponents({ models, modals }) {
        const { storeModel } = models;
        return {
            XiomeStoreConnect: (mixinSnapstateSubscriptions(storeModel.snap.subscribe)(mixinShare({
                modals,
                storeModel,
            })(XiomeStoreConnect))),
            XiomeStoreSubscriptionPlanning: (mixinSnapstateSubscriptions(storeModel.snap.subscribe)(mixinShare({
                modals,
                storeModel,
            })(XiomeStoreSubscriptionPlanning))),
            XiomeStoreSubscriptionTier,
            XiomeStoreSubscriptionCatalog: XiomeStoreSubscriptionCatalog({
                modals,
                storeModel,
            }),
            XiomeStoreCustomerPortal: (mixinSnapstateSubscriptions(storeModel.snap.subscribe)(mixinShare({
                storeModel,
            })(XiomeStoreCustomerPortal))),
            XiomeStoreSubscriptionStatus: XiomeStoreSubscriptionStatus({
                storeModel,
            }),
            XiomeStoreBillingArea: (mixinSnapstateSubscriptions(storeModel.snap.subscribe)(mixinShare({
                storeModel,
            })(XiomeStoreBillingArea))),
        };
    }

    function getComponents(options) {
        return themeComponents(theme, {
            ...integrateXioComponents(),
            ...integrateExampleComponents(options),
            ...integrateAuthComponents(options),
            ...integrateQuestionsComponents(options),
            ...integrateAdministrativeComponents(options),
            ...integrateVideoComponents(options),
            ...integrateChatComponents(options),
            ...integrateNotesComponents(options),
            ...integrateStoreComponents(options),
        });
    }

    function trapFocus(element, focusNth) {
        const blueprint = `
		[focusable]:not([disabled])
		[tabindex]:not([disabled])
		a[href]:not([disabled])
		button:not([disabled])
		textarea:not([disabled])
		input[type="text"]:not([disabled])
		input[type="radio"]:not([disabled])
		input[type="checkbox"]:not([disabled])
		select:not([disabled])
	`;
        const selector = blueprint
            .split("\n")
            .map(l => l.trim())
            .filter(l => l.length)
            .join(", ");
        const focusable = Array.from(element.querySelectorAll(selector));
        if (focusable.length === 0)
            throw new Error("cannot trap focus: no focusable element");
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        const nthFocusable = focusable[focusNth - 1];
        setTimeout(() => nthFocusable.focus(), 0);
        element.onkeydown = event => {
            if (event.key === "Tab") {
                if (event.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        event.preventDefault();
                    }
                }
                else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        event.preventDefault();
                    }
                }
            }
        };
    }

    function preparePrompt(popup) {
        return async ({ title, input, body = null, yes = { label: "okay", vibe: "positive" }, no = { label: "nevermind", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansCancel = true, }) => new Promise(resolve => {
            var _a;
            const xioTextInput = document.createElement("xio-text-input");
            xioTextInput.textarea = (_a = input.textarea) !== null && _a !== void 0 ? _a : false;
            xioTextInput.parser = input.parser;
            xioTextInput.validator = input.validator;
            xioTextInput.textContent = input.label;
            function hasProblems() {
                void xioTextInput.value;
                return xioTextInput.problems.length !== 0;
            }
            function getCurrentValue() {
                return hasProblems()
                    ? undefined
                    : { value: xioTextInput.value };
            }
            function prepareFinishingMoves(controls) {
                return {
                    yes: () => {
                        const currentValue = getCurrentValue();
                        if (!hasProblems()) {
                            controls.close();
                            resolve(currentValue);
                        }
                    },
                    no: () => {
                        controls.close();
                        resolve(undefined);
                    },
                };
            }
            const { controls, modal } = popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansCancel
                    ? controls => {
                        controls.close();
                        resolve(undefined);
                    }
                    : () => { },
                renderContent: controls => {
                    const finish = prepareFinishingMoves(controls);
                    return x `
					<div data-confirm>
						${typeof title == "string" ? x `<h2>${title}</h2>` : title}
						${typeof body == "string" ? x `<p>${body}</p>` : body}
						${xioTextInput}
						<div data-buttons>
							<xio-button
								data-button=yes
								data-vibe=${yes.vibe}
								?disabled=${hasProblems()}
								@press=${finish.yes}>
									${yes.label}
							</xio-button>
							<xio-button
								data-button=no
								data-vibe=${no.vibe}
								@press=${finish.no}>
									${no.label}
							</xio-button>
						</div>
					</div>
				`;
                },
            });
            const finish = prepareFinishingMoves(controls);
            xioTextInput.onvaluechange = () => controls.rerender();
            xioTextInput.onenterpress = () => finish.yes();
            modal.addEventListener("keyup", ({ key }) => {
                if (key === "Escape")
                    finish.no();
            });
        });
    }

    function prepareConfirm(popup) {
        return async ({ title, body = null, yes = { label: "yes", vibe: "positive" }, no = { label: "no", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => new Promise(resolve => {
            popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansNo
                    ? controls => {
                        controls.close();
                        resolve(false);
                    }
                    : () => { },
                renderContent: controls => {
                    const onYes = () => {
                        controls.close();
                        resolve(true);
                    };
                    const onNo = () => {
                        controls.close();
                        resolve(false);
                    };
                    return x `
					<div data-confirm>
						${typeof title == "string" ? x `<h2>${title}</h2>` : title}
						${typeof body == "string" ? x `<p>${body}</p>` : body}
						<div data-buttons>
							<xio-button
								focusable
								data-button=yes
								data-vibe="${yes.vibe}"
								@press=${onYes}>
									${yes.label}
							</xio-button>
							${no ? x `
								<xio-button
									focusable
									data-button=no
									data-vibe="${no.vibe}"
									@press=${onNo}>
										${no.label}
								</xio-button>
							` : null}
						</div>
					</div>
				`;
                },
            });
        });
    }

    var modalSystemStyles = i$3 `

*:focus {
	outline: var(--focus-outline);
}

[data-modal-system] {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	display: block;
}

[data-modal-system] [data-blanket] {
	z-index: 101;
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	display: block;
	background: #0008;
	backdrop-filter: blur(10px);
}

[data-modal-system] [data-plate] {
	z-index: 102;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;

	width: 96%;
	max-width: 32em;
	min-height: 1em;
	margin: 2em auto;

	background: linear-gradient(to bottom right, #fff, #ccc);
	color: #444;
}

[data-modal-system] [data-plate] h2 {
	padding: 0 1rem;
	margin: 1rem auto;
}

[data-modal-system] [data-content]:focus {
	outline: unset;
}

[data-modal-system] [data-confirm] {
	padding: 0 1rem;
	margin: 1rem auto;
}

[data-modal-system] [data-buttons] {
	margin-top: 1rem;
	text-align: right;
}

[data-modal-system] [data-button] {
	--xio-button-hover-color: white;
	--xio-button-hover-background: #666;
}

[data-modal-system] [data-vibe=positive] {
	color: green;
	--xio-button-hover-color: white;
	--xio-button-hover-background: green;
}

[data-modal-system] [data-vibe=negative] {
	color: #a00;
	--xio-button-hover-color: white;
	--xio-button-hover-background: #a00;
}

`;

    function prepareModalSystemRendering(listModals) {
        const style = document.createElement("style");
        B(modalSystemStyles, style);
        const element = document.createElement("div");
        element.setAttribute("data-modal-system", "");
        function rerender() {
            B(x `
			${style}
			${listModals().map(modal => modal.render())}
		`, element);
        }
        return { element, rerender };
    }

    function prepareAlert(confirm) {
        return async ({ title, body = null, button = { label: "ok", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => {
            await confirm({
                title,
                body,
                blanketClickMeansNo,
                yes: button,
                no: null,
            });
        };
    }

    function prepareConfirmAction(popup) {
        return async ({ title, message, loadingMessage, cancelButtonLabel = "no", confirmButtonLabel = "yes", actionWhenConfirmed, }) => {
            let op = ops.ready(undefined);
            function setOp(newOp) {
                op = newOp;
                modal.controls.rerender();
            }
            const modal = popup({
                focusNthElement: 1,
                renderContent: (controls) => {
                    const isError = ops.isError(op);
                    return x `
					<h2>${title}</h2>
					${renderOp(op, () => x `
							<div data-confirm>
								${message}
								<div data-buttons>
									<xio-button
										focusable
										data-button=yes
										data-vibe="positive"
										@press=${async () => {
                    await ops.operation({
                        promise: actionWhenConfirmed(),
                        setOp,
                    });
                    controls.close();
                }}>
											${confirmButtonLabel}
									</xio-button>
									<xio-button
										focusable
										data-button=no
										data-vibe="neutral"
										@press=${controls.close}>
											${cancelButtonLabel}
									</xio-button>
								</div>
							</div>
						`, null, { loadingMessage })}
					${isError
                    ? x `
						<div data-buttons>
							<xio-button
								focusable
								data-button=no
								data-vibe="neutral"
								@press=${controls.close}>
									ok
							</xio-button>
						</div>
						`
                    : null}
				`;
                },
                onBlanketClick: (controls) => {
                    const isLoading = ops.isLoading(op);
                    if (!isLoading)
                        controls.close();
                }
            });
        };
    }
    // function confirmAction({
    // 		title,
    // 		message,
    // 		cancelButtonLabel,
    // 		confirmButtonLabel,
    // 		actionWhenConfirmed,
    // 	}: {
    // 		actionWhenConfirmed: () => void
    // 		message: string
    // 		title: string
    // 		confirmButtonLabel: string
    // 		cancelButtonLabel: string
    // 	}) {
    // 	}

    function setupModalSystem() {
        let count = 0;
        const modals = new Map();
        const listModals = () => Array.from(modals.values());
        const { rerender, element } = prepareModalSystemRendering(listModals);
        function popup({ focusNthElement, renderContent, onBlanketClick }) {
            var _a, _b, _c;
            const id = count++;
            const controls = {
                rerender,
                close: () => {
                    modals.delete(id);
                    rerender();
                },
            };
            const top = (_c = (_b = (_a = window.pageYOffset) !== null && _a !== void 0 ? _a : document.documentElement.scrollTop) !== null && _b !== void 0 ? _b : document.body.scrollTop) !== null && _c !== void 0 ? _c : 0;
            const handleBlanketClick = () => onBlanketClick(controls);
            modals.set(id, {
                render() {
                    return x `
					<div data-modal="${id}">
						<div data-blanket @click=${handleBlanketClick}></div>
						<div data-plate style="top: ${top}px">
							${renderContent(controls)}
						</div>
					</div>
				`;
                },
            });
            rerender();
            const modal = element.querySelector(`[data-modal="${id}"]`);
            trapFocus(modal, focusNthElement);
            return { controls, modal };
        }
        const confirm = prepareConfirm(popup);
        const confirmAction = prepareConfirmAction(popup);
        return {
            modalsElement: element,
            modals: {
                popup,
                confirm,
                confirmAction,
                alert: prepareAlert(confirm),
                prompt: preparePrompt(popup),
            },
        };
    }

    function parseQuery(query = location.search) {
        const parsed = {};
        query = query.startsWith("?") ? query.slice(1) : query;
        query = query.startsWith("#") ? query.slice(1) : query;
        const parts = query.split("&");
        for (const part of parts) {
            const [key, ...rest] = part.split("=");
            const value = rest.join("=");
            parsed[decodeURIComponent(key)] = decodeURIComponent(value);
        }
        return parsed;
    }

    async function loginWithLinkTokenOrUseExistingLogin({ link, accessModel, onDone, onError, }) {
        const { hash } = new URL(link);
        const { login } = parseQuery(hash);
        if (login) {
            try {
                await accessModel.login(login);
            }
            catch (error) {
                onError(error);
            }
            onDone();
        }
        else
            try {
                await accessModel.useExistingLogin();
            }
            catch (error) {
                console.error("error with xiome login:", error);
            }
    }

    async function assembleAndInitializeFrontend({ appId, storage, authMediator, remote, stripePopups, chatConnect, }) {
        const { modals, modalsElement } = setupModalSystem();
        const models = await assembleModels({
            appId,
            remote,
            storage,
            authMediator,
            stripePopups,
            chatConnect,
        });
        const components = getComponents({ models, modals });
        await loginWithLinkTokenOrUseExistingLogin({
            accessModel: models.accessModel,
            link: window.location.toString(),
            onError: error => {
                if (error instanceof AccessLoginExpiredError)
                    modals.alert({
                        title: "expired login link",
                        body: "this login link has expired, please try again",
                    });
                else
                    modals.alert({
                        title: "invalid login link",
                        body: "something is wrong with this login link, please try again",
                    });
            },
            onDone: () => {
                window.location.hash = "";
            },
        });
        return { appId, components, models, modals, modalsElement };
    }

    async function assembleXiomeMock(mockConfig) {
        const connection = await mockConnect(mockConfig);
        connection.setMockLatency({ min: 200, max: 800 });
        const frontend = await assembleAndInitializeFrontend(connection);
        applyMockHacks({
            frontend,
            connection: connection,
        });
        return { ...connection, ...frontend };
    }

    function configReading(selector) {
        const element = document.querySelector(selector);
        if (!element)
            throw new Error(`${selector} is required`);
        return {
            attr(key) {
                var _a;
                return (_a = element.getAttribute(key)) !== null && _a !== void 0 ? _a : undefined;
            },
        };
    }

    function readXiomeMock() {
        var _a;
        const { attr } = configReading("xiome-mock");
        const rawMode = attr("mode");
        return {
            root: (_a = attr("root")) !== null && _a !== void 0 ? _a : "",
            mode: (rawMode === undefined
                ? undefined
                : rawMode === "platform"
                    ? "platform"
                    : "app")
        };
    }

    async function installXiomeMock(config = readXiomeMock()) {
        const xiome = await assembleXiomeMock(config);
        document.body.prepend(xiome.modalsElement);
        registerComponents(xiome.components);
        window.xiome = xiome;
        return xiome;
    }

    installXiomeMock();

})();
//# sourceMappingURL=xiome-mock.bundle.js.map
