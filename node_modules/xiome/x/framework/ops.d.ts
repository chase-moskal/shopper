export declare namespace Ops {
    enum Mode {
        None = 0,
        Loading = 1,
        Error = 2,
        Ready = 3
    }
    interface None {
        mode: Ops.Mode.None;
    }
    interface Loading {
        mode: Ops.Mode.Loading;
    }
    interface Error {
        mode: Ops.Mode.Error;
        reason: string;
    }
    interface Ready<xValue> {
        mode: Ops.Mode.Ready;
        value: xValue;
    }
}
export type Op<xValue> = Ops.None | Ops.Loading | Ops.Error | Ops.Ready<xValue>;
export declare const ops: {
    none: () => Ops.None;
    loading: () => Ops.Loading;
    error: (reason: string) => Ops.Error;
    ready: <xValue>(value: xValue) => Ops.Ready<xValue>;
    replaceValue<xValue_1>(op: Op<any>, value: xValue_1): Op<xValue_1>;
    isNone: <xValue_2>(op: Op<xValue_2>) => boolean;
    isLoading: <xValue_3>(op: Op<xValue_3>) => boolean;
    isError: <xValue_4>(op: Op<xValue_4>) => boolean;
    isReady: <xValue_5>(op: Op<xValue_5>) => boolean;
    value<xValue_6>(op: Op<xValue_6>): xValue_6;
    select<xValue_7, xResult = any>(op: Op<xValue_7>, options: {
        none: () => xResult;
        loading: () => xResult;
        error: (reason: string) => xResult;
        ready: (value: xValue_7) => xResult;
    }): xResult;
    operation<xValue_8>({ promise, errorReason, setOp, }: {
        errorReason?: string;
        promise: Promise<xValue_8>;
        setOp: (op: Op<xValue_8>) => unknown | Promise<unknown>;
    }): Promise<xValue_8>;
    mode(op: Op<any>): string;
    combine(...ops: Op<any>[]): Op<void>;
    debug(op: Op<any>): any[];
};
