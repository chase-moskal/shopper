import { and } from "../helpers.js";
import { isTable } from "./is-table.js";
import { objectMap } from "../tools/object-map.js";
export function constrain({ table, constraint, }) {
    const spike = (conditionTree) => (conditionTree
        ? and({ equal: constraint }, conditionTree)
        : and({ equal: constraint }));
    return {
        async create(...rows) {
            return table.create(...rows.map(row => ({ ...row, ...constraint })));
        },
        async read(options) {
            return table.read({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async readOne(options) {
            return table.readOne({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async update(options) {
            const opts = options;
            return table.update({
                ...options,
                conditions: spike(options.conditions),
                upsert: opts.upsert
                    ? { ...opts.upsert, ...constraint }
                    : undefined,
                whole: opts.whole
                    ? { ...opts.whole, ...constraint }
                    : undefined,
                write: opts.write
                    ? { ...opts.write, ...constraint }
                    : undefined,
            });
        },
        async delete(options) {
            return table.delete({
                ...options,
                conditions: spike(options.conditions),
            });
        },
        async count(options) {
            return table.count({
                ...options,
                conditions: spike(options.conditions),
            });
        },
    };
}
export function constrainTables({ tables, constraint }) {
    function recurse(t) {
        return objectMap(t, value => isTable(value)
            ? constrain({ constraint, table: value })
            : recurse(value));
    }
    return recurse(tables);
}
//# sourceMappingURL=constraints.js.map