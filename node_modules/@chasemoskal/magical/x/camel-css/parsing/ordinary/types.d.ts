export interface Source {
    code: string;
}
export interface Cursor {
    index: number;
    line: number;
    column: number;
}
export interface Trace {
    cursor: Cursor;
    length: number;
}
export type MakeTrace = (valueLength?: number) => Trace;
export interface LexerResult<xToken extends Token.Any = Token.Any> {
    token: xToken;
    newIndex: number;
}
export type Lexer<xToken extends Token.Any> = (source: Source, cursor: Cursor) => undefined | LexerResult<xToken>;
export declare namespace Token {
    enum Type {
        Open = 0,
        Close = 1,
        RuleName = 2,
        RuleValue = 3,
        SlashSlashComment = 4
    }
    interface Base {
        type: Type;
        trace: Trace;
    }
    interface Open extends Base {
        type: Type.Open;
        selector: string;
    }
    interface Close extends Base {
        type: Type.Close;
    }
    interface RuleName extends Base {
        type: Type.RuleName;
        name: string;
    }
    interface RuleValue extends Base {
        type: Type.RuleValue;
        value: string;
    }
    interface SlashSlashComment extends Base {
        type: Type.SlashSlashComment;
        value: string;
    }
    type Any = (Open | Close | RuleName | RuleValue | SlashSlashComment);
}
export declare function asLexers<xLexers extends {
    [key: string]: Lexer<Token.Any>;
}>(lexers: xLexers): xLexers;
export declare function asToken<xToken extends Token.Base>(token: xToken): xToken;
